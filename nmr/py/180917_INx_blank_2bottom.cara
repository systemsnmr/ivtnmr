</project>
<script name='AssignmentReport'>
<code lang='Lua'>-- script to report missing assignments &amp; unusual shifts in a project
-- at the end of the report, a summary of assignment completeness is given
--   statistics of assignments: number assigned/missing, percentage in catagories:
--    H, C, N, Backbone, Sidechain, Triple Resonance, Aromatic, Aliphatic, Carbonyl

-- No need to edit this script. Just run it and select desired options.

-- reports: atoms with no assignments in each residue with at least one missing assignment.
-- options to:
-- report on H atoms only or all atoms (H,C,N)
-- report atoms with unusual shifts (outside the "dev" value for the ResidueType)
-- report only H atoms attatched to C or N (ignore OH and SH)
-- report only Heteroatoms attatched to H (ignore tertiary C and N)
-- at the end of the report, a summary is given

-- Version summary

-- Version 1: June 17 2004 F.Damberger

-- Version 2: Feb.22.2005 F.Damberger

-- Added the summary to report (percentage of H,C, and N assignments)
-- fixed a problem: Spins with no System assignment are now ignored

-- Version 3: Mar 26 2005 F. Damberger

-- Added menu window to set all options at once and keep them in memory
-- added option to report H atoms attatched to C,N only (ignores OH, SH)
-- added statistics on Backbone (BB) and Sidechain (SC) resonances
-- added parameter to adjust cutoff for unusual shifts (SDmult)

-- Version 4: Apr 20 2005 F. Damberger

-- Added the calculation of average shift deviations to summary
-- This detects errors in chemical shift calibration
-- Large offsets from zero indicate systematic shifts in the chemical shifts.

-- Version 5: Jun 09 2005 F.Damberger

-- Corrected a bug which resulted in an error messsage:
-- Attempt to concatenate global Formatted_SDmult (a nil value)
-- when "Include Outliers" checkbox was not selected. 
-- Also added an escape error if no project is present.

-- Remark on aromatic rings with symmetry related atoms:

-- If the input includes assignments for HD1 but not HD2 of a PHE, HD2 will be flagged as unassigned
-- It is up to the user whether (s)he should assign a pseudoatom HD (in which case HD1 and HD2 are counted as assigned)

-- Same thing applies to CD1 and CD2 of PHE: Even though CD1 and CE1 are assigned, script will report
-- CD2 and CE2 as unassigned.
-- User must reassign CD1 to CD group to avoid counting CD2 as unassigned.

-- Version 6: Oct.19 2005 F.Damberger

-- Declared the variables in functions as local to avoid unexpected effects
-- Changed the loop through sequence so the sequence order is correct (for a,b in pairs(t.Seq) does not follow the sequence)
-- Added a summary line for total number of assignments

-- Version 7: Jul.24 2006 F.Damberger

-- Added a summary of assignments for triple resonance spectra (percentage of H, N, CA, CB, C resonances)
-- Added a summary of assignments for aromatic resonances
-- Added reporting of Pseudoatom conflicts
--   If both pseudoatoms and the corresponding real atoms are assigned
--   script reports this.
--   E.g. if both pseudoatom HB and real atom HB2 were assigned in an ASN.

-- Version 8: Nov. 16 2007 F.Damberger

-- Added statistics for carbonyl carbons (side chain &amp; backbone are considered together)

-- Structure of the script:

-- Define Functions
-- Set up menu window for user preferences
-- Run analysis and store in table
-- Output results from table

Version = 8
Date = "16. Nov. 2007"

-- ----------------------------------------------------------------------


-- create array for script variables
t = {}



-- ----------------------------------------------------------------------

-- =================== Define Functions =================================

-- Function CorNatomIsAttatched
function CorNatomIsAttatched( Atom )
	Neighbours = Atom:getNeighbours()
	local Result = false
	local AtomLabel,AtomNeighbour
	for AtomLabel,AtomNeighbour in pairs( Neighbours ) do
		if AtomNeighbour:getAtomType() == "C"or AtomNeighbour:getAtomType() == "N" then
			Result = true
		end
	end
	return Result
end -- function CorNatomIsAttatched
-- ----------------------------------------------------------------------

-- ----------------------------------------------------------------------

-- Function HatomIsAttatched
function HatomIsAttatched( Atom )
	Neighbours = Atom:getNeighbours()
	local Result = false
	local AtomLabel,AtomNeighbour
	for AtomLabel,AtomNeighbour in pairs( Neighbours ) do
		if AtomNeighbour:getAtomType() == "H" then
			Result = true
		end
	end
	return Result
end -- function HatomIsAttatched
-- ----------------------------------------------------------------------

-- ----------------------------------------------------------------------

-- Function BackboneLabel
function BackboneLabel ( TheLabel, TheBackboneLabels )
	local Result = false
	local Index,BBLabel
	for Index,BBlabel in pairs( TheBackboneLabels ) do
		if TheLabel == BBlabel then
			Result = true
		end
	end
	return Result
end
-- ----------------------------------------------------------------------

-- ----------------------------------------------------------------------

-- Function ReportPercent
function ReportPercent( Number, Total )
	local Percent
	if Total &gt; 0  and Number &gt; 0 then
		Percent = 100 * Number / Total
		Percent = string.format( "%7.3f", Percent )
	else
		Percent = "ND"
	end
	return Percent
end

-- ----------------------------------------------------------------------

-- Function SideChainAromatic
function SideChainAromatic( Res, AtomLabel )
	local AromaticRes = { "PHE", "TYR", "TRP", "HIS" }
	local AmxLabels = { "HN", "H", "N", "C", "CA", "HA", "CB", "HB2", "HB3" }
	local IsAromaticSideChain = false -- assume it is not aromatic res, next try to disprove
	local Id,AroRes
	for Id,AroRes in pairs( AromaticRes ) do
		if Res:getType():getShort() == AroRes then
			IsAromaticSideChain = true -- assume it is aromatic sc, next try to disprove
			for Id,AmxAtomName in pairs( AmxLabels ) do
				if AtomLabel == AmxAtomName then
					IsAromaticSideChain = false
				end
			end -- for all Amx labels
		end -- if Aromatic Residue
	end -- for all aromatic residue names
	return IsAromaticSideChain
end -- function SideChainAromatic

function SortedSequenceIndex( Sequence )
	local i = 1
	Index = {}
	local a,b
	for a,b in pairs( Sequence ) do
		Index[i] = a
		i = i + 1
	end
	table.sort( Index )
	return Index
end -- function SortedSequenceIndex

function TableSize( Table ) -- added in ver.4
	local Size = 0
	for IdNum,Entry in pairs( Table ) do
		Size = Size + 1
	end -- for
	return Size
end -- function TableSize

function IsOfClass( Atom, ClassName ) -- added in ver.7
	result = false
	if ClassName == "H atoms" then
		if Atom:getAtomType() == "H" then result = true end -- include if it is an H atom
	elseif ClassName == "Backbone" then
		for IdNum,Label in pairs( AssignmentReport_BackboneLabels ) do
			if Atom:getName() == Label then result = true end
		end -- for all BBlabels
	elseif ClassName == "Triple" then
		for IdNum,Label in pairs( AssignmentReport_TripleLabels ) do
			if Atom:getName() == Label then result = true end
		end -- for all TripleLabels
	else -- all labels
		result = true
	end -- if ClassName = X
	return result
end -- function IsOfClass

function CheckForPseudoAtomConflicts( Sys, Group ) -- added in ver.7 
	-- purpose: check for conflicts between the assigned pseudoatom and assigned real atoms
	--          Either the pseudoatom or real atoms should be assigned, but not both.
	-- HERE is PseudoCode for this PseudoFunction (that's a programmers joke)
	--          if Conflict then
	--              return a line of text reporting the conflicts
	--          else
	--              return nil
	--          end
	
	-- INITIALIZE VARIABLES
	NumConflicts = 0
	ConflictsTable = {} -- create empty list of Spin Labels that conflict with the assigned pseudoatom

	-- LOOP THROUGH ALL ATOMS in GROUP
	for AtomNameOfGroup,AtomOfGroup in pairs( Group:getAtoms() ) do
		for SpinId,Spin in pairs( Sys:getSpins() ) do
			if Spin:getLabel() == AtomNameOfGroup then
				-- add to list
				NumConflicts = NumConflicts + 1
				ConflictsTable[ NumConflicts ] = AtomNameOfGroup
			end
		end -- for all spins in System
	end -- for all Atoms in Group
	
	-- GENERATE RESULT
	if NumConflicts == 0 then
		PseudoAtomConflictResult = nil
	else
		PseudoAtomConflictResult = "PseudoAtom "..Group:getName().." has conflicting assignments: "
		for Index=1,NumConflicts do
			PseudoAtomConflictResult = PseudoAtomConflictResult.."  "..ConflictsTable[ Index ]
		end -- for all elements of table ConflictList
	end -- if NumConflicts == 0
	
	return PseudoAtomConflictResult
end -- funtion CheckForPseudoAtomConflicts

function AtomNameFromResType( Label, ResType )  -- added in ver.7
	-- purpose: return true if label occurs in ResType
	local result = nil
	for AtomName,Atom in pairs( ResType:getAtoms() ) do
		if Label == AtomName then
			result = true
		end
	end -- for all atoms in ResType
	return result
end -- function AtomNameFromResType

function IsAromaticRes( ResName ) -- added in ver.7
	AromaticResNames = { "HIS", "PHE", "TRP", "TYR" }
	local result = nil
	for Id,AroResName in pairs( AromaticResNames ) do
		if ResName == AroResName then
			result = true
		end
	end -- for all members of AromaticResNames
	return result
end -- function IsAromaticRes

function IsAromaticAtom( Atom, ResName ) -- added in ver.7 -- (OK, this is redundant with function SideChainAromatic, so sue me. FFD)
	if cara:getResidueType( "BB" ) == nil then -- escape if the residueType BB is missing
		error( "The ResidueType BB could not be found. This script should be run with Template Start.1.3.cara. ")
	end
	if IsAromaticRes( ResName ) and not AtomNameFromResType( Atom:getName(), cara:getResidueType( "BB" ) ) then
		result = true -- its in an aromatic residue and it is not part of the AMX spin system
	else
		result = nil
	end
	return result
end --function IsAromaticAtom

function IsCarbonylCarbon( Atom )
	NeighbourAtoms = Atom:getNeighbours()
	if not TableSize( NeighbourAtoms ) then return false end -- Carbonyl carbons have 3-attatched atoms
	for AtId,At in pairs( NeighbourAtoms ) do -- search for attatched carbonyl oxygen
		if At:getAtomType() == "O" then
			if TableSize( At:getNeighbours() ) == 1 then return true end
		end
	end
	return false
end

--===================END OF FUNCTION DEFINITIONS ========================


-- ================== SOME PARAMETER DEFINITIONS ========================

AssignmentReport_BackboneLabels = { "HN", "H", "N", "C", "CA", "HA", "HA1", "HA2", "HA3" } -- I include both XEASY and IUPAC nomenclature
AssignmentReport_TripleLabels = { "HN", "H", "N", "C", "CA", "CB" } -- I include both XEASY and IUPAC nomenclature

-- Define BackboneLabelsText
BackboneLabelsText = "Backbone Labels : "
for Index,CurrentLabel in pairs( AssignmentReport_BackboneLabels ) do
	BackboneLabelsText = BackboneLabelsText.." "..CurrentLabel
end -- for all Labels in BackboneLabels Table

-- Define TripleLabelsText
TripleLabelsText = "Triple Resonance Labels : "
for Index,CurrentLabel in pairs( AssignmentReport_TripleLabels ) do
	TripleLabelsText = TripleLabelsText.." "..CurrentLabel
end -- for all Labels in TripleLabels Table


-- ============Set up menu window for user preferences===================

--0. Check whether there are any projects available
ProjectsTable = cara:getProjects()

if TableSize( ProjectsTable ) == 0 then error("No projects found in repository") end


--1. Create main menu window

v = gui.createMainWindow()
v:setCaption( "AssignmentReport Preferences" )
t.frm = gui.createGrid( v, 2, false )
v:setCentralWidget( t.frm )
v:show()
t.frm:show()

-- Labels for first two columns
t.ProjectListLabel = gui.createLabel( t.frm, "Select Project" )
t.ProjectListCB = gui.createComboBox( t.frm )


--2. Read ProjectNames into ProjectList combobox

SelectedItemIndex = nil
for Id,Project in pairs( cara:getProjects() ) do
	ItemIndex = t.ProjectListCB:addItem( Project:getName() )
	t.ProjectListCB:setCurrentItem( ItemIndex )
	if AssignmentReportProjectName == t.ProjectListCB:getCurrentText() then
		SelectedItemIndex = ItemIndex
	end
end -- for all projects

-- stop if no projects found

if SelectedItemIndex then -- set to previous choice if it exists
	t.ProjectListCB:setCurrentItem( SelectedItemIndex )
end

-- Display ProjectList Combobox
t.ProjectListLabel:show()
t.ProjectListCB:show()

--3. Determine Output report location ------------------------------------

SelectedItemIndex = nil
t.OutputMethodCBLabel = gui.createLabel( t.frm, "Output sent to" )
t.OutputMethodCB = gui.createComboBox( t.frm )

-- Add Item "File" to ComboBox
ItemIndex = t.OutputMethodCB:addItem( "file" )
t.OutputMethodCB:setCurrentItem( ItemIndex )
if AssignmentReportOutputMethod == t.OutputMethodCB:getCurrentText() then
	SelectedItemIndex = ItemIndex
end

-- Add Item "terminal window" to ComboBox
ItemIndex = t.OutputMethodCB:addItem( "terminal window" )
t.OutputMethodCB:setCurrentItem( ItemIndex )
if AssignmentReportOutputMethod == t.OutputMethodCB:getCurrentText() then
	SelectedItemIndex = ItemIndex
end

-- Determine if an output method was selected already
if SelectedItemIndex then
	t.OutputMethodCB:setCurrentItem( SelectedItemIndex )
end

-- Display Label and Combobox for Output Method 
t.OutputMethodCBLabel:show()
t.OutputMethodCB:show()

--4. Determine Output file name ------------------------------------------

-- Create Label and Combobox for Filename
t.FilenameLELabel = gui.createLabel( t.frm, "filename for output" )
t.FilenameLE = gui.createLineEdit( t.frm )

if AssignmentReportFilename then -- determine if Filename already exists
	t.FilenameLE:setText( AssignmentReportFilename )
else
	t.FilenameLE:setText( "AssignmentReport.txt" ) -- default name
end

-- Display Label and LineEdit window
t.FilenameLELabel:show()
t.FilenameLE:show()


--5. Read AtomTypesToInclude choices into AtomTypesToInclude combobox ---------------

-- Create Label and Combobox for AtomTypesToInclude
t.AtomTypesToIncludeCBLabel = gui.createLabel( t.frm, "Select AtomTypes to include" )
t.AtomTypesToIncludeCB = gui.createComboBox( t.frm )

SelectedItemIndex = nil
-- Add Item "H atoms only" to Combobox
ItemIndex = t.AtomTypesToIncludeCB:addItem( "H atoms only" )
t.AtomTypesToIncludeCB:setCurrentItem( ItemIndex )
if AssignmentReportAtomTypesToInclude == t.AtomTypesToIncludeCB:getCurrentText() then
	SelectedItemIndex = ItemIndex
end

-- Add Item "all atoms" to Combobox
ItemIndex = t.AtomTypesToIncludeCB:addItem( "all atoms" )
t.AtomTypesToIncludeCB:setCurrentItem( ItemIndex )
if AssignmentReportAtomTypesToInclude == t.AtomTypesToIncludeCB:getCurrentText() then
	SelectedItemIndex = ItemIndex
end

if SelectedItemIndex then -- determine if selected previously
	t.AtomTypesToIncludeCB:setCurrentItem( SelectedItemIndex )
end

-- Display Label and Combobox
t.AtomTypesToIncludeCBLabel:show()
t.AtomTypesToIncludeCB:show()

-- Checkboxes follow ------------------------------------------

--4. Checkbox ReportOnlyHatomsAttatchedToCorN

t.ReportOnlyHatomsAttatchedToCorN_ChBxLabel = gui.createLabel( t.frm, "Report only H attatched to C or N" )
t.ReportOnlyHatomsAttatchedToCorN_ChBx = gui.createCheckBox( t.frm )

if ReportOnlyHatomsAttatchedToCorN == "YES" then
	t.ReportOnlyHatomsAttatchedToCorN_ChBx:setChecked()
end
t.ReportOnlyHatomsAttatchedToCorN_ChBxLabel:show()
t.ReportOnlyHatomsAttatchedToCorN_ChBx:show()


--5. Checkbox ReportOnlyHeteroAtomsAttatchedToH

t.ReportOnlyHeteroAtomsAttatchedToH_ChBxLabel = gui.createLabel( t.frm, "Report only heteroatoms attatched to H" )
t.ReportOnlyHeteroAtomsAttatchedToH_ChBx = gui.createCheckBox( t.frm )

if ReportOnlyHeteroAtomsAttatchedToH == "YES" then
	t.ReportOnlyHeteroAtomsAttatchedToH_ChBx:setChecked()
end
t.ReportOnlyHeteroAtomsAttatchedToH_ChBxLabel:show()
t.ReportOnlyHeteroAtomsAttatchedToH_ChBx:show()

--6. Checkbox IncludeAssignedSpins

t.IncludeAssignedSpins_ChBxLabel = gui.createLabel( t.frm, "Report assigned atoms" )
t.IncludeAssignedSpins_ChBx = gui.createCheckBox( t.frm )

if IncludeAssignedSpins == "YES" then
	t.IncludeAssignedSpins_ChBx:setChecked()
end

t.IncludeAssignedSpins_ChBxLabel:show()
t.IncludeAssignedSpins_ChBx:show()

--7. Checkbox IncludeOutliers

t.IncludeOutliers_ChBxLabel = gui.createLabel( t.frm, "Report outliers (unusual chemical shifts)" )
t.IncludeOutliers_ChBx = gui.createCheckBox( t.frm )

if IncludeOutliers == "YES" then
	t.IncludeOutliers_ChBx:setChecked()
end

t.IncludeOutliers_ChBxLabel:show()
t.IncludeOutliers_ChBx:show()

--8. SDmult field

-- Some notes on variables:
-- AssignmentReport_SDmult : holds the value of SDmult previously set by the user
-- SDmult_Repository       : holds the value of SDmult used to generate the "dev" values in the residueTypes of the repository
-- 

t.SDmult_LELabel = gui.createLabel( t.frm, "Enter SDmult ( chemical shift cutoff = SDmult*SD )" )
t.SDmult_LE = gui.createLineEdit( t.frm )

if AssignmentReport_SDmult and SDmult_Repository then
	-- print("User defined SDmult : "..AssignmentReport_SDmult.."\nRepository value of SDmult : "..SDmult_Repository)
	t.SDmult_LE:setText( AssignmentReport_SDmult )
else
	-- print("Calculating SDmult of ResidueTypes in Repository.")
	t.ProjectName = t.ProjectListCB:getCurrentText()
	t.Project = cara:getProject( t.ProjectName )
	ResTypes = cara:getResidueTypes()
	SDmult_Sum = 0; Num_SDmult = 0;
	for ResTypName,ResTyp in pairs( ResTypes) do
		SDmult_Res = ResTyp:getAttr( "SDmult" )
		if SDmult_Res then
			SDmult_Sum = SDmult_Sum + SDmult_Res
			Num_SDmult = Num_SDmult + 1
		end -- if SDmult_Res exists
	end -- for all Residue Types in Repository
	if Num_SDmult == 0 then
		t.SDmult_LELabel:setText( "No SDmult value found in repository. Assuming it is 4.0. Enter SDmult for analysis:")
		AssignmentReport_SDmult = 4.0
		SDmult_Repository = 4.0
		t.SDmult_LE:setText( AssignmentReport_SDmult )
	else
		SDmult_Repository = SDmult_Sum / Num_SDmult
		AssignmentReport_SDmult = SDmult_Repository
		t.SDmult_LE:setText( SDmult_Repository )
	end -- if SDmult values defined for repository
	-- print("User defined SDmult : "..AssignmentReport_SDmult.."\nRepository value of SDmult : "..SDmult_Repository)
end -- if SDmult set previously

t.SDmult_LELabel:show()
t.SDmult_LE:show()

--9. OK and Cancel Buttons

t.okbutton = gui.createPushButton(t.frm, "OK" )
t.cancelbutton = gui.createPushButton( t.frm, "Cancel" )

t.okbutton:show()
t.cancelbutton:show()


-- ============Callbacks for menu window ===================

-- Define Callbacks for the buttons

-- SDmult lineEdit Callback
t.SDmult_LE:setCallback( gui.event.Changed,
	function (self)
		-- function actions
		-- check if a number was entered:
		StartChar,EndChar,NumberRetrieved = string.find( t.SDmult_LE:getText(), "(%d+)" )
		StartChar,EndChar,HalfFloatRetrieved = string.find( t.SDmult_LE:getText(), "(%d+)." )
		StartChar,EndChar,FloatRetrieved = string.find( t.SDmult_LE:getText(), "(%d+.%d+)" )
		Value = nil
		if NumberRetrieved then Value = NumberRetrieved end
		if HalfFloatRetrieved then Value = HalfFloatRetrieved end
		if FloatRetrieved then Value = FloatRetrieved end
		if Value then
			AssignmentReport_SDmult = Value
		else
			t.SDmult_LELabel:setText( "SDmult value: Please enter a number or floating point value: " )
		end -- if Value found
		
	end -- function self
) -- end SDmult_LE Callback


-- cancel button Callback
t.cancelbutton:setCallback( gui.event.Clicked,
	function (self)
		v:close()
	end
) -- end cancel button Callback

-- OK button Callback
t.okbutton:setCallback( gui.event.Clicked,
	function (self)
-- =============== Determine User Preferences ===========================

		t.P = cara:getProject( t.ProjectListCB:getCurrentText() )
		AssignmentReportProjectName = t.P:getName()
		AssignmentReportOutputMethod = t.OutputMethodCB:getCurrentText()
		AssignmentReportFilename = t.FilenameLE:getText()
		AssignmentReportAtomTypesToInclude = t.AtomTypesToIncludeCB:getCurrentText()
		if AssignmentReport_SDmult + 0 &lt;= 0 then error( "SDmult must be a positive floating point or number") end
		if SDmult_Repository + 0 &lt;= 0 then error( "SDmult for repository must be a positive floating point or number") end
		Formatted_SDmult = string.format( "%3.1f", AssignmentReport_SDmult )

		if t.ReportOnlyHatomsAttatchedToCorN_ChBx:isChecked() then
			ReportOnlyHatomsAttatchedToCorN = "YES"
		else
			ReportOnlyHatomsAttatchedToCorN = "NO"
		end
		if t.ReportOnlyHeteroAtomsAttatchedToH_ChBx:isChecked() then
			ReportOnlyHeteroAtomsAttatchedToH = "YES"
		else
			ReportOnlyHeteroAtomsAttatchedToH = "NO"
		end
		if t.IncludeAssignedSpins_ChBx:isChecked() then
			IncludeAssignedSpins = "YES"
		else
			IncludeAssignedSpins = "NO"
		end
		if t.IncludeOutliers_ChBx:isChecked() then
			IncludeOutliers = "YES"
		else
			IncludeOutliers = "NO"
		end
-- ============== Run analysis ===========================================
-- cycle through all residues and report missing assignments

		t.Seq = t.P:getSequence()
		
		NumHfound = 0
		NumHAROfound = 0
		NumHALIfound = 0
		NumCfound = 0
		NumCAROfound = 0
		NumCALIfound = 0
		NumCOfound = 0
		NumNfound = 0
		NumBBfound = 0
		NumSCfound = 0
		NumHmissing = 0
		NumHAROmissing = 0
		NumHALImissing = 0
		NumCmissing = 0
		NumCAROmissing = 0
		NumCALImissing = 0
		NumCOmissing = 0
		NumNmissing = 0
		NumBBmissing = 0
		NumSCmissing = 0
		NumTRIPLEfound = 0 -- atoms identified in triple res expts
		NumTRIPLEmissing = 0
		NumAROfound = 0 -- atoms identified in triple res expts
		NumAROmissing = 0
		
		i=1
		t.Lines = {}
--		t.ReportOnlyHatomsAttatchedToCorN = temp2 -- TEST ONLY
		
		-- Generate Header to Report
		t.Lines[ i ] = "\nAssignment Report for Project "..AssignmentReportProjectName.."\n"
		i = i + 1
		t.Lines[ i ] = "\nAssignmentReport gives a list of all missing atom assignments\nin each residue and summarizes the completeness of the assignments.\n"
		i = i + 1
		t.Lines[ i ] = "It has options to include the assigned atoms, and to identify\nunusual shifts (|shift - ave| &gt; SDmult*SD)\n"
		i = i + 1
		t.Lines[ i ] = " It additionally checks for conflicting assignment of both pseudoatom and real atoms\n(redundant assignments: e.g. HB and HB2 of ASN). \n"
		i = i + 1
		t.Lines[ i ] = "It also checks for large average deviations from database shifts\n which indicate possible calibration errors. See bottom of report."
		i = i + 1
		t.Lines[ i ] = "\n---------------------------------------------------------\nUser selected options are given below.\n-------------------------------------------------\n"
		i = i + 1
		t.Lines[ i ] = "Report of "..AssignmentReportAtomTypesToInclude.." (unassigned).\n"
		i = i + 1
		t.Lines[ i ] = "Report only H attatched to C or N? .. "..ReportOnlyHatomsAttatchedToCorN.."\n"

		if AssignmentReportAtomTypesToInclude == "all atoms" then
			i = i + 1
			t.Lines[ i ] = "Report only heteroatoms attatched to H? .. "..ReportOnlyHeteroAtomsAttatchedToH.."\n"
		end
		i = i + 1
		t.Lines[ i ] = "Include assigned atoms? .. "..IncludeAssignedSpins.."\n"
		i = i + 1
		t.Lines[ i ] = "Include outliers (unusual chemical shifts)? .. "..IncludeOutliers.."\n"
		if t.IncludeOutliers_ChBx:isChecked() then
			i = i + 1
--			Formatted_SDmult = string.format( "%3.1f", AssignmentReport_SDmult )
			t.Lines[ i ] = "Outliers have chemical shift deviations: &gt;"..Formatted_SDmult.."*SD\n"
		end
		i = i + 1
		t.Lines[ i ] = "------------------------------------------------\n"		
		i = i + 1
		t.Lines[ i ] = "A summary of the results is given at the bottom."
		-- finished generating header report
		CountResWithOutliers = 0
		NumResWithOutliers = 0
		t.OutlierSummary = nil
		CountResWithConflicts = 0
		NumResWithConflicts = 0
		t.PseudoAtomConflictsSummary = nil
		H_outliers = 0
		Haro_outliers = 0
		Hali_outliers = 0
		C_outliers = 0
		Caro_outliers = 0
		Cali_outliers = 0
		CO_outliers = 0
		N_outliers = 0
		BB_outliers = 0
		SC_outliers = 0
		t.DevH_total = 0
		t.DevH_number = 0
		t.DevC_total = 0
		t.DevC_number = 0
		t.DevN_total = 0
		t.DevN_number = 0
		t.DevHali_total = 0
		t.DevHali_number = 0
		t.DevHaro_total = 0
		t.DevHaro_number = 0
		t.DevCali_total = 0
		t.DevCali_number = 0
		t.DevCaro_total = 0
		t.DevCaro_number = 0
		t.DevCO_total = 0
		t.DevCO_number = 0
		t.DevNali_total = 0
		t.DevNali_number = 0
		PseudoAtomCount = 0
		NumAssignedInTotal = 0
		NumPseudoAtomsAssignedInTotal = 0
		NumPseudoAtomConflictsInTotal = 0
		SortedIndex = SortedSequenceIndex( t.Seq )


if Debug then
	for Id=1,table.getn( SortedIndex ) do
		ResId=SortedIndex[ Id ]
		Res=t.Seq[ SortedIndex[ Id ] ]
		print(ResId,Res:getType():getShort())
	end
end

--		for ResNum,Res in pairs( t.Seq ) do -- LUA does not output in sequential order using this
		for Indx = 1,table.getn( SortedIndex ) do
			ResNum = SortedIndex[ Indx ]
			Res = t.Seq[ SortedIndex[ Indx ] ]
			
			t.Assigned = " "
			t.Unassigned = " "
			t.PseudoAtomConflicts = " "
			t.Res = t.P:getResidue( ResNum )
			t.Typ = t.Res:getType()
			t.Name = t.Typ:getShort()
			t.Atoms = t.Typ:getAtoms()
			t.Sys = t.Res:getSystem()
			num_outliers = 0
			CountUnassigned = 0
			NumAssignedForRes = 0
			NumUnassignedForRes = 0
			NumPseudoAtomConflicts = 0
		
			for AtomId,Atom in pairs( t.Atoms ) do			
				SpinAssigned = false
				
				-- Determine whether this Atom should be included in report
				
				t.ReportThisAtom = "false"
				if AssignmentReportAtomTypesToInclude == "H atoms only" then
					if Atom:getAtomType() == "H" then
						if ReportOnlyHatomsAttatchedToCorN == "YES" then
							if CorNatomIsAttatched( Atom ) then
								t.ReportThisAtom = "true"
							end
						else -- report all H atoms
							t.ReportThisAtom = "true"
						end -- if ReportOnlyHatomsAttatchedToCorN
					end -- if AtomType = "H"
				elseif AssignmentReportAtomTypesToInclude == "all atoms" then
					if Atom:getAtomType() ~= "O" and Atom:getAtomType() ~= "S" then
						if Atom:getAtomType() == "H" then
							if ReportOnlyHatomsAttatchedToCorN == "YES" then
								if CorNatomIsAttatched( Atom) then
									t.ReportThisAtom = "true"
								end
							else -- report all H atoms
								t.ReportThisAtom = "true"
							end -- if t.ReportOnlyHatomsAttatchedToCorN2
						else -- atom is not H
							if ReportOnlyHeteroAtomsAttatchedToH == "YES" then
								if HatomIsAttatched( Atom ) then
									t.ReportThisAtom = "true"
								end
							else -- report all HeteroAtoms
								t.ReportThisAtom = "true"
							end --if AttatchedHeteroAtomIsCorN
						end -- if AtomType == "H"
					end -- if AtomType is not O or S
				else -- AssignmentReportAtomTypesToInclude does not match one of the available choices
						t.ReportThisAtom = "false"
				end
				
				-- Determine whether the atom is assigned or not
					
				if t.ReportThisAtom == "true" then
					t.AtomName = Atom:getName()
					local AtomNameForm = string.format( "%5s", t.AtomName )
					if Atom:getGroup() ~= nil then -- get Group and GroupName (PseudoAtoms)
						t.Group = Atom:getGroup()
						t.GroupName = Atom:getGroup():getName()
					else
						t.Group = nil
						t.GroupName = nil
					end
					if t.Sys then
						for SpinId,Spin in pairs( t.Sys:getSpins() ) do
							if ( t.AtomName == Spin:getLabel() or t.GroupName == Spin:getLabel() ) then -- Spin's label matches the AtomName or it's GroupName then it's assigned
								SpinAssigned = true
								--NumAssignedForRes = NumAssignedForRes + 1
								if t.GroupName == Spin:getLabel() then
									IsPseudoAtom = true
									--print("pseudo:"..t.Name..ResNum.." "..Spin:getLabel() )
								else
									IsPseudoAtom = false
								end
								if IncludeOutliers == "YES" then
								-- compare chemical shifts &amp; write into t.Outliers if needed
									t.LibraryAve,t.LibrarySd = t.Res:getValue( Atom:getName() )
									t.LibrarySd = ( AssignmentReport_SDmult / SDmult_Repository ) * t.LibrarySd
									t.Shift = Spin:getShift()
									t.Dev = t.Shift - t.LibraryAve
									-- Keep track of average deviation for sidechain shifts of atom types H,C,N
									if Atom:getAtomType() == "H" then -- track H atom average dev
										t.DevH_number = t.DevH_number + 1
										t.DevH_total = t.DevH_total + t.Dev
										if SideChainAromatic( Res, t.AtomName ) then -- aromatic sidechain
											t.DevHaro_number = t.DevHaro_number + 1
											t.DevHaro_total = t.DevHaro_total + t.Dev
										else
											t.DevHali_number = t.DevHali_number + 1
											t.DevHali_total = t.DevHali_total + t.Dev
										end
									elseif Atom:getAtomType() == "C" then -- track C atom average dev
										t.DevC_number = t.DevC_number + 1
										t.DevC_total = t.DevC_total + t.Dev
										if not SideChainAromatic( Res, t.AtomName ) and not IsCarbonylCarbon( Atom ) then -- aliphatic sidechain
											t.DevCali_number = t.DevCali_number + 1
											t.DevCali_total = t.DevCali_total + t.Dev
										elseif not IsCarbonylCarbon( Atom ) then -- is sidechain aromatic
											t.DevCaro_number = t.DevCaro_number + 1
											t.DevCaro_total = t.DevCaro_total + t.Dev
										else                                -- is carbonyl carbon
											t.DevCO_number = t.DevCO_number + 1
											t.DevCO_total = t.DevCO_total + t.Dev
										end
									elseif Atom:getAtomType() == "N" then -- track N atom average dev
										t.DevN_number = t.DevN_number + 1
										t.DevN_total = t.DevN_total + t.Dev
										if not SideChainAromatic( Res, t.AtomName ) then -- aliphatic sidechain
											t.DevNali_number = t.DevNali_number + 1
											t.DevNali_total = t.DevNali_total + t.Dev
										end
									end
									
									-- Check whether shift is unusual
									if t.Dev &gt; t.LibrarySd or t.Dev &lt; -1 * t.LibrarySd then
										-- count total number of outliers
										num_outliers = num_outliers + 1
										if Atom:getAtomType() == "H" then
											H_outliers = H_outliers + 1
											if IsAromaticAtom( Atom, t.Name ) then
												Haro_outliers = Haro_outliers + 1
											else
												Hali_outliers = Hali_outliers + 1
											end
										elseif Atom:getAtomType() =="C" then
											C_outliers = C_outliers + 1
											if IsAromaticAtom( Atom, t.Name ) then
												Caro_outliers = Caro_outliers + 1
											elseif not IsCarbonylCarbon then
												Cali_outliers = Cali_outliers + 1
											else
												CO_outliers = CO_outliers + 1											
											end
										elseif Atom:getAtomType() == "N" then
											N_outliers = N_outliers + 1
										end
										if BackboneLabel( t.AtomName, AssignmentReport_BackboneLabels ) then
											BB_outliers = BB_outliers + 1
										else
											SC_outliers = SC_outliers + 1
										end
										-- format the numbers
										t.LibraryAve = string.format( "%7.3f", t.LibraryAve )
										t.LibrarySd = string.format( "%4.3f", t.LibrarySd )
										t.Shift = string.format("%7.3f", t.Shift )
										t.Dev = string.format("%10.3f", t.Dev )
										if num_outliers == 1 then -- write header for outlier report
											if t.OutlierSummary == nil then
												t.OutlierSummary = "\n"
											end --- if first Outlier in the sequence
											t.Outliers = "Unusual Shifts:\n"
											Formatted_SDmult = string.format( "%3.1f", AssignmentReport_SDmult )
											t.Outliers = t.Outliers.." Atom     Shift   Average   Difference   SD*"..Formatted_SDmult.."\n"
											local ResWithOutlier = string.format( "%5s", t.Typ:getLetter()..ResNum )
											t.OutlierSummary = t.OutlierSummary.." "..ResWithOutlier
											NumResWithOutliers = NumResWithOutliers + 1
											CountResWithOutliers = CountResWithOutliers + 1
											if CountResWithOutliers &gt; 9 then -- add a line break every 10 residues
												t.OutlierSummary = t.OutlierSummary.."\n"
												CountResWithOutliers = 0 -- reset counter
											end
										end -- if 1st outlier in the residue
										t.Outliers = t.Outliers..AtomNameForm.."   "..t.Shift.."   "..t.LibraryAve.."   "..t.Dev.."   "..t.LibrarySd.."\n"
										
									end -- if Outlier found
								end -- if outlier report requested
							end -- if spin matches atom, then SpinAssigned
						end -- searched through all spins in system
					end -- if t.Sys
					if SpinAssigned == false then -- missing assignment
						CountUnassigned = CountUnassigned + 1
						t.Unassigned = t.Unassigned.." "..AtomNameForm
						if CountUnassigned &gt; 6 then
							t.Unassigned = t.Unassigned.."\n             "
							CountUnassigned = 0
						end
						if Atom:getAtomType() == "H" then
							NumHmissing = NumHmissing + 1
							if IsAromaticAtom( Atom, t.Name ) then
								NumHAROmissing = NumHAROmissing + 1
							else
								NumHALImissing = NumHALImissing + 1
							end
						end
						if Atom:getAtomType() == "C" then
							NumCmissing = NumCmissing + 1
							if IsAromaticAtom( Atom, t.Name ) then
								NumCAROmissing = NumCAROmissing + 1
							elseif not IsCarbonylCarbon( Atom ) then
								NumCALImissing = NumCALImissing + 1
							else
								NumCOmissing = NumCOmissing + 1
							end
						end
						if Atom:getAtomType() == "N" then NumNmissing = NumNmissing + 1 end
						if BackboneLabel( t.AtomName, AssignmentReport_BackboneLabels ) then
							NumBBmissing = NumBBmissing + 1
						else
							NumSCmissing = NumSCmissing + 1
						end
						if IsOfClass( Atom, "Triple" ) then NumTRIPLEmissing = NumTRIPLEmissing + 1 end
						if IsAromaticAtom( Atom, t.Name ) then NumAROmissing = NumAROmissing + 1 end
						NumUnassignedForRes = NumUnassignedForRes + 1
	
					else -- found assignment
						t.Assigned = t.Assigned.." "..Atom:getName()
						if Atom:getAtomType() == "H" then
							NumHfound = NumHfound + 1
							if IsAromaticAtom( Atom, t.Name ) then
								NumHAROfound = NumHAROfound + 1
							else
								NumHALIfound = NumHALIfound + 1
							end
						end
						if Atom:getAtomType() == "C" then
							NumCfound = NumCfound + 1
							if IsAromaticAtom( Atom, t.Name ) then
								NumCAROfound = NumCAROfound + 1
							elseif not IsCarbonylCarbon( Atom ) then
								NumCALIfound = NumCALIfound + 1
							else
								NumCOfound = NumCOfound + 1
							end
						end
						if Atom:getAtomType() == "N" then NumNfound = NumNfound + 1 end
						if BackboneLabel( t.AtomName, AssignmentReport_BackboneLabels ) then
							NumBBfound = NumBBfound + 1
						else
							NumSCfound = NumSCfound + 1
						end
						if IsOfClass( Atom, "Triple" ) then NumTRIPLEfound = NumTRIPLEfound + 1 end
						if IsAromaticAtom( Atom, t.Name ) then NumAROfound = NumAROfound + 1 end
						NumAssignedForRes = NumAssignedForRes + 1
						NumAssignedIntTotal = NumAssignedInTotal + 1
						if IsPseudoAtom then
							NumPseudoAtomsAssignedInTotal = NumPseudoAtomsAssignedInTotal + 1
							PseudoAtomConflictResult = CheckForPseudoAtomConflicts( t.Sys, t.Group ) -- added in ver.7
							if PseudoAtomConflictResult ~= nil then
								NumPseudoAtomConflictsInTotal = NumPseudoAtomConflictsInTotal + 1
								NumPseudoAtomConflicts = NumPseudoAtomConflicts + 1 -- total in residue
								t.PseudoAtomConflicts = t.PseudoAtomConflicts.."  "..PseudoAtomConflictResult.."\n" -- add to list								
								if NumPseudoAtomConflicts == 1 then -- write header pseudoatom conflicts report (if 1st one found in residue)
									if t.PseudoAtomConflictsSummary == nil then
										t.PseudoAtomConflictsSummary = "\n"
									end --- if first pseudoatom conflict in the sequence
									local ResWithConflict = string.format( "%5s", t.Typ:getLetter()..ResNum )
									t.PseudoAtomConflictsSummary = t.PseudoAtomConflictsSummary.." "..ResWithConflict
									NumResWithConflicts = NumResWithConflicts + 1
									CountResWithConflicts = CountResWithConflicts + 1
									if CountResWithConflicts &gt; 9 then -- add a line break every 10 residues
										t.PseudoAtomConflictsSummary = t.PseudoAtomConflictsSummary.."\n"
										CountResWithConflicts = 0 -- reset counter
									end
								end -- if 1st pseudoatom conflict in the residue
					end -- if both pseudoatom and real atom are assigned
						end
					end
				end -- ignore Oxygen &amp; Serine (not assignable)
			end -- scan through all atoms in residue
				if t.Unassigned ~= " " or IncludeAssignedSpins == "YES" or num_outliers &gt; 0 or t.PseudoAtomConflicts ~= " " then
				i = i + 1
				t.Lines[ i ] = "\n"
				t.Lines[ i ] = t.Lines[ i ].."-----------------------------------------------------\n"
				t.Lines[ i ] = t.Lines[ i ]..ResNum.." "..Res:getType():getShort().."\n"
		
				if IncludeAssignedSpins == "YES" then
					NumAssignedForRes = string.format( "%3s", NumAssignedForRes )
					t.Lines[ i ] = t.Lines[ i ].."Assigned: "..NumAssignedForRes..t.Assigned.."\n"
				end
		
				if IncludeOutliers == "YES" and num_outliers &gt; 0 then
						t.Lines[ i ] = t.Lines[ i ].."---\n"
						t.Lines[ i ] = t.Lines[ i ]..t.Outliers.."\n"
				end
				if t.PseudoAtomConflicts ~= " " then
					t.Lines[ i ] = t.Lines[ i ].."---\n"
					t.Lines[ i ] = t.Lines[ i ]..t.PseudoAtomConflicts
				end
				if t.Unassigned ~= " " then
					NumUnssignedForRes = string.format( "%3s", NumUnassignedForRes )
					t.Lines[ i ] = t.Lines[ i ].."---\n"
					t.Lines[ i ] = t.Lines[ i ].."Unassigned: "..NumUnassignedForRes..t.Unassigned.."\n"
				end
		
			end -- store a line only if there is a missing assignment in the Residue
		end -- scan through entire sequence
-- ============================= Output results ================================
		t.Lines[ i + 1 ] = "-----------------------------------------------------\n"
		
		NumHtotal = NumHfound + NumHmissing
		NumHAROtotal = NumHAROfound + NumHAROmissing
		NumHALItotal = NumHALIfound + NumHALImissing
		NumCtotal = NumCfound + NumCmissing
		NumCAROtotal = NumCAROfound + NumCAROmissing
		NumCALItotal = NumCALIfound + NumCALImissing
		NumCOtotal = NumCOfound + NumCOmissing
		NumNtotal = NumNfound + NumNmissing
		NumBBtotal = NumBBfound + NumBBmissing
		NumSCtotal = NumSCfound + NumSCmissing
		NumTRIPLEtotal = NumTRIPLEfound + NumTRIPLEmissing
		NumPseudoAtomsAssignedInTotal = NumPseudoAtomsAssignedInTotal -- /2
		NumAfound = NumHfound+NumCfound+NumNfound
		NumAfoundPseudo = NumAfound - NumPseudoAtomsAssignedInTotal
		NumAROfound = NumCAROfound + NumHAROfound
		NumAmissing = NumHmissing+NumCmissing+NumNmissing
		NumAmissingPseudo = NumAmissing
		NumAROmissing = NumCAROmissing + NumHAROmissing
		NumAROtotal = NumAROfound + NumAROmissing

		-- Calculate percentage complete
		PercentA = ReportPercent( NumAfound, NumAfound+NumAmissing )
		PercentAPseudo = ReportPercent( NumAfoundPseudo, NumAfoundPseudo + NumAmissingPseudo )
		PercentARO = ReportPercent( NumAROfound, NumAROfound+NumAROmissing )
		
		PercentH = ReportPercent( NumHfound, NumHtotal )
		PercentHARO = ReportPercent( NumHAROfound, NumHAROtotal )
		PercentHALI = ReportPercent( NumHALIfound, NumHALItotal )
		PercentBB = ReportPercent( NumBBfound , NumBBtotal )
		PercentSC = ReportPercent( NumSCfound, NumSCtotal )
		PercentTRIPLE = ReportPercent( NumTRIPLEfound, NumTRIPLEtotal )
		
		
		function AveDev( Number, Value )
			if Number==0 then
				result = "no unusual shifts found"
			else
				Ave = Value/Number
				if Ave &gt; 0 then
					result = string.format("+%5.3f", Ave )
				else
					result = string.format("%5.3f", Ave )					
				end
			end
			return result
		end -- function AveDev
		
		-- Calculate average deviations
		DevH_ave = AveDev( t.DevH_number, t.DevH_total )
		DevN_ave = AveDev( t.DevN_number, t.DevN_total )
		DevNali_ave = AveDev( t.DevNali_number, t.DevNali_total )
		DevHali_ave = AveDev( t.DevHali_number, t.DevHali_total )
		DevHaro_ave = AveDev( t.DevHaro_number, t.DevHaro_total )
		DevC_ave = AveDev( t.DevC_number, t.DevC_total )
		DevCali_ave = AveDev( t.DevCali_number, t.DevCali_total )
		DevCaro_ave = AveDev( t.DevCaro_number, t.DevCaro_total )
		DevCO_ave = AveDev( t.DevCO_number, t.DevCO_total )

		-- Format summary lines
		Space = "   "
		NumHfound = string.format( "%5s", NumHfound )
		NumHmissing = string.format( "%7s", NumHmissing )
		NumHAROfound = string.format( "%5s", NumHAROfound )
		NumHAROmissing = string.format( "%7s", NumHAROmissing )
		NumHALIfound = string.format( "%5s", NumHALIfound )
		NumHALImissing = string.format( "%7s", NumHALImissing )
		NumBBfound = string.format( "%5s", NumBBfound )
		NumBBmissing = string.format( "%7s", NumBBmissing )
		NumSCfound = string.format( "%5s", NumSCfound )
		NumSCmissing = string.format( "%7s", NumSCmissing )
		NumAROfound = string.format( "%5s", NumAROfound )
		NumAROmissing = string.format( "%7s", NumAROmissing )
		H_outliers = string.format( "%8s", H_outliers )
		Hali_outliers = string.format( "%8s", Hali_outliers )
		Haro_outliers = string.format( "%8s", Haro_outliers )
		BB_outliers = string.format( "%8s", BB_outliers )
		SC_outliers = string.format( "%8s", SC_outliers )
		repHead =        "                      found   missing   complete    &gt;"..Formatted_SDmult.."*SD    Ave Dev\n" 
		reportH =        "          1H shifts : "..NumHfound..Space..NumHmissing..Space..PercentH.."%"..Space..H_outliers..Space..DevH_ave.."\n"
		reportH =        "          1H shifts : "..NumHfound..Space..NumHmissing..Space..PercentH.."%"..Space..H_outliers..Space..DevH_ave.."\n"
		reportHARO =     "       1Haro shifts : "..NumHAROfound..Space..NumHAROmissing..Space..PercentHARO.."%"..Space..Haro_outliers..Space..DevHaro_ave.."\n"
		reportHALI =     "       1Hali shifts : "..NumHALIfound..Space..NumHALImissing..Space..PercentHALI.."%"..Space..Hali_outliers..Space..DevHali_ave.."\n"
		reportBB =       "          BB shifts : "..NumBBfound..Space..NumBBmissing..Space..PercentBB.."%"..Space..BB_outliers.."\n"
		reportSC =       "          SC shifts : "..NumSCfound..Space..NumSCmissing..Space..PercentSC.."%"..Space..SC_outliers.."\n"
		reportHali_Dev = "    1H aliphatic sidechain shifts: "..DevHali_ave.."\n"
		reportHaro_Dev = "    1H  aromatic sidechain shifts: "..DevHaro_ave.."\n"
		reportCali_Dev = "   13C aliphatic sidechain shifts: "..DevCali_ave.."\n"
		reportCaro_Dev = "   13C  aromatic sidechain shifts: "..DevCaro_ave.."\n"
		reportCO_Dev =   "   13C carbonyl shifts           : "..DevCO_ave.."\n"
		reportNali_Dev = "   15N nonaromatic shifts        : "..DevNali_ave.."\n"
		if AssignmentReportAtomTypesToInclude == "all atoms" then
		  PercentC = ReportPercent( NumCfound, NumCtotal )
		  PercentCARO = ReportPercent( NumCAROfound, NumCAROtotal )
		  PercentCALI = ReportPercent( NumCALIfound, NumCALItotal )
		  PercentCO = ReportPercent( NumCOfound, NumCOtotal )
		  PercentN = ReportPercent( NumNfound, NumNtotal )
		  PercentTRIPLE = ReportPercent( NumTRIPLEfound, NumTRIPLEtotal )
		  NumCfound = string.format( "%5s", NumCfound )
		  NumCAROfound = string.format( "%5s", NumCAROfound )
		  NumCALIfound = string.format( "%5s", NumCALIfound )
		  NumCOfound = string.format( "%5s", NumCOfound )
		  NumNfound = string.format( "%5s", NumNfound )
		  NumAfound = string.format( "%5s", NumAfound )
		  NumAfoundPseudo = string.format( "%5s", NumAfoundPseudo )
		  NumTRIPLEfound = string.format( "%5s", NumTRIPLEfound )
		  NumCmissing = string.format( "%7s", NumCmissing )
		  NumCAROmissing = string.format( "%7s", NumCAROmissing )
		  NumCALImissing = string.format( "%7s", NumCALImissing )
		  NumCOmissing = string.format( "%7s", NumCOmissing )
		  NumNmissing = string.format( "%7s", NumNmissing )
		  NumAmissing = string.format( "%7s", NumAmissing )
		  NumAmissingPseudo = string.format( "%7s", NumAmissingPseudo )
		  NumTRIPLEmissing = string.format( "%7s", NumTRIPLEmissing )
		  C_outliers = string.format( "%8s", C_outliers )
		  Caro_outliers = string.format( "%8s", Caro_outliers )
		  Cali_outliers = string.format( "%8s", Cali_outliers )
		  CO_outliers = string.format( "%8s", CO_outliers )
		  N_outliers = string.format( "%8s", N_outliers )
		  A_outliers = string.format( "%8s", H_outliers+C_outliers+N_outliers )
		  -- reportC = "13C shifts found: "..NumCfound.." missing: "..NumCmissing.." "..PercentC.."% complete\n"
		  -- reportN = "15N shifts found: "..NumNfound.." missing: "..NumNmissing.." "..PercentN.."% complete\n"
		  reportC        = "         13C shifts : "..NumCfound..Space..NumCmissing..Space..PercentC.."%"..Space..C_outliers..Space..DevC_ave.."\n"
		  reportCARO     = "      13Caro shifts : "..NumCAROfound..Space..NumCAROmissing..Space..PercentCARO.."%"..Space..Caro_outliers..Space..DevCaro_ave.."\n"
		  reportCALI     = "      13Cali shifts : "..NumCALIfound..Space..NumCALImissing..Space..PercentCALI.."%"..Space..Cali_outliers..Space..DevCali_ave.."\n"
		  reportCO     =   "      13CO   shifts : "..NumCOfound..Space..NumCOmissing..Space..PercentCO.."%"..Space..CO_outliers..Space..DevCO_ave.."\n"
		  reportN        = "         15N shifts : "..NumNfound..Space..NumNmissing..Space..PercentN.."%"..Space..N_outliers..Space..DevN_ave.."\n"
		  reportTRIPLE   = "      Triple shifts : "..NumTRIPLEfound..Space..NumTRIPLEmissing..Space..PercentTRIPLE.."%   ".."\n"
		  reportA        = "         All shifts : "..NumAfound..Space..NumAmissing..Space..PercentA.."%"..Space..A_outliers..Space.."\n"
		  reportAPseudo = "Removing pseudoatom shifts: "..NumPseudoAtomsAssignedInTotal.."\n"
		  reportAPseudo = reportAPseudo.."     All Shifts : "..NumAfoundPseudo..Space..NumAmissingPseudo..Space..PercentAPseudo.."%"..Space.."\n"
		  
		end
		if t.OutlierSummary then -- add header to Outlier Summary
			t.Header = "--------------------------------------------\n\n"
			t.Header = t.Header.."Unusual Shifts  (&gt; "..Formatted_SDmult.."*SD) found in "..NumResWithOutliers.." residues: "
			t.OutlierSummary = t.Header.."\n"..t.OutlierSummary
		else
			t.OutlierSummary = "\n"
		end
		
		if t.PseudoAtomConflictsSummary then -- add header to PseudoAtomConflictsSummary
			t.Header = "--------------------------------------------\n\n"
			t.Header = t.Header.."PseudoAtom Conflicts (redundant assignments) found in "..NumPseudoAtomConflictsInTotal.." residues: "
			t.PseudoAtomConflictsSummary = t.Header.."\n"..t.PseudoAtomConflictsSummary
		else
			t.PseudoAtomConflictsSummary = "\n"
		end
		
		-- Output the results

		
		if AssignmentReportOutputMethod == "terminal window" then
			for i=1,table.getn( t.Lines ) do
				print(t.Lines[ i ])
			end
			print( "------ Class of Spins analysed : "..AssignmentReportAtomTypesToInclude.." --------")
			print( "---------------------------------------------------------------")
			print( repHead )
			print( reportH )
			print( reportHARO )
			print( reportHALI )
			if AssignmentReportAtomTypesToInclude == "all atoms" then
			  print( " ----- Assignments separated by AtomType -----" )
			  print( reportC )
			  print( reportCARO )
			  print( reportCALI )
			  print( reportCO )
			  print( reportN )
			  print( reportA )
			  print("------ After removing pseudoatoms ------")
			  print( reportAPseudo )
			end
			print("------ Assignments separated into Backbone, Sidechain, Triple resonance and Aromatic ------")
			print( reportBB )
			print( reportSC )
			if AssignmentReportAtomTypesToInclude ~= "H atoms only" then
				print( reportTRIPLE )
			end
			--print( reportARO )
			print("--------------------------------------------\n")
			print( BackboneLabelsText.."\n" )
			if AssignmentReportAtomTypesToInclude ~= "H atoms only" then
				print( TripleLabelsText.."\n" )
			end
			-- print("--------------------------------------------\n")
			print( t.PseudoAtomConflictsSummary )
			-- print("--------------------------------------------\n")
			print( t.OutlierSummary )
			print("--------------------------------------------\n")
			print( "Report of average deviations from database values. \nLarge values indicate possible calibration error!".."\n")
			print( " --------------------------------------------------" )
			print( reportHaro_Dev )
			print( reportHali_Dev )
			if AssignmentReportAtomTypesToInclude == "all atoms" then
				print( reportCali_Dev )
				print( reportCaro_Dev )
				print( reportCO_Dev )
				print( reportNali_Dev )
				
			end
			print( "================ Scroll up for residue by residue details! ===================" )
			print( "\n".."Printed out report to terminal window" )
		else
			-- open file to write
			outfile = io.output( AssignmentReportFilename )
			for i=1,table.getn( t.Lines ) do
				outfile:write( t.Lines[ i ] )
			end
			outfile:write( "------ Class of Spins analysed : "..AssignmentReportAtomTypesToInclude.." --------".."\n")
			outfile:write( "---------------------------------------------------------------".."\n")
			outfile:write( repHead )
			outfile:write( reportH )
			outfile:write( reportHARO )
			outfile:write( reportHALI )
			if AssignmentReportAtomTypesToInclude ~= "H atoms only" then
			  outfile:write( reportC )
			  outfile:write( reportCARO )
			  outfile:write( reportCALI )
			  outfile:write( reportCO )
			  outfile:write( reportN )
			  outfile:write( reportA )
			  outfile:write("\n".."------ After removing pseudoatoms ------".."\n")
			  outfile:write( reportAPseudo )
			end
			outfile:write("\n".."------ Assignments separated into Backbone, Sidechain, Triple resonance and Aromatic ------".."\n")
			outfile:write( reportBB )
			outfile:write( reportSC )
			if AssignmentReportAtomTypesToInclude ~= "H atoms only" then
			  outfile:write( reportTRIPLE )
			end
			--outfile:write( reportARO )
			outfile:write("\n".."--------------------------------------------\n")
			outfile:write( BackboneLabelsText.."\n")
			if AssignmentReportAtomTypesToInclude ~= "H atoms only" then
				outfile:write( TripleLabelsText.."\n")
			end
			-- outfile:write("--------------------------------------------\n")
			outfile:write( t.PseudoAtomConflictsSummary.."\n" )			
			-- outfile:write("--------------------------------------------\n")
			outfile:write( t.OutlierSummary.."\n" )			
			outfile:write("--------------------------------------------\n")
			outfile:write( "Report of average deviations from database values, \nlarge values indicate possible calibration error!".."\n")
			outfile:write( " --------------------------------------------------\n" )
			outfile:write( reportHaro_Dev )
			outfile:write( reportHali_Dev )
			if AssignmentReportAtomTypesToInclude == "all atoms" then
				outfile:write( reportCaro_Dev )
				outfile:write( reportCali_Dev )
				outfile:write( reportCO_Dev )
				outfile:write( reportNali_Dev )
			end
			outfile:close()
			print( "Wrote out report to file "..AssignmentReportFilename )
			print( "AssignmentReport version "..Version.." "..Date.." is finished" )
		end
		
		v:close()
	end
) -- end OK button Callback

-- End of script FD.






</code>
<fld name='Author' type='String'>Fred Damberger</fld>
<fld name='Creation Date' type='Date'>2008-3-14</fld>
<fld name='Description' type='Memo'>Generates a report of the completeness of assignments in a project. Unusual shifts can be reported, along with inconsistent pseudoatom assignments. Average deviations from the database chemical shifts in different catagories may also reveal referencing errors. It is recommended to use AssignmentReport to identify problems in the assignments and fix them before writing them out with WriteAssignments.</fld>
<fld name='Version' type='Short'>8</fld>
</script>
<script name='CreateProjectedSpins'>
<code lang='Lua'>-----------------------------------------------------------------------------------------
-- Script to copy selected spins (label X) from a system i to a sequential neighbor system
-- (Either i-1 or i+1)
-- with the new label (X-1 or X+1 respectively)

-- This allows the user to see the projected spins that were assigned in an XEASY project.
-- e.g. the default settings copy CA spins of residue i to CA-1 of residue i+1

-- F. Damberger  24.Jun.2004

-- Always Back-up your Repository before executing the script!
-- There is no undo!
-----------------------------------------------------------------------------------------

-- create temporary array for lua script
t={}


--1. Get ProjectName -----------------------------------------------------
local ProjectNames = {}
i = 0
for a,b in pairs( cara:getProjects() ) do
	i = i + 1
	ProjectNames[ i ] = b:getName()
end
if table.getn( ProjectNames ) &gt; 1 then
	t.ProjectName=dlg.getSymbol("Select Project","", unpack( ProjectNames ) )
	t.P = cara:getProject( t.ProjectName )
else
	t.P = cara:getProject( ProjectNames[ 1 ] )
end

--2. The Spin Labels of Spins to be copied --------------------------------
t.oldlabel = dlg.getText("Enter Spin Labels of Spins to be copied","Enter the label for spins to copy", "CA")

--3. The new Spin Labels of the Spins in the new System -------------------
t.Offset = dlg.getSymbol("Choose an offset for the new spin", "select offset of new spins","-1", "+1")

t.newlabel = t.oldlabel..t.Offset
print("label of new spins will be"..t.newlabel)

i=0
for SpinId,Spin in pairs( t.P:getSpins() ) do
	if Spin:getLabel() == t.oldlabel then           -- SELECT THE SPINS TO BE COPIED
		t.NeighborSysExists = false
		if t.Offset == "-1" then
			if Spin:getSystem() and Spin:getSystem():getSucc() then
				t.NeighborSysExists = true
				t.SuccSysSpins = Spin:getSystem():getSucc():getSpins()
			end
		elseif t.Offset == "+1" then
			if Spin:getSystem() and Spin:getSystem():getPred() then
				t.NeighborSysExists = true
				t.SuccSysSpins = Spin:getSystem():getPred():getSpins()
			end
		else
			print("offset must be +1 or -1")
			t = nil
		end
		if t.NeighborSysExists then	-- CHECK WHETHER newlabel ALREADY EXISTS
			
			t.NewLabelExists = false
			for NeighborSpinId,NeighborSpin in pairs( t.SuccSysSpins ) do
				if NeighborSpin:getLabel() == t.newlabel  then
					t.NewLabelExists = true
				end
			end
			if not t.NewLabelExists then
				t.newspin = t.P:createSpin( Spin:getAtomType(), Spin:getShift() )
				i=i+1
				if t.Offset == "-1" then
					t.P:assignSpin( t.newspin, Spin:getSystem():getSucc() )
				elseif t.Offset == "+1" then
					t.P:assignSpin( t.newspin, Spin:getSystem():getPred() )
				else
					print("offset must be +1 or -1")
					t = nil
				end
				t.P:setLabel(t.newspin,t.newlabel)	  -- SELECT THE NEW SPINLABEL (must exist already in the repository)
			end
		end
	end 
end
print("copied "..i.." "..t.oldlabel.." to "..t.newlabel.." of neighbor.")
print("\nCreateProjecteSpins is finished.")
--free up script variables
t = nil
</code>
<fld name='Author' type='String'>Fred Damberger</fld>
<fld name='Creation Date' type='Date'>2005-3-26</fld>
<fld name='Description' type='Memo'>Creates projected spins from spins in the original system

e.g. You have assignments for CA and want to see the CA-1 peaks in an HNCA. This is useful if you are starting from known assignments and want to make "sequential peaks" visible in the Scopes.</fld>
</script>
<script name='DeleteAllSpinLinks'>
<code lang='Lua'>-- Script to erase all spinlinks in a project
-- F. Damberger  29.April.2004
--
--22.June.2004
-- modified to allow user to select project in a dialog window
--11.Jan.2005
-- modified to include dialog which asks user if erased spinlinks
-- should be printed to terminal window

-- WARNING: this script erases large numbers of spinlinks from project.
-- Always Back-up your Repository before executing the script!

-- create temporary table for variables
t = {}

-- get user preference on output

t.choice = dlg.getSymbol(" Do you want to print a line for each erased spinlink?","","NO","YES" )

if t.choice == "YES" then
  local PrintResults = true
end
----------------------------------------------------------------------
-- Create array to hold all script variables
t={}

--1. Get ProjectName
local ProjectNames = {}
t.i = 0
for a,b in pairs( cara:getProjects() ) do
	t.i = t.i + 1
	ProjectNames[ t.i ] = b:getName()
end
t.ProjectName=dlg.getSymbol("Select Project","", unpack( ProjectNames ) )
t.P = cara:getProject( t.ProjectName )


-- get Project

t.P=cara:getProject(t.ProjectName)

-- ----------------------------------------------------------------------

t.SL = t.P:getSpinLinks()

t.i = 0
for a,b in pairs( t.SL ) do
-- erase spinlink

	t.P:unlinkSpins( t.P:getSpin(b:getLeft()),t.P:getSpin( b:getRight() ) )
	t.i = t.i + 1
	if PrintResults then
		print( "erased link from spin"..b:getLeft().. " to  "..b:getRight() )
	end
end

print( "erased "..t.i.." spinlinks" )
print( "DeleteSpinLinks is done" )

t = nil</code>
<fld name='Author' type='String'>Fred Damberger</fld>
<fld name='Creation Date' type='Date'>2005-3-26</fld>
<fld name='Description' type='Memo'>Deletes all Spinlinks from a project.</fld>
</script>
<script name='LoadBmrbStats'>
<code lang='Lua'>-- F.Damberger
-- 14.Feb.2005

-- purpose: read BMRB statistics from a file and update
-- all ResidueTypes to reflect those statistics.
-- The statistical average and standard deviations will
-- be read from the file and replace the relevant values
-- in the ResidueType definitions of the loaded repository.
-- The DateStamp from the Statistics file will be added
-- as attribute to each ResidueType which is updated.

-- Only ResidueTypes will be replaced where EVERY atom of
-- the StandardResidueType has an entry in the statistics file!
-- StandardResidueType contains the largest number of atoms
-- for a given residue
-- ARG+ : for ARG
-- LYS+ : for LYS
-- ASP  : for ASP-
-- GLU  : for GLU-
-- CYS  : for CYSS
-- HIS+ : for HIS,HIST

-- The statistics file should be a copy-paste of the entire www page of the BMRB statistics
-- Step-by-Step
-- go to www.bmrb.wisc.edu
-- click on "Retrieve"
-- click on "Statistical Data Derived from the BMRB Archive"
-- under 'Diamagnetic' Protein Entries, click on "Amino Acid Chemical Shift Statistics"
-- copy-paste the entire page into a file named something like "bmrbdia25-06-2010.stats"

-- unfortunately, this descriptive approach is neccessary since BMRB does not provide
-- downloadable files with fixed names at fixed locations.

-- To see the DateStamp, you will have to define the
-- Attribute in the Cara-Explorer under
-- Attribute Definitions - ResidueType
-- Right-Click in the right window and select "new attribute"
-- Enter the name "Updated-MM-DD-YYYY" and the type "memo".
-- You can leave the description field blank.
-- After running the script, you should see the attribute
-- if you click on ResidueType in the Cara-Explorer and
-- then right-click in right window and select "Open Object Table"

-- FD Feb.14.2005

-- FUNCTION FindDateStamp --------------------------------------------------------------------------
function FindDateStamp( StatFile )
  DateStampFound = false
  DateStampSearch = true
  while DateStampSearch do
    local Line = StatFile:read()
    if Line ~= nil then -- not end of file
      -- Scan the line -----
      StartChar,EndChar,Month,Day,Year = string.find( Line, "Last updated: (%d+)%-(%d+)%-(%d+)" )
      if StartChar then
        DateStampFound = true
        DateStampSearch = false
        return Month,Day,Year
      end
    else -- EOF
      DateStampSearch = false
      NotEof = false
      error( "Date Stamp not found at start of file: e.g. Last updated: 01-07-2005" )
      return -- Return nothing, no DateStamp found
    end --if Line not nil
  end -- scan of file until EOF or DateStampFound
end --function

-- FUNCTION FindStatisticsLine ------------------------------------------------------------------------------------------------------------------------------------
function FindStatisticsLine( Statfile )

  ScanForStatisticsLine = true
  StatisticsLineFound = false
  StartChar = false
  while ScanForStatisticsLine do
    local Line = StatFile:read()
    if Line ~= nil then -- Scan the Line
      StartChar,EndChar,Res,AtomName,AtomType,NumShifts,AveShift,DevShift = string.find( Line, "(%u+)%s+(%u+%d*)%s+(%u+)%s+(%d+)%s+%-?%d+%.%d+%s+%-?%d+%.%d+%s+(%-?%d+%.%d+)%s+(%-?%d+%.%d+)" )
      if StartChar then
        return false,Res,AtomName,AtomType,AveShift,DevShift
      end
    else
      ScanForStatisticsLine = false -- EOF reached
      return true -- EOF is true
    end
    if StartChar then
      StatisticsLineFound = true
      ScanForStatisticsLine = false
    end
  end -- scan for statistics line
end -- function

-- FUNCTION AllLabelsInResidueType ----------------------------------------------------------------------------------------------------------------------
function AllLabelsInResidueType( ResidueType, Stats, NumLines, NeasyNomenclature )
  Atoms = ResidueType:getAtoms()
  AllLabelsFound = true
  for AtomLabel,Atom in pairs( Atoms ) do
    AtomName = Atom:getName()
    AtomType = Atom:getAtomType()
    if NeasyNomenclature then
      AtomName = ConvertNeasyToBmrbLabel( ResidueType, Atom )
    end
    MissingLabel = true
    if Atom:getValue() then
      for i = 1,NumLines do -- scan through all Stats
        AtomMatchFound = false
        if ThreeLetterName( ResidueType:getShort() ) == Stats.ResName[ i ] and AtomType == Stats.AtomType[ i ] and AtomName == Stats.AtomName[ i ] then
          AtomMatchFound = true
        end
        if AtomMatchFound then
          MissingLabel = false
        end
      end -- scan of Stats
    else
      MissingLabel = false -- ignore Atoms with no shifts defined in Repository e.g. Oxygen, Sulfur...
    end -- if Atom has Shift defined
    if MissingLabel == true then
      print("No match for "..ResidueType:getShort()..":"..AtomName)
      AllLabelsFound = false
    end
  end -- scan of Atoms in ResidueType
  return AllLabelsFound
end --Function

-- FUNCTION ConvertNeasyToBmrbLabel ----------------------------------------------------------------------------------------------------------------------
-- This function converts the deviating labels in Neasy nomenclature to Bmrb nomenclature
-- e.g. BMRB:	H	Neasy: HN (Amide protons are named "HN" in Neasy, and "H" in Bmrb (IUPAC) nomenclature)
--      BMRB:	HG	Neasy: QG (pseudoatoms have name "Q" in Neasy, the "Q" is replaced with "H" in Bmrb nomenclature
--      BMRB:	GLY HA3	Neasy:	GLY HA1 (GLY alphas are named HA1 and HA2 in Neasy, and HA3 and HA2 in Bmrb (IUPAC) nomenclature)

function ConvertNeasyToBmrbLabel( ResidueType, Atom )
  AtomName = Atom:getName()
  AtomType = Atom:getAtomType()

  if ResidueType:getShort() == "GLY" and AtomType == "H" and AtomName == "HA1" then -- BMRB name HA3
    AtomName = "HA3" -- rename it for internal purposes to the expected name in the BMRB database
  elseif AtomType == "H" and AtomName == "HN" then -- BMRB name H
    AtomName = "H" -- rename it for internal purposes to the expected name in the BMRB database
  elseif AtomType == "H" and IsPseudoAtom( AtomName ) then -- BMRB replaces Q with H
    AtomName = BmrbPseudoAtom( AtomName )
  end

  return AtomName

end -- function

-- FUNCTION IsPseudoAtom ----------------------------------------------------------------------------------------------------------------------
-- This function checks whether the AtomName contains "Q" and returns true if it does
function IsPseudoAtom( AtomName )
-- checks for "Q" in the name
  StartChar,EndChar,FirstChar,RestChars = string.find( AtomName, "(%u)(%w+)" )
  if FirstChar == "Q" then
    return true
  else
    return false
  end
end -- function

-- FUNCTION BmrbPseudoAtom ----------------------------------------------------------------------------------------------------------------------
-- This function converts a NEASY pseudoatom to BMRB nomenclature by replacing Q with H
function BmrbPseudoAtom( AtomName )
  StartChar,EndChar,FirstChar,RestChars = string.find( AtomName, "(%u)(%w+)" )
  return "H"..RestChars
end


-- FUNCTION DateStampResidueType ----------------------------------------------------------------------------------------------------------------
-- This function sets a new attribute for ResidueType "Updated-MM-DD-YYY"
-- to be equal to the DateStamp read from header of BMRB stats file
-- This documents which ppm values were used to update from BMRB
-- It also sets an attribute documenting what the SD values were
-- multiplied by (SDmult) to obtain the dev values (usually 4.0)
function DateStampResidueType( ResidueType, Month, Day, Year, SDmult )
  ResidueType:setAttr( "Updated-MM-DD-YYYY",Month.."-"..Day.."-"..Year)
  ResidueType:setAttr("SDmult", SDmult )
end

-- FUNCTION RemoveAtomShifts ------------------------------------------------------------------------------------------------------------------
-- This function removes atom shifts for atoms which should not have shifts
-- like Oxygen atoms. This corrects an error in the template Start1.1.cara
function RemoveAtomShifts( AtomType )
ResidueTypes = cara:getResidueTypes()
  for ResidueTypeId,ResidueType in pairs( ResidueTypes ) do
  Atoms = ResidueType:getAtoms()
    for AtomID,Atom in pairs( Atoms ) do
      if Atom:getAtomType() == AtomType and Atom:getValue() then
        print( "Removing Atom Shift:"..ResidueType:getShort()..":"..Atom:getName() )
		ResidueType:setValue( Atom )
      end
    end
  end -- for
end -- function

-- FUNCTION UpdateStatsInResidueType ------------------------------------------------------------------------------------------------------------
-- This is the heart of the script.
-- This function updates the shifts to the values from the BMRB file
function UpdateStatsInResidueType( ResidueType, SDmult, Stats )
 print( "\n-------------------- Updating Stats in Residue:"..ResidueType:getShort().."--------------------------" )
  Atoms = ResidueType:getAtoms()

  for AtomLabel,Atom in pairs( Atoms ) do
    AtomName = ConvertNeasyToBmrbLabel( ResidueType, Atom )
    for i=1,NumLines do -- scan through all Stats
      AtomMatchFound = false
      if ThreeLetterName( ResidueType:getShort() ) == Stats.ResName[ i ] and Atom:getAtomType() == Stats.AtomType[ i ] and AtomName == Stats.AtomName[ i ] then
        AtomMatchFound = true
      end
      if not Atom:getValue() then
        --skip it, no shift expected
      else
        if AtomMatchFound  then
          StatsAveShift = string.format( "%7.3f", Stats.AveShift[ i ] )
          SDtimesDevShift = string.format( "%7.3f", SDmult*Stats.DevShift[ i ] )
          AtomShift,AtomDev = Atom:getValue()
          AtomShift = string.format( "%7.3f", AtomShift )
          AtomDev = string.format( "%7.3f", AtomDev )
          AtomNameForm = string.format( "%-6s", AtomName )
          print( "Updating "..ResidueType:getShort()..":"..AtomNameForm.." from "..AtomShift.." +- "..AtomDev.." to "..StatsAveShift.." +- "..SDtimesDevShift )
          -- update stats NEXT LINE uses the new function ResidueType:setValue(Atom,Ave,Dev)" which is not described in Calua manual NMR.014.doc!!!
          ResidueType:setValue( Atom, Stats.AveShift[ i ], SDmult*Stats.DevShift[ i ])
        end
      end --if Shift exists
    end -- scan of Stats
  end -- scan of Atoms in ResidueType
end

-- FUNCTION  StandardResidueType------------------------------------------------------------------------------------------------------------
function StandardResidueType( ResidueType, NeasyNomenclature )
-- function points to the "StandardResidueType for each ResidueType
-- This is because the BRMB database does not distinguish the different states of residues (like ionization states, tautomers, oxidation)
-- Therefore the script replaces the statistics for each ResidueType with those of the StandardResidueType
-- e.g. the ResidueTypes CYS and CYSS will have the same shifts (even for the CB spins which vary significantly between CYSS(red) and CYS(ox) )
-- Blame BMRB for this, It's not my decision.

-- e.g. CYS for CYSS
--      ARG+ for ARG
--      LYS+ for LYS
--      GLU- for GLU
--      ASP- for ASP
--      HIS+ for HIS and HIST etc..

  IUPACRES = { "ALA", "ARG", "ASN", "ASP", "CYS", "GLU", "PHE", "GLN", "GLY", "HIS", "ILE", "LEU", "LYS", "MET", "PRO", "SER", "THR", "TRP", "TYR", "VAL" }
  
  Type = ResidueType:getShort()
  if NeasyNomenclature then
    if Type == "CYSS" then Type = "CYS" end
    if Type == "ASP" then Type = "ASP-" end
    if Type == "GLU" then Type = "GLU-" end
    if Type == "HIS" then Type = "HIS+" end
    if Type == "HIST" then Type = "HIS+" end
    if Type == "LYS" then Type = "LYS+" end
    if Type == "ARG" then Type = "ARG+" end
  else -- BMRB nomenclature expected
    IUPAC = false
    for Index,AllowedResName in pairs( IUPACRES ) do
	  if Type == AllowedResName then IUPAC = true end
	end
	if not IUPAC then	  
      print( "Non IUPAC residue name: "..Type )
    end
  end -- if NeasyNomenclature
  StandardType = cara:getResidueType( Type )
  return StandardType
end -- function StandardResidueType

function ThreeLetterName( ResidueTypeName )
-- change name to three letter name , BMRB only uses the standard three letter name
-- e.g. Neasy and Cara template use ARG+ to mean the protonated arginine, BMRB uses ARG

  StartChar,EndChar,FirstThreeChars = string.find( ResidueTypeName, "(%u%u%u)" )
  return FirstThreeChars
end

-- Main Body of Program -------------------------------------------------------------------------------------------------------------------------------

--0. Get Format of Repository ResidueTypes (Neasy or Bmrb nomenclature)
--   e.g. Amide Protons: Neasy "HN" / BMRB "H"
RepositoryFormat = dlg.getSymbol("Select Repository format Bmrb or Neasy","Which Format are the Repository Labels? e.g. if Amide protons are labeled HN you have Neasy format","BMRB","Neasy")
if RepositoryFormat == "Neasy" then
  NeasyNomenclature = true
else
  NeasyNomenclature = false
end

--1. Get BMRB Statistics File Location
local StatFileLocation = dlg.getOpenFileName( "Select the BRMB statistics file", "*.stats" )

StatFile = io.open( StatFileLocation )
NotEof = true

--2. Get DateStamp

Month,Day,Year = FindDateStamp( StatFile )
DateStamp = Month.."-"..Day.."-"..Year
if Month == nil then
  error("No Date Stamp found. Read in aborted")
end
print( "MM-DD-YEAR = "..Month.."-"..Day.."-"..Year )

-- create array for statistics:
Stats = {}
Stats.ResName = {}
Stats.AtomName = {}
Stats.AtomType = {}
Stats.AveShift = {}
Stats.DevShift = {}

-- Read in Statistics

NumLines = 0
Eof = false
while not Eof do
  Eof,ResName,AtomName,AtomType,AveShift,DevShift = FindStatisticsLine( StatFile )
  if ResName then
    NumLines = NumLines + 1
    print(ResName,AtomName,AtomType,AveShift,DevShift)
-- READ STATS DATA INTO ARRAY
    Stats.ResName[ NumLines ] = ResName
    Stats.AtomName[ NumLines ] = AtomName
    Stats.AtomType[ NumLines ] = AtomType
    Stats.AveShift[ NumLines ] = AveShift
    Stats.DevShift[ NumLines ] = DevShift

  end
end

print( "read in "..NumLines.." statistics lines" )

-- for i=1,table.getn(Stats.ResName) do
--   print(i,Stats.ResName[i],Stats.AtomName[i],Stats.AtomType[i],Stats.AveShift[i],Stats.DevShift[i])
-- end

--3. Get the multiplier for the dev value from the user (default is 4.0)
SDmult = dlg.getText("Enter multiplier for Standard Deviations","SD multiplier","4.0")
StartChar = nil
StartChar,EndChar,SDmultParse = string.find( SDmult, "(%d+%.%d+)" )
if StartChar == nil then
    error("Please enter a floating point number like 4.0")
end

--4. ACTUAL WORK PART OF SCRIPT : Loop through ResidueTypes and replace the old Ave/Dev with the new.


-- remove shifts for O and S -- this fixes an error in Start1.1.cara
print( "removing shifts for O and S -- this fixes an error in Start1.1.cara" )
RemoveAtomShifts( "O" )
RemoveAtomShifts( "S" )
-- get ResidueTypes and update their shifts
ResidueTypes = cara:getResidueTypes()

-- print( "Not Replaced / Replaced" )
for ResidueTypeName,ResidueType in pairs( ResidueTypes ) do  
  if AllLabelsInResidueType( StandardResidueType( ResidueType, NeasyNomenclature ), Stats, NumLines, NeasyNomenclature ) then
    DateStampResidueType( ResidueType, Month, Day, Year, SDmult )
    UpdateStatsInResidueType ( ResidueType, SDmult, Stats )
    -- print("------------- / -----"..ResidueType:getShort().."-----" )
  else
    print( "-----"..ResidueType:getShort().."----- / -------------" )
	blank= 0 -- dummy line
  end
end

-- Report which ResidueTypes were updated:
print( "----------------------------" )
print( "DateStamp for BMRB file: "..DateStamp )
print( "Summary of Updated Residues:" )
print( "Res  Updated-MM-DD-YYYY" )
for ResidueTypeName,ResidueType in pairs( ResidueTypes ) do
  if ResidueType:getAttr("Updated-MM-DD-YYYY") then
    if DateStamp == ResidueType:getAttr("Updated-MM-DD-YYYY") then
      CurrentStatusString = "up to date"
    else
      CurrentStatusString = "NOT UP TO DATE!"
    end
  FormattedResTyp = string.format( "%-5s", ResidueType:getShort() )
  print( FormattedResTyp.."   "..ResidueType:getAttr( "Updated-MM-DD-YYYY").."   "..CurrentStatusString )
  else
    print( ResidueType:getShort().."      never updated." )
  end
end



print("LoadBmrbStats is all done")

-- end of Main Body
</code>
<fld name='Author' type='String'>Fred Damberger</fld>
<fld name='Creation Date' type='Date'>2005-3-26</fld>
<fld name='Description' type='Memo'>Loads BMRB statistics from a file named Filename.stats onto the ResidueTypes of the repository. You need to copy-paste the entire WWW page listing the BMRB statistics into a file.

Some details of how it works:

Script asks whether the repository uses Xeasy or BMRB nomenclature. If Xeasy is selected, the script will assume that amide protons are named "HN" within the ResidueTypes (other differences are also taken in cosideration). Start1.1.cara used Xeasy nomenclature. Start1.2.cara uses BMRB nomenclature.

Script reads the "UpdateDate" from this file and includes it as an attribute for each ResidueType (see ObjectTable for ResidueTypes). In addition the user must determine the SDmult value (how much to multiply the StandardDeviations by to obtain the "dev" values written into ResidueTypes. The Default value 4.0 was used also for the old template Start1.1.cara.

You may have a situation, like molten globule proteins where the SDmult value should be smaller to reflect the narrrower expected chemical shift range.</fld>
</script>
<script name='LoadProtonListOntoResidues'>
<code lang='Lua'>-- Description: Opens an external protonlist and creates a ppm value for each
-- atom found in the sequence. This allows the user to bias the fragment
-- mapping to look for fragments which match the assignments which were read in
-- instead of expecting random coil (average) chemical shifts at each residue
-- position as derived from the ResidueType shifts.

-- 27.Feb. 2005 F.Damberger

-- Notes: The script only loads atoms whose label begins with H,C,N, or Q.
-- The user can set separately the dev (deviation) value for Hatoms (H or Q)
-- and for HeteroAtoms (C or N).
-- It assumes that Q corresponds to a Hatom pseudotom label.

-- FUNCTION DEFINITIONS

function GetFirstLetter( Label )
-- get first letter
	StartChar,EndChar,FirstLetter = string.find( Label, "(%u)" )
	if FirstLetter then -- return first letter or nil
		return FirstLetter
	else
		return nil
	end
end -- function GetFirstLetter

-- MAIN BODY of Script -----------------------------------------------------------------

--1. Get ProjectName
local ProjectNames = {}
i = 0
for a,b in pairs(cara:getProjects()) do
	i = i + 1
	ProjectNames[ i ] = b:getName()
end
local ProjectName = dlg.getSymbol("Select Project","", unpack( ProjectNames ) )
local Project = cara:getProject( ProjectName )

--2. Get the dev value for H atoms from the user (default is 0.5)
HatomDev = dlg.getText("Enter maximum Deviation to match 1H shift","Hatom Dev","0.5")
StartChar = nil
StartChar,EndChar,HAtomDevParse = string.find( HatomDev, "(%d+%.%d+)" )
if StartChar == nil then
error("Please enter a floating point number like 0.5")
end

--3. Get the dev value for Hetero atoms from the user (default is 2.0)
HeteroAtomDev = dlg.getText("Enter maximum Deviation to match HeteroAtom shift (15N,13C)","HeteroAtom Dev","2.0")
StartChar = nil
StartChar,EndChar,HeteroAtomDevParse = string.find( HeteroAtomDev, "(%d+%.%d+)" )
if StartChar == nil then
error("Please enter a floating point number like 2.0")
end

--4. Select external ProtonList and get a pointer to it ---------------------------------------

ProtonList = spec.openProtonList( dlg.getOpenFileName( "Load ProtonList", "Protonlist (*.prot)" ) )


--5. get Sequence Tabel

Sequence = Project:getSequence()

--5. Scan through ProtonList and create ResidueValues
Hcount = 0
Ccount = 0
Ncount = 0
Qcount = 0
NoneCount = 0
AssignedShiftsCount = 0
FirstUnassigned = true
for i = 1,ProtonList:getCount() do
	SpinId,Shift,AtomLabel,ResNum = ProtonList:getAtom( i )
	if Shift ~= 999.0 then
		AssignedShiftsCount = AssignedShiftsCount + 1
		if Sequence[ ResNum ] then
			Residue = Sequence[ ResNum ]
			LabelFirstLetter = GetFirstLetter( AtomLabel )
			if LabelFirstLetter == "H" then
				Project:setValue( Residue, AtomLabel, string.format( "%3.2f",Shift), HatomDev )
				-- Spin = Project:getSpin( SpinId )
				-- print("SpinId:"..SpinId.." AtomType: "..Spin:getAtomType().." Label: "..Spin:getLabel() )
				Hcount = Hcount + 1
			elseif LabelFirstLetter == "C" then
				Project:setValue( Residue, AtomLabel, string.format( "%3.2f",Shift), HeteroAtomDev )
				Ccount = Ccount + 1
			elseif LabelFirstLetter == "N" then
				Project:setValue( Residue, AtomLabel, string.format( "%3.2f",Shift), HeteroAtomDev )
				Ncount = Ncount + 1
			elseif LabelFirstLetter == "Q" then
				Project:setValue( Residue, AtomLabel, string.format( "%3.2f",Shift), HatomDev )
				Qcount = Qcount + 1
			else
				-- Report Unassigned Atom
				if FirstUnassigned then
					FirstUnassigned = false
					print( "Not assigned:")
				end -- print header for this report
				print( SpinId,Shift,AtomLabel,ResNum )
				NoneCount = NoneCount + 1
			end -- if AtomType matches H,C, or N
			-- print( ProtonList:getAtom( i ) )
		end -- if Residue with residueNumber ResNum exists
	end
end

print( "Loaded Atoms        : "..ProtonList:getCount() )
print( "Assigned Shifts     : "..AssignedShiftsCount )
print("-------------------------------------")
print( "Defined  1H shifts  : "..Hcount )
if Qcount &gt; 0 then
	print( "Defined   Q shifts  : "..Qcount.."  These all assumed to be 1H." )
end
if Ccount &gt; 0 or Ncount &gt; 0 then
	print( "Defined 13C shifts  : "..Ccount )
	print( "Defined 15N shifts  : "..Ncount )
end
print( "Total shifts defined: "..Hcount + Ccount + Ncount + Qcount )
print("-------------------------------------")
print( "undefined shifts    : "..NoneCount )
print()
print()
print( "LoadProtonListOntoResidues.lua is done." )
</code>
<fld name='Author' type='String'>Fred Damberger</fld>
<fld name='Creation Date' type='Date'>2005-3-26</fld>
<fld name='Description' type='Memo'>Creates expected shifts for each spin in a protonlist defined on the sequence of the project. I.e. CARA will use the shifts appearing in the Sequence-explorer to do chemical shift mapping of fragments instead of the ResidueType chemical shifts.

This allows you to bias the assignments towards expected chemical shifts from an input protonlist. The user must enter the expected chemical shift range around the shift read in for 1H atoms and for "heteroatoms" (13C/15N).

e.g. You have a homologous proteins assignments and want to look for fragments with similar assignments to the homologue.
</fld>
</script>
<script name='PeakListNumberedByResidue'>
<code lang='Lua'>-- script to write out a peaklist to external file numbered by residue number.
-- e.g. if you want a peaklist for an HSQC15N with one peak for each residues HN/N pair
--      numbered so that the peaknumber corresponds to the residue number
--      This can be useful for analysing NH relaxation or NH exchange data vs.residue number

-- F.Damberger July 23.2004

-- create array for script variables
t = {}
-- ----------------------------------------------------------------------
--1. Get ProjectName
local ProjectNames = {}
i = 0
for a,b in pairs(cara:getProjects()) do
	i = i + 1
	ProjectNames[ i ] = b:getName()
end
t.ProjectName=dlg.getSymbol("Select Project","", unpack( ProjectNames ) )
t.P = cara:getProject( t.ProjectName )

--2. Get Output Filename
t.Filename = dlg.getText("Enter the output filename", "", "PeakVsResidue_"..t.ProjectName..".peaks" )
-- open outfile
outfile = io.output( t.Filename )

--3. Get Unique Labels for Peaks
t.Label1 = dlg.getText("Enter the Label for Dim1: e.g. HN (XEASY), H (BMRB)", "", "H" )
t.Label2 = dlg.getText("Enter the Label for Dim2", "", "N" )

--4. Get Preference to Include Label or not
t.IncludeLabel = dlg.getText("Include Labels?","", "YES", "NO")

-- Write header to peaklist

outfile:write("# Number of dimensions 2".."\n")
outfile:write("#INAME 1 "..t.Label1.."\n")
outfile:write("#INAME 2 "..t.Label2.."\n")


t.Seq = t.P:getSequence()

for ResNum,Res in pairs( t.Seq ) do
-- get the SpinSystem
	t.Sys = Res:getSystem()
	if t.Sys then
		-- go through each Spin in System
		shift1 = nil; shift2 = nil
		for SpinId,Spin in pairs( t.Sys:getSpins() ) do
			if t.Label1 == Spin:getLabel() then
				shift1 = Spin:getShift()
				t.ass1 = Spin:getId()
			elseif t.Label2 == Spin:getLabel() then
				shift2 = Spin:getShift()
				t.ass2 = Spin:getId()
			end
		end
		if shift1 and shift2 then
		
    	--print("Res "..ResNum.." "..t.Label1.." "..shift1.." "..t.Label2.." "..shift2)
			PeakNum = string.format("%6d",ResNum)
			Shift1 = string.format("%8.3f",shift1)
			Shift2 = string.format("%8.3f",shift2)
			Code = string.format("%2d",1)
			SpecTyp = " U"
	        vol = 0
			Vol = string.format("%12.3E",vol)
			err = 0
	        Err = string.format("%12.3E", err)
			IntMeth = " e"
	        Unused = " 0"
			Ass1 = string.format("%6d",t.ass1) --"Ass1" --
			Ass2 = string.format("%6d",t.ass2) --"Ass2" --
	        print(PeakNum..Shift1..Shift2..Code..SpecTyp..Vol..Err..IntMeth..Unused..Ass1..Ass2)
			outfile:write(PeakNum..Shift1..Shift2..Code..SpecTyp..Vol..Err..IntMeth..Unused..Ass1..Ass2.."\n")
			if t.IncludeLabel == "YES" then
				outfile:write("# "..Res:getType():getLetter()..ResNum.."\n")
			end -- if t.IncludeLabel
		end -- if shift1 and shift2
	end -- if t.Sys
end -- for loop

-- close outfile
outfile:close()
print( "wrote all lines to peaklist file: "..t.Filename )
print( "\nPeakListNumberedByResidue is done." )

-- done with script

</code>
<fld name='Author' type='String'>Fred Damberger</fld>
<fld name='Creation Date' type='Date'>2005-3-26</fld>
<fld name='Description' type='Memo'>Generates a peaklist file from the assignments in a project where the peaks are numbered by residue number. This is useful for analysing relaxation or exchange data.

Instructions:
Enter the unique labels in each dimension for peaks.
E.g. HN/N for an HSQC15N to write out one HN/N peak for each system.

Note that it uses the SPINS to generate the peaks!</fld>
</script>
<script name='RemoveAliases'>
<code lang='Lua'>-- Script to remove Alias shifts from a spectrum in a project.
-- User can remove ALL alias shifts, or only those whose spin has a defined label.

-- F.Damberger 18.March.2004: script written
-- F.Damberger 11.Jan.2005: modified to include dialogs:
-- No editing necessary. The script asks the user for the input

-- WARNING: always backup your project before you execute the script.
-- There is no undo!

-- create temporary table to store variables
t = {}

--1. Get Project

local ProjectNames = {}
i = 0
for a,b in pairs(cara:getProjects()) do
	i = i + 1
	ProjectNames[ i ] = b:getName()
end
local ProjectName=dlg.getSymbol("Select Project","", unpack( ProjectNames ) )
t.P = cara:getProject( ProjectName )


-- 2. Get Spectrum to remove Alias shifts from:

local SpectrumNames = {}
local SpectrumID = {}
i = 0
for a,b in pairs( t.P:getSpectra() ) do
	i = i + 1
	SpectrumNames[ i ] = b:getName()
	SpectrumID[ i ] = b:getId()
end
local SpectrumName = dlg.getSymbol( "Select Spectrum to remove aliases from", "", unpack( SpectrumNames ) )

for i = 1, table.getn( SpectrumNames ) do
	if SpectrumNames[ i ] == SpectrumName then
		t.Spect = t.P:getSpectrum( SpectrumID[ i ] )
	end
end

-- 3. Get optional label of spins whose alias shifts are removed (optional)
t.choice = dlg.getSymbol("Do you want to remove all aliases (ALL) or only aliases for specific spins (SOME)?","","ALL", "SOME" ) 

if t.choice == "SOME" then
  t.label = dlg.getText("Enter Label of spins whose alias shifts are removed", "", "N" )
end

-- look for spins and delete aliases

local Num = 0
t.SpinsTable = t.P:getSpins()
for a,b in pairs ( t.SpinsTable ) do
	if b:getShift( t.Spect ) ~= b:getShift() then
		if t.choice == "SOME" then
			if b:getLabel()== t.label then
				t.P:setShift( b,b:getShift(),t.Spect )
				Num = Num + 1
			end
		else
			t.P:setShift( b,b:getShift(),t.Spect )
			Num = Num + 1
		end -- if choice = SOME
	end -- if alias exists
end -- for all spins

-- report results to user

if t.choice == "SOME" then
  print( "\n ------------------ Removing aliases for spins with label: "..t.label.." --------------------" )
else
  print ( "\nRemoving aliases for all spins" )
end
print("\nRemoved "..Num.." aliases from spectrum "..SpectrumName.." in project "..ProjectName)
print( "\n -------------------- Script RemoveAliases is finished. ---------------------" )

-- delete temporary table
t = nil
</code>
<fld name='Author' type='String'>Fred Damberger</fld>
<fld name='Creation Date' type='Date'>2005-3-26</fld>
<fld name='Description' type='Memo'>Removes alias shifts for selected spins of  the selected spectrum or all alias shifts for the selected spectrum.

e.g.

Remove spin aliases for "CA" in spectrum "HNCA" of project "Assign1".

Remove all spin aliasesfor spectrum "HNCA" of project "Assign1".</fld>
</script>
<script name='RemoveSelectedSystems'>
<code lang='Lua'>-- Script to erase spin systems that are not assigned to the sequence
-- F. Damberger  1.April.2004

-- Version 2: 26.April 2005 F. Damberger
-- modified to introduce user dialog window which remembers values

-- WARNING: this script erases large numbers of spins from project.
-- Always Back-up your Repository before executing the script!

-- ----------------------------------------------------------------------
-- Create array to hold all script variables
t={}

-- User can edit parameters below to adapt to the project:
-- ----------------------------------------------------------------------
IgnoreResidues = true
-- ======================== Define functions ============================

-- AllowedResidueRange
function AllowedResidueRange( StartNum, EndNum, Project )
	Result = true -- Assume ResidueRange is allowed
	StartChar,EndChar,StartNumberRetrieved = string.find( StartNum, "(%d*)" )
	StartChar,EndChar,EndNumberRetrieved = string.find( EndNum, "(%d*)" )
	StartNumberRetrieved = StartNumberRetrieved + 0
	EndNumberRetrieved = EndNumberRetrieved + 0
	if StartNumberRetrieved and EndNumberRetrieved and EndNumberRetrieved &gt;= StartNumberRetrieved then
		-- StartNum and EndNum are integers with accending values
--		for i=StartNum,EndNum do
--			if not Project:getSystem( i ) then
--				Result = false -- one System does not exist
--			end
--		end
	else
		Result = false -- StartNum,EndNum are not accending integers
	end
	return Result
end

-- ----------------------------------------------------------------------

function ResidueToRemove( Spin, StartRes, EndRes, KeepSelectedResidues )
	Result = false
	Residue = Spin:getResidue()
	if Residue then ResidueId = Residue:getId() end

	if ResidueId then
		if KeepSelectedResidues then -- Remove selected Residue if outside range
			if ResidueId &lt; StartRes or ResidueId &gt; EndRes then
				Result = true
			end
		else -- Remove selected Residue if included in range
			if ResidueId &gt;= StartRes and ResidueId &lt;= EndRes then
				Result = true
			end
		end -- if KeepSelectedResidues
	end -- if ResidueId
	return Result
end -- function
-- ----------------------------------------------------------------------

-- ====================== Get Selections from User ======================

--1. Set up dialog window
v = gui.createMainWindow()
v:setCaption( "RemoveSelectedSystems dialog" )
t.frm = gui.createGrid( v, 2, false )
v:setCentralWidget( t.frm )
v:show()
t.frm:show()

-- Labels for first two columns
t.ProjectListLabel = gui.createLabel( t.frm, "Select Project" )
t.ProjectListCB = gui.createComboBox( t.frm )


--2. Read ProjectNames into ProjectList combobox

SelectedItemIndex = nil
for Id,Project in pairs( cara:getProjects() ) do
	ItemIndex = t.ProjectListCB:addItem( Project:getName() )
	t.ProjectListCB:setCurrentItem( ItemIndex )
	if RemoveSelectedSystemsProjectName == t.ProjectListCB:getCurrentText() then
		SelectedItemIndex = ItemIndex
	end
end -- for all projects

if SelectedItemIndex then -- set to previous choice if it exists
	t.ProjectListCB:setCurrentItem( SelectedItemIndex )
end

-- Display ProjectList Combobox
t.ProjectListLabel:show()
t.ProjectListCB:show()

--3. ResidueRange 

-- Create Label and Combobox for ResidueRanges
t.StartResLELabel = gui.createLabel( t.frm, "Starting system (residue)" )
t.StartResLE = gui.createLineEdit( t.frm )
t.EndResLELabel = gui.createLabel( t.frm, " Ending system (residue)" )
t.EndResLE = gui.createLineEdit( t.frm )

if RemoveSelectedSystemsStartRes then -- determine if StartRes already exists
	t.StartResLE:setText( RemoveSelectedSystemsStartRes )
else
	t.StartResLE:setText( "1" ) -- default value
end

if RemoveSelectedSystemsEndRes then -- determine if StartRes already exists
	t.EndResLE:setText( RemoveSelectedSystemsEndRes )
else
	t.EndResLE:setText( "150" ) -- default value
end


-- Display Label and LineEdit windows
t.StartResLELabel:show()
t.StartResLE:show()

t.EndResLELabel:show()
t.EndResLE:show()

-- Checkboxes follow ------------------------------------------

--4. Checkbox KeepSelectedResidues

t.KeepSelectedResidues_ChBxLabel = gui.createLabel( t.frm, "Keep selected systems, and remove the rest." )
t.KeepSelectedResidues_ChBx = gui.createCheckBox( t.frm )

if RemoveSelectedSystemsKeepSelectedResidues == true then
	t.KeepSelectedResidues_ChBx:setChecked()
end
t.KeepSelectedResidues_ChBxLabel:show()
t.KeepSelectedResidues_ChBx:show()


-- ----------------------------------------------------------------------

--5. Checkbox Ignore ResidueAssignments

t.IgnoreResidues_ChBxLabel = gui.createLabel( t.frm, "Ignore residue assignments (remove system numbers): " )
t.IgnoreResidues_ChBx = gui.createCheckBox( t.frm )

if RemoveSelectedSystemsIgnoreResidues == true then -- determine if Selection was made previously
	t.IgnoreResidues_ChBx:setChecked()
end
t.IgnoreResidues_ChBxLabel:show()
t.IgnoreResidues_ChBx:show()

--6. OK and Cancel Buttons

t.okbutton = gui.createPushButton(t.frm, "OK" )
t.cancelbutton = gui.createPushButton( t.frm, "Cancel" )

t.okbutton:show()
t.cancelbutton:show()

-- ============ Callbacks for menu window ===============================

-- Define Callbacks for the buttons


-- cancel button Callback
t.cancelbutton:setCallback( gui.event.Clicked,
	function (self)
		v:close()
	end
)

-- OK button Callback
t.okbutton:setCallback( gui.event.Clicked,
	function (self)
-- =============== Determine User Preferences ===========================
		t.P = cara:getProject( t.ProjectListCB:getCurrentText() )
		RemoveSelectedSystemsProjectName = t.P:getName()
		t.StartNum = t.StartResLE:getText() + 0
		t.EndNum = t.EndResLE:getText() + 0
		if t.KeepSelectedResidues_ChBx:isChecked() then
			RemoveSelectedSystemsKeepSelectedResidues = true
		else
			RemoveSelectedSystemsKeepSelectedResidues = false
		end
		if t.IgnoreResidues_ChBx:isChecked() then
			RemoveSelectedSystemsIgnoreResidues = true
		end

		if AllowedResidueRange( t.StartNum, t.EndNum, t.P ) then
-- =============== Start erase procedure ================================
			RemoveSelectedSystemsStartRes = t.StartNum + 0
			RemoveSelectedSystemsEndRes = t.EndNum + 0
			t.StartRes = RemoveSelectedSystemsStartRes + 0
			t.EndRes = RemoveSelectedSystemsEndRes + 0
			
			-- get Sequence
			t.Seq = t.P:getSequence()

			-- get Systems			
			t.Sys = t.P:getSystems()
			
			-- create Array to Hold Selected Systems
			t.SelectSys={}
			
			-- loop through the Systems
			t.NumSelSys = 0
			for a,b in pairs( t.Sys ) do
				if RemoveSelectedSystemsIgnoreResidues or ResidueToRemove( b, t.StartRes, t.EndRes, RemoveSelectedSystemsKeepSelectedResidues ) then
				-- if b:getResidue() == nil or b:getResidue():getId() &lt; t.StartRes or b:getResidue():getId() &gt; t.EndRes then
					t.NumSelSys = t.NumSelSys + 1
					print("will remove system "..a.." "..b:getId())
					t.SelectSys[ t.NumSelSys ] = b
				end
			end
			print("total number of selected systems to remove: "..t.NumSelSys)
			
			-- display select systems
			
			print("-----------selected Systems-------------")
			for a,b in pairs(t.SelectSys) do
						 print(a.." "..b:getId() )
			end
			
			
			for a,b in pairs( t.SelectSys ) do
			
			--      print(a.." "..b:getResidue():getType():getShort())
			--   if predecessor, unlink Predecessor
				  if b:getPred() ~= nil then
					   print("unlinking pred "..b:getPred():getId())
					   t.P:unlinkSystems(b:getPred(),b)
				  end
				  if b:getSucc() ~= nil then
					   print("unlinking succ "..b:getSucc():getId())
					   t.P:unlinkSystems(b,b:getSucc())
				  end
				  if b:getResidue() ~= nil then
					   t.P:unassignSystem(b)
				  end
				   if b:getSpins() ~= nil then
			--          print("has spins")
					  t.SpinsInSys = b:getSpins()
			--      remove Spins in System
					 for c,d in pairs(t.SpinsInSys) do
			--          remove a spin
			--            print("spin to remove"..c.." "..d:getLabel())
						   t.P:unassignSpin(d)
						   t.P:removeSpin(d)
					 end
				  end
				  t.P:removeSystem(b)
			
			end
		else
			error(" Not an allowed residue range.")
		end
		v:close()
	end
)


-- t = {}
</code>
<fld name='Author' type='String'>Fred Damberger</fld>
<fld name='Creation Date' type='Date'>2005-3-29</fld>
<fld name='Description' type='Memo'> Remove a selected set of systems from a project.

e.g. remove spins, spinlinks and systems of systems 1-10.
You can also remove all systems EXCEPT for the selected set by clicking the appropriate button.
Finally it is possible to only remove systems if they are assigned to a residue with the appropriate button activated.

</fld>
</script>
<script name='CopyProjectedSpinsToOriginSystem'>
<code lang='Lua'>-----------------------------------------------------------------------------------------
-- script to copy selected spins (label X-1,X+1) of Spin System i-1,i+1
-- to the System i and changes the Spin Label to X

-- E.g. This allows the user to transfer the "projected" spins like "C-1" picked in an HNCO
-- from the system they were picked in (i-1) to the system they belong in (i: the successor system)
-- Ofcourse this only works if the predecessor has been linked to the system 

-- script transfers only one type of label (e.g. only CA-1 of system i-1 is copied to CA of system i).
-- There is also a script to copy all projected spins to their origin system (if they are assigned and linked).
-- It is called CopyAllProjectedSpinsToOriginSystem.lua

-- F. Damberger 3.Feb.2005

-- Version 2: modified to use a single dialog for entry of user parameters
-- F.Damberger April 1, 2005
-----------------------------------------------------------------------------------------
-- create temporary array for lua script
t={}



-- New interface

--1. Create main menu window

v = gui.createMainWindow()
v:setCaption( "Selection Dialog for Pick_2D_Peaks" )
t.frm = gui.createGrid( v, 2, false )
v:setCentralWidget( t.frm )
v:show()
t.frm:show()

-- Define ProjectList Combobox and its Label
t.ProjectListLabel = gui.createLabel( t.frm, "Select Project" )
t.ProjectListCB = gui.createComboBox( t.frm )


--2. Read ProjectNames into ProjectList combobox

SelectedItemIndex = nil
for Id,Project in pairs( cara:getProjects() ) do
	ItemIndex = t.ProjectListCB:addItem( Project:getName() )
	t.ProjectListCB:setCurrentItem( ItemIndex )
	if CopyProjectedSpinsToOriginalSystem_ProjectName == t.ProjectListCB:getCurrentText() then
		SelectedItemIndex = ItemIndex
	end
end -- for all projects

if SelectedItemIndex then -- set to previous choice if it exists
	t.ProjectListCB:setCurrentItem( SelectedItemIndex )
end

-- Display ProjectList Combobox
t.ProjectListLabel:show()
t.ProjectListCB:show()

--3. Create LineEdit window for: Label of Spins to copy

SelectedItemIndex = nil
t.LabelLELabel = gui.createLabel( t.frm, "Enter label of spins to copy" )
t.LabelLE = gui.createLineEdit( t.frm )
if CopyProjectedSpinsToOriginalSystem_Label then
	t.LabelLE:setText( CopyProjectedSpinsToOriginalSystem_Label )
else
	t.LabelLE:setText( "HA" )
end

-- Display Line edit for Labels
t.LabelLELabel:show()
t.LabelLE:show()

--4. Create ComboBox for offset

t.OffsetCBLabel = gui.createLabel( t.frm, "Select the offset of spins to copy" )
t.OffsetCB = gui.createComboBox( t.frm )

t.ListOfAllowedOffsets = { "-1", "+1" }
SelectedItemIndex = nil
for Index,Offset in pairs( t.ListOfAllowedOffsets ) do
	ItemIndex = t.OffsetCB:addItem( Offset )
	t.OffsetCB:setCurrentItem( ItemIndex )
	if CopyProjectedSpinsToOriginalSystem_Offset == t.OffsetCB:getCurrentText() then
		SelectedItemIndex = ItemIndex
	end
end

if SelecteItemIndex then
	t.OffsetCB:setCurrentItem( SelectedItemIndex )
end
t.OffsetCBLabel:show()
t.OffsetCB:show()

-- ================== END OF SELECTION DIALOG =============================

-- get values of Label and Offset
t.Label = nil
t.Offset = nil

if t.LabelLE:getText() then
	t.Label = t.LabelLE:getText()
end

if t.OffsetCB:getCurrentText() then
	t.Offset = t.OffsetCB:getCurrentText()
end

-- ================= Summary of action text =============================

if t.Label and t.Offset then
		SummaryOfActionText = t.Label..t.Offset.." (res i"..t.Offset..") -&gt; "..t.Label.." (res i)."
else
	SummaryOfActionText = "No selection made yet."
end
t.SummaryOfActionLabel = gui.createLabel( t.frm, "Press OK to: ")
t.SummaryOfActionLine = gui.createLabel( t.frm )
t.SummaryOfActionLine:setText( SummaryOfActionText )

t.SummaryOfActionLabel:show()
t.SummaryOfActionLine:show()

-- ================= create control buttons =============================

t.okbutton = gui.createPushButton(t.frm, "OK" )
t.cancelbutton = gui.createPushButton( t.frm, "Cancel" )

t.okbutton:show()
t.cancelbutton:show()

-- ================= CALLBACKS for menu window ==========================

-- offset Combobox callback
t.OffsetCB:setCallback( gui.event.Activated,
	function (self)
		t.Offset = t.OffsetCB:getCurrentText()
--		t.Offset = self:getCurrentText()
		SummaryOfActionText = t.Label..t.Offset.." (res i"..t.Offset..") -&gt; "..t.Label.." (res i)."
		t.SummaryOfActionLine:setText( SummaryOfActionText )
	end
) -- end offset Combobox callback

-- label Combobox callback
t.LabelLE:setCallback( gui.event.Changed,
	function (self)
		t.Label = t.LabelLE:getText()
		SummaryOfActionText = t.Label..t.Offset.." (res i"..t.Offset..") -&gt; "..t.Label.." (res i)."
		t.SummaryOfActionLine:setText( SummaryOfActionText )
	end
) -- end label Combobox callback



-- cancel button callback

t.cancelbutton:setCallback( gui.event.Clicked,
	function (self)
		v:close()
	end
) -- end cancelbutton callback

-- OK button Callback
t.okbutton:setCallback( gui.event.Clicked,
	function (self)


-- ================== Set the user preference variables ==================

-- get the project
for ProjId,Proj in pairs( cara:getProjects() ) do
	if Proj:getName() == t.ProjectListCB:getCurrentText() then
		t.P = Proj
	end
end
if t.P == nil then error("No valid project selected Aborting without any action.") end

-- get the label

t.Label = t.LabelLE:getText()
if t.Label == nil then error("No label was selected. Aborting without any action.") end

-- get the offset
if t.OffsetCB:getCurrentText() == nil then error("No offset value was selected. Aborting without any action.") end
t.Offset = t.OffsetCB:getCurrentText()

-- ================== START CREATING SPINS ================================

i=0
for SpinId,Spin in pairs( t.P:getSpins() ) do
	if Spin:getLabel() == t.Label..t.Offset then           -- SELECT THE SPINS TO BE COPIED
		t.NeighborSysExists = false
		if t.Offset == "-1" then
			if Spin:getSystem() and Spin:getSystem():getPred() then
				t.NeighborSysExists = true
				t.NeighborSysSpins = Spin:getSystem():getPred():getSpins()
			end
		elseif t.Offset == "+1" then
			if Spin:getSystem() and Spin:getSystem():getSucc() then
				t.NeighborSysExists = true
				tNeighborSysSpins = Spin:getSystem():getSucc():getSpins()
			end
		else
			error( "offset must be +1 or -1" )
		end
		if t.NeighborSysExists then	-- CHECK WHETHER newlabel ALREADY EXISTS
			
			t.NewLabelExists = false
			for NeighborSpinId,NeighborSpin in pairs( t.NeighborSysSpins ) do
				if NeighborSpin:getLabel() == t.Label  then
					t.NewLabelExists = true
				end
			end
			if not t.NewLabelExists then
				t.newspin = t.P:createSpin( Spin:getAtomType(), Spin:getShift() )
				i = i + 1
				if t.Offset == "-1" then
					t.P:assignSpin( t.newspin, Spin:getSystem():getPred() )
					print( "created spin "..t.Label.." in System "..Spin:getSystem():getPred():getId().." from spin "..t.Label..t.Offset.." in System "..Spin:getSystem():getId() )
				elseif t.Offset == "+1" then
					t.P:assignSpin( t.newspin, Spin:getSystem():getSucc() )
				else
					error( "offset must be +1 or -1" )
				end
				t.P:setLabel( t.newspin, t.Label )	  -- SELECT THE NEW SPINLABEL (must exist already in the repository)
			end
		end
	end 
end
print("\n-------- copied "..i.." "..t.Label..t.Offset.." to "..t.Label.." of i"..t.Offset.." neighbor. --------")
print( "\nCopyProjectedSpinsToOriginalSystem is finished" )
--free up script variables
-- t = nil
	v:close()
	end
) -- end okbutton callback


</code>
<fld name='Author' type='String'>Fred Damberger</fld>
<fld name='Creation Date' type='Date'>2005-4-1</fld>
<fld name='Description' type='Memo'>Copies projected spins to their origin system.

e.g. you measured an HNCO and picked the "C-1" spins in the i-1 system strips. Now you want to copy them to the origin system i with label "C".</fld>
</script>
<script name='Pick_2D_Peaks'>
<code lang='Lua'>--PickPeaks

--This script is for peak picking 2D spectra. Each new peak is considered
--a new CARA spin system, so this script is most useful for peak picking
--a 15N-HSQC spectrum. The peak-picked HSQC spectrum can be used to guide
--peak picking of 3D spectra using another script (i.e. Pick_3D_Peaks).

-- The labels of the spins are taken from the label of the dimension axes from
-- the 2D spectrum.
--
--Author: J.E.M.

-- modified to include a user dialog panel by F.Damberger Mar.29.2005

-- Script will prompt user for input.
-- You do not need to modify any lines below -FFD

--CONTROL_PANEL------------------------------------------------------

peak_picking_mode_1="simple";
print_spectral_information_only=0;


--end_of_control_panel-----------------------------------------------


function print_information_about_spectrum(spectrum)
    local num_of_dim=spectrum:getDimCount();
    local x,y,label,temp_string;
    local ppm_range_1,ppm_range_2;
    local label_RA={};
    print("\nspectrum&gt;    ID: "..spectrum:getId().."    name: "..spectrum:getName());
    for x=1,num_of_dim do
        ppm_range_1,ppm_range_2=spectrum:getPpmRange(x);
        print("    dimension: "..x.."    range: "..ppm_range_1.."&lt;--&gt;"..ppm_range_2.." (ppm)");
        label_RA=spectrum:getType():getLabels(x);
        temp_string="";for y,label in pairs(label_RA)do temp_string=temp_string.." "..label end;
        if(length_of(label_RA)==1)then print("        label:"..temp_string) else print("        labels:"..temp_string) end;
    end    --for x=1,num_of_dim
    print("\n");
end    --print_information_about_spectrum


function length_of(input_table)

    if(not(input_table))then return 0 end;
    xx=0;
    for x,y in pairs(input_table) do
        xx=xx+1
    end    --for x,y in pairs(input_table
    return xx;
end    --function length_of


function get_1D_from_spectrum(spectrum,d1,d2,d3,d4,d5)
    --test peak at d1=1H:470,d2=15N:23
    local amplitude;
    local output_1D_RA={};
    if(not(spectrum))then print("No spectrum with Id: "..input_spectrum_Id); return; end;
    local num_of_dim=spectrum:getDimCount();
    --print("num_of_dim: "..num_of_dim);
    --print("label 1: "..spectrum:getLabel(1));
    --print("label 2: "..spectrum:getLabel(2));
    local size_RA={};for x=1,num_of_dim do size_RA[x]=spectrum:getSampleCount(x) end;
    --print("size_RA[1]: "..size_RA[1].."    size_RA[2]: "..size_RA[2]);
    --print(d1);
    if((not(d1))and(num_of_dim&gt;=1))then
        for x=1,size_RA[1] do
            if(num_of_dim==5)then amplitude=spectrum:getAt(x,d2,d3,d4,d5);
            else if(num_of_dim==4)then amplitude=spectrum:getAt(x,d2,d3,d4);
            else if(num_of_dim==3)then amplitude=spectrum:getAt(x,d2,d3);
            else if(num_of_dim==2)then amplitude=spectrum:getAt(x,d2);
            else if(num_of_dim==1)then amplitude=spectrum:getAt(x);
            end;end;end;end;end    --if(num_of_dim==5
            output_1D_RA[x]=amplitude;
        end    --for x=0,size_RA[1
    end    --if((not(d1))and(num_of_dim&gt;=1
    if((not(d2))and(num_of_dim&gt;=2))then
        for x=1,size_RA[2] do
            if(num_of_dim==5)then amplitude=spectrum:getAt(d1,x,d3,d4,d5);
            else if(num_of_dim==4)then amplitude=spectrum:getAt(d1,x,d3,d4);
            else if(num_of_dim==3)then amplitude=spectrum:getAt(d1,x,d3);
            else if(num_of_dim==2)then amplitude=spectrum:getAt(d1,x);
            end;end;end;end   --if(num_of_dim==5
            output_1D_RA[x]=amplitude;
        end    --for x=0,size_RA[1
    end    --if((not(d2))and(num_of_dim&gt;=2
    if((not(d3))and(num_of_dim&gt;=3))then
        for x=1,size_RA[3] do
            if(num_of_dim==5)then amplitude=spectrum:getAt(d1,d2,x,d4,d5);
            else if(num_of_dim==4)then amplitude=spectrum:getAt(d1,d2,x,d4);
            else if(num_of_dim==3)then amplitude=spectrum:getAt(d1,d2,x);
            end;end;end    --if(num_of_dim==5
            output_1D_RA[x]=amplitude;
        end    --for x=0,size_RA[1
    end    --if((not(d3))and(num_of_dim&gt;=3
    if((not(d4))and(num_of_dim&gt;=4))then
        for x=1,size_RA[4] do
            if(num_of_dim==5)then amplitude=spectrum:getAt(d1,d2,d3,x,d5);
            else if(num_of_dim==4)then amplitude=spectrum:getAt(d1,d2,d3,x);
            end;end    --if(num_of_dim==5
            output_1D_RA[x]=amplitude;
        end    --for x=0,size_RA[1
    end    --if((not(d4))and(num_of_dim&gt;=4
    if((not(d5))and(num_of_dim&gt;=5))then
        for x=1,size_RA[5] do
            if(num_of_dim==5)then amplitude=spectrum:getAt(d1,d2,d3,d4,x);
            end    --if(num_of_dim==5
            output_1D_RA[x]=amplitude;
        end    --for x=0,size_RA[1
    end    --if((not(d5))and(num_of_dim&gt;=5
    --for x=1,length_of(output_1D_RA)do print("x: "..x.."    output_1D_RA[x]: "..output_1D_RA[x]) end;
    --for x=1,length_of(output_1D_RA)do print("x: "..x.."    "..output_1D_RA[x].."\n"..string.rep("=",output_1D_RA[x]/10000).."*") end;
    --getAt(d1,d2,d3,d4,d5)
    return output_1D_RA;

end    --function get_1D_from_spectrum


function increment_position_RA(input_position_RA)
    local position=3;
    local upper_limit=2;
    local lower_limit=1;
    local RA_length=length_of(input_position_RA)
    for row=1,RA_length do
        input_position_RA[row].position=(input_position_RA[row].position)+1;
        --if(row==RA_length)then print(input_position_RA[RA_length].position) end;
        if(input_position_RA[row].position&gt;input_position_RA[row].upper_limit)then
            input_position_RA[row].position=input_position_RA[row].lower_limit;
            if(row==RA_length)then return true end;
        else break;
        end    --if(input_position_RA[row].position&gt;input_pos
    end    --for row=1,RA_length
    return false;
end    --increment_position_RA


function initialize_size_RA(spectrum)
    local dimension;
    local size_RA={};
    local num_of_dim=spectrum:getDimCount();
    for dimension=1,num_of_dim do
        size_RA[dimension]=spectrum:getSampleCount(dimension);
    end    --for dimension=1,num_of_dim
    return size_RA;
end    --initialize_size_RA


function initialize_limit_RA(spectrum,input_limit_RA,size_RA)
    local upper=2;
    local lower=1;
    local dimension;
    local num_of_dim=spectrum:getDimCount();
    local limit_RA={};
    if(not(input_limit_RA))then
        for dimension=1,num_of_dim do
            local new_row={};
            limit_RA[dimension]=new_row;
            limit_RA[dimension].upper=math.floor(0.9*size_RA[dimension]+0.5);
            --print("limit_RA[dimension].upper: "..limit_RA[dimension].upper);
            limit_RA[dimension].lower=math.floor(0.1*size_RA[dimension]+0.5);
        end    --dimension=1,num_of_dim
        --print("limit_RA[1].upper: "..limit_RA[1].upper);
    else    limit_RA=input_limit_RA;
    end    --if(not(input_limit_RA
    return limit_RA;
end    --initialize_limit_RA


function initialize_position_marker_RA(spectrum,input_position_marker_RA,limit_RA,size_RA)
    local dimension;
    local num_of_dim=spectrum:getDimCount();
    local upper=2;
    local lower=1;
    local position=3;
    local upper_limit=2;
    local lower_limit=1;
    local position_marker_RA={};
    position_marker_RA=input_position_marker_RA;
    --print("limit_RA[1].upper: "..limit_RA[1].upper);
    for dimension=1,num_of_dim do
        local new_row={};
        position_marker_RA[dimension]=new_row;
        position_marker_RA[dimension].position=limit_RA[dimension].lower;
        if(limit_RA[dimension].upper)then position_marker_RA[dimension].upper_limit=limit_RA[dimension].upper;
        else position_marker_RA[dimension].upper_limit=math.floor(0.9*size_RA[dimension]+0.5) end;
        position_marker_RA[dimension].lower_limit=limit_RA[dimension].lower;
        --if(not(position_marker_RA[dimension].lower_limit))then position_marker_RA[dimension].lower_limit=math.floor(0.1*size_RA[dimension]+0.5) end;
    end    --for dimension=1,num_of_dim
    --for x=1,num_of_dim do print("dimension: "..x.."    lower_limit: "..position_marker_RA[x].lower_limit.."    upper_limit: "..position_marker_RA[x].upper_limit.."    position: "..position_marker_RA[x].position) end;
    --temp=false;while(not(temp))do temp=increment_position_RA(position_marker_RA) end;
    --for x=1,num_of_dim do print("dimension: "..x.."    lower_limit: "..position_marker_RA[x].lower_limit.."    upper_limit: "..position_marker_RA[x].upper_limit.."    position: "..position_marker_RA[x].position) end;
    return position_marker_RA;
end    --initialize_position_marker_RA

--REPLACED THIS FUNCTION WITH THE FUNCTION BELOW IT
function original_get_max_average_highest_lowest_amplitude(spectrum,input_limit_RA)
    local complete_scan_signal;
    local amplitude;
    local size_RA={};
    local position_marker_RA={};
    local num_of_dim=spectrum:getDimCount();
    local position=3;
    size_RA=initialize_size_RA(spectrum);
    limit_RA=initialize_limit_RA(spectrum,input_limit_RA,size_RA);
    position_marker_RA=initialize_position_marker_RA(spectrum,position_marker_RA,limit_RA,size_RA);
    complete_scan_signal=false;
    local average_amplitude=0;local num_of_points=0;local max_amplitude=0;local highest_intensity=0;local lowest_intensity=0;
    while(not(complete_scan_signal))do
        if(num_of_dim==1)then amplitude=spectrum:getAt(position_marker_RA[1].position) end;
        if(num_of_dim==2)then amplitude=spectrum:getAt(position_marker_RA[1].position,position_marker_RA[2].position) end;
        if(num_of_dim==3)then amplitude=spectrum:getAt(position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position) end;
        if(num_of_dim==4)then amplitude=spectrum:getAt(position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position,position_marker_RA[4].position) end;
        if(num_of_dim==5)then amplitude=spectrum:getAt(position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position,position_marker_RA[4].position,position_marker_RA[5].position) end;
        complete_scan_signal=increment_position_RA(position_marker_RA);
        num_of_points=num_of_points+1;average_amplitude=average_amplitude+math.abs(amplitude);
        if(math.abs(amplitude)&gt;max_amplitude)then max_amplitude=math.abs(amplitude) end;
        if(amplitude&gt;highest_intensity)then highest_intensity=amplitude end;
        if(amplitude&lt;lowest_intensity)then lowest_intensity=amplitude end;
    end    --while(not(complete_scan_signal
    average_amplitude=average_amplitude/num_of_points;
    return max_amplitude,average_amplitude,highest_intensity,lowest_intensity;
end    --get_max_average_highest_lowest_amplitude

function get_max_average_highest_lowest_amplitude(spectrum,input_limit_RA)
	pmax,pnoise,nmax,nnoise = spectrum:getLevels()
	average_amplitude = ( math.abs(pnoise) + math.abs(nnoise) )/2
	if ( math.abs(pmax) &gt; math.abs(nmax) ) then
		max_amplitude = math.abs(pmax)
	else
		max_amplitude = math.abs(nmax)
	end
	return max_amplitude,average_amplitude,pmax,nmax
end


function scale_RA(input_RA,input_max_amplitude)
    local x,y,max_amplitude;
    local output_RA={};
    max_amplitude=0;
    for x,y in pairs(input_RA)do
        if(y&gt;max_amplitude)then max_amplitude=y end;
    end    --for x,y in pairs(input_RA
    for x,y in pairs(input_RA)do
        output_RA[x]=(y/max_amplitude)*input_max_amplitude;
    end    --for x,y in pairs(input_RA
    return output_RA,max_amplitude
end    --scale_RA


function transfer_1D_RA_to_ND_RA(input_1D_spectrum_RA,input_ND_spectrum_RA,num_of_dim,position_RA,threshold,dimension_of_1D)

    local temp_threshold;
    local x,y,temp_dimension_of_1D,signal;
    local temp_ND_spectrum_RA={};
    local temp_pos_RA={};
    if (threshold) then temp_threshold=threshold else temp_threshold=0 end;
    signal=0;
    for x,y in pairs(input_1D_spectrum_RA) do
        if(math.abs(y)&gt;temp_threshold)then signal=1 end;
    end    --for x,y in pairs(input_1D_spectrum_RA
    if(signal&gt;0)then
        if(input_ND_spectrum_RA)then temp_ND_spectrum_RA=input_ND_spectrum_RA ;end;
        if(not(dimension_of_1D))then
        for x=1,num_of_dim do if(not(position_RA[x]))then temp_dimension_of_1D=x end;end;
        else temp_dimension_of_1D=dimension_of_1D end;
        for x,y in pairs(position_RA) do temp_pos_RA[x]=y end;
        for x,y in pairs(input_1D_spectrum_RA) do
            if(math.abs(y)&gt;temp_threshold)then
                temp_pos_RA[temp_dimension_of_1D]=x;
                if(num_of_dim==1)then
                    temp_ND_spectrum_RA[temp_pos_RA[1]]=y;
                end    --if(num_of_dim==5
                if(num_of_dim==2)then
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]]=new_row end;
                    temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]]=y;
                end    --if(num_of_dim==5
                if(num_of_dim==3)then
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]]=new_row end;
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]]=new_row end;
                    temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]][temp_pos_RA[3]]=y;
                end    --if(num_of_dim==5
                if(num_of_dim==4)then
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]]=new_row end;
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]]=new_row end;
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]][temp_pos_RA[3]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]][temp_pos_RA[3]]=new_row end;
                    temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]][temp_pos_RA[3]][temp_pos_RA[4]]=y;
                end    --if(num_of_dim==5
                if(num_of_dim==5)then
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]]=new_row end;
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]]=new_row end;
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]][temp_pos_RA[3]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]][temp_pos_RA[3]]=new_row end;
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]][temp_pos_RA[3]][temp_pos_RA[4]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]][temp_pos_RA[3]][temp_pos_RA[4]]=new_row end;
                    temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]][temp_pos_RA[3]][temp_pos_RA[4]][temp_pos_RA[5]]=y;
                end    --if(num_of_dim==5
            end    --if(math.abs(y)&gt;temp_threshold
        end    --for x,y in pairs(input_1D_spectrum_RA
    input_ND_spectrum_RA=temp_ND_spectrum_RA;
    end    --if(signal&gt;0
    return;
end    --transfer_1D_RA_to_3D_RA


function multiply_combine_spectrum_RAs(input_RA_of_spectra,num_of_dim)

    local spectrum_num=1;
    local marker_1,marker_2,marker_3,marker_4,marker_5;
    num_of_spectra=length_of(input_RA_of_spectra);
    if(num_of_dim&gt;=1)then local size_1=length_of(input_RA_of_spectra[spectrum_num]) end;
    if(num_of_dim&gt;=2)then local size_2=length_of(input_RA_of_spectra[spectrum_num][1]) end;
    if(num_of_dim&gt;=3)then local size_3=length_of(input_RA_of_spectra[spectrum_num][1][1]) end;
    if(num_of_dim&gt;=4)then local size_4=length_of(input_RA_of_spectra[spectrum_num][1][1][1]) end;
    if(num_of_dim&gt;=5)then local size_5=length_of(input_RA_of_spectra[spectrum_num][1][1][1][1]) end;
    if(num_of_dim&gt;=1)then
        for d1=1,size_1 do
            if(num_of_dim&gt;=2)then
                for d2=1,size_2 do
                    if(num_of_dim&gt;=3)then
                        for d3=1,size_3 do
                            if(num_of_dim&gt;=4)then
                                for d4=1,size_4 do
                                    if(num_of_dim&gt;=5)then
                                        marker_5=0;
                                        for d5=1,size_5 do
                                            --5 dimensions:
                                            for x=1,num_of_spectra do
                                                if(not(output_spectra[d1]))then local new_row={};output_spectra[d1]=new_row;end;
                                                if(not(output_spectra[d1][d2]))then local new_row={};output_spectra[d1][d2]=new_row;end;
                                                if(not(output_spectra[d1][d2][d3]))then local new_row={};output_spectra[d1][d2][d3]=new_row;end;
                                                if(not(output_spectra[d1][d2][d3][d4]))then local new_row={};output_spectra[d1][d2][d3][d4]=new_row;end;
                                                if(not(output_spectra[d1][d2][d3][d4][d5]))then output_spectra[d1][d2][d3][d4][d5]=0;if(x==1)then output_spectra[d1][d2][d3][d4][d5]=1 end;end;
                                                new_int=nil;if(input_RA_of_spectra[x][d1])then if(input_RA_of_spectra[x][d1][d2])then if(input_RA_of_spectra[x][d1][d2][d3])then if(input_RA_of_spectra[x][d1][d2][d3][d4])then if(input_RA_of_spectra[x][d1][d2][d3][d4][d5])then new_int=input_RA_of_spectra[x][d1][d2][d3][d4][d5] end;end;end;end;end;
                                                if(new_int)then output_spectra[d1][d2][d3][d4][d5]=output_spectra[d1][d2][d3][d4][d5]*new_int else output_spectra[d1][d2][d3][d4][d5]=0 end    --if(new_int
                                                --if(output_spectra[d1][d2][d3][d4][d5]==0)then output_spectra[d1][d2][d3][d4][d5]=nil end;
                                            end    --for x=1,num_of_spectra
                                            if(output_spectra[d1][d2][d3][d4][d5]~=0)then output_spectra[d1][d2][d3][d4][d5]=output_spectra[d1][d2][d3][d4][d5]^(1/num_of_spectra);marker_1=1;marker_2=1;marker_3=1;marker_4=1;marker_1=5; end;
                                        end    --for d5=1,size_5
                                        if(marker_5==0)then output_spectra[d1][d2][d3][d4][d5]=nil end;
                                    else    --if(num_of_dim&gt;=5
                                        --4 dimensions:
                                        for x=1,num_of_spectra do
                                            if(not(output_spectra[d1]))then local new_row={};output_spectra[d1]=new_row;end;
                                            if(not(output_spectra[d1][d2]))then local new_row={};output_spectra[d1][d2]=new_row;end;
                                            if(not(output_spectra[d1][d2][d3]))then local new_row={};output_spectra[d1][d2][d3]=new_row;end;
                                            if(not(output_spectra[d1][d2][d3][d4]))then output_spectra[d1][d2][d3][d4]=0;if(x==1)then output_spectra[d1][d2][d3][d4]=1 end;end;
                                            new_int=nil;if(input_RA_of_spectra[x][d1])then if(input_RA_of_spectra[x][d1][d2])then if(input_RA_of_spectra[x][d1][d2][d3])then if(input_RA_of_spectra[x][d1][d2][d3][d4])then new_int=input_RA_of_spectra[x][d1][d2][d3][d4] end;end;end;end;
                                            if(new_int)then output_spectra[d1][d2][d3][d4]=output_spectra[d1][d2][d3][d4]*new_int else output_spectra[d1][d2][d3][d4]=0 end    --if(new_int
                                            --if(output_spectra[d1][d2][d3][d4]==0)then output_spectra[d1][d2][d3][d4]=nil end;
                                        end    --for x=1,num_of_spectra
                                        if(output_spectra[d1][d2][d3][d4]~=0)then output_spectra[d1][d2][d3][d4]=output_spectra[d1][d2][d3][d4]^(1/num_of_spectra);marker_1=1;marker_2=1;marker_3=1;marker_4=1; end;
                                    end    --if(num_of_dim&gt;=5...else
                                end    --for d4=1,size_4
                                if(marker_4==0)then output_spectra[d1][d2][d3][d4]=nil end;
                            else    --if(num_of_dim&gt;=4
                                --3 dimensions:
                                for x=1,num_of_spectra do
                                    if(not(output_spectra[d1]))then local new_row={};output_spectra[d1]=new_row;end;
                                    if(not(output_spectra[d1][d2]))then local new_row={};output_spectra[d1][d2]=new_row;end;
                                    if(not(output_spectra[d1][d2][d3]))then output_spectra[d1][d2][d3]=0;if(x==1)then output_spectra[d1][d2][d3]=1 end;end;
                                    new_int=nil;if(input_RA_of_spectra[x][d1])then if(input_RA_of_spectra[x][d1][d2])then if(input_RA_of_spectra[x][d1][d2][d3])then new_int=input_RA_of_spectra[x][d1][d2][d3] end;end;end;
                                    if(new_int)then output_spectra[d1][d2][d3]=output_spectra[d1][d2][d3]*new_int else output_spectra[d1][d2][d3]=0 end    --if(new_int
                                    --if(output_spectra[d1][d2][d3]==0)then output_spectra[d1][d2][d3]=nil end;
                                end    --for x=1,num_of_spectra
                                if(output_spectra[d1][d2][d3]~=0)then output_spectra[d1][d2][d3]=output_spectra[d1][d2][d3]^(1/num_of_spectra);marker_1=1;marker_2=1;marker_3=1; end;
                            end    --if(num_of_dim&gt;=4...else
                        end    --for d3=1,size_3
                        if(marker_3==0)then output_spectra[d1][d2][d3]=nil end;
                    else    --if(num_of_dim&gt;=3
                        --2 dimensions:
                        for x=1,num_of_spectra do
                            if(not(output_spectra[d1]))then local new_row={};output_spectra[d1]=new_row;end;
                            if(not(output_spectra[d1][d2]))then output_spectra[d1][d2]=0;if(x==1)then output_spectra[d1][d2]=1 end;end;
                            new_int=nil;if(input_RA_of_spectra[x][d1])then if(input_RA_of_spectra[x][d1][d2])then new_int=input_RA_of_spectra[x][d1][d2] end;end;
                            if(new_int)then output_spectra[d1][d2]=output_spectra[d1][d2]*new_int else output_spectra[d1][d2]=0 end    --if(new_int
                            --if(output_spectra[d1][d2]==0)then output_spectra[d1][d2]=nil end;
                        end    --for x=1,num_of_spectra
                        if(output_spectra[d1][d2]~=0)then output_spectra[d1][d2]=output_spectra[d1][d2]^(1/num_of_spectra);marker_1=1;marker_2=1; end;
                    end    --if(num_of_dim&gt;=3...else
                end    --for d2=1,size_2
                if(marker_2==0)then output_spectra[d1][d2]=nil end;
            else    --if(num_of_dim&gt;=2
                --1 dimensions:
                for x=1,num_of_spectra do
                    if(not(output_spectra[d1]))then output_spectra[d1]=0;if(x==1)then output_spectra[d1]=1 end;end;
                    new_int=nil;if(input_RA_of_spectra[x][d1])then new_int=input_RA_of_spectra[x][d1] end;
                    if(new_int)then output_spectra[d1]=output_spectra[d1]*new_int else output_spectra[d1]=0 end    --if(new_int
                    --if(output_spectra[d1]==0)then output_spectra[d1]=nil end;
                end    --for x=1,num_of_spectra
                if(output_spectra[d1]~=0)then output_spectra[d1]=output_spectra[d1]^(1/num_of_spectra);marker_1=1; end;
            end    --if(num_of_dim&gt;=2...else
        end    --for d1=1,size_1
        if(marker_1==0)then output_spectra[d1]=nil end;
    else    --if(num_of_dim&gt;=1
        print("dimensionality=0");
    end    --if(num_of_dim&gt;=1...else
    return output_spectra;
end    --multiply_combine_spectrum_RAs


function get_intensity_from_nD_RA(input_spectrum_RA,x1,x2,x3,x4,x5)
    if(x5)then
        if(not(input_spectrum_RA[x1]))then return nil end;
        if(not(input_spectrum_RA[x1][x2]))then return nil end;
        if(not(input_spectrum_RA[x1][x2][x3]))then return nil end;
        if(not(input_spectrum_RA[x1][x2][x3][x4]))then return nil end;
        if(not(input_spectrum_RA[x1][x2][x3][x4][x5]))then return nil end;
        return input_spectrum_RA[x1][x2][x3][x4][x5];
    end    --if(x5
    if(x4)then
        if(not(input_spectrum_RA[x1]))then return nil end;
        if(not(input_spectrum_RA[x1][x2]))then return nil end;
        if(not(input_spectrum_RA[x1][x2][x3]))then return nil end;
        if(not(input_spectrum_RA[x1][x2][x3][x4]))then return nil end;
        return input_spectrum_RA[x1][x2][x3][x4];
    end    --if(x4
    if(x3)then
        if(not(input_spectrum_RA[x1]))then return nil end;
        if(not(input_spectrum_RA[x1][x2]))then return nil end;
        if(not(input_spectrum_RA[x1][x2][x3]))then return nil end;
        return input_spectrum_RA[x1][x2][x3];
    end    --if(x3
    if(x2)then
        if(not(input_spectrum_RA[x1]))then return nil end;
        if(not(input_spectrum_RA[x1][x2]))then return nil end;
        return input_spectrum_RA[x1][x2];
    end    --if(x2
    if(x1)then
        if(not(input_spectrum_RA[x1]))then return nil end;
        return input_spectrum_RA[x1];
    end    --if(x1
    return nil;
end    --get_intensity_from_nD_RA


function identify_peaks_in_ND_spectrum(spectrum,peak_shape_RA,threshold,input_limit_RA,mode,point_window_RA)
    local size_RA={};
    local position_marker_RA={};
    local num_of_dim=spectrum:getDimCount();
    local position_marker_RA={};
    local temp_position_RA={};
    local temp_1D_spectrum_RA={};
    local new_row={};
    local output_peak_shape_RA={};
    local RA_of_spectra={};
    local temp_point_window_RA={};
    local processed_spectrum_RA={};
    local output_peak_table={};
    local upper=2;
    local lower=1;
    local position=3;
    local upper_limit=2;
    local lower_limit=1;
    local amplitude_index=1;
    local intensity_index=2;
    local coordinates_index=3;
    local max_amplitude,average_amplitude,local_max_signal,center_amp,center_intensity;
    for x=1,num_of_dim do local new_row={};RA_of_spectra[x]=new_row; end;
    if(not(point_window_RA))then for x=1,num_of_dim do temp_point_window_RA[x]=10 end; else temp_point_window_RA=point_window_RA end;
    for x=1,num_of_dim do
        if(temp_point_window_RA[x]&lt;4)then temp_point_window_RA[x]=4 end;
        if(math.mod(temp_point_window_RA[x],2)==1)then temp_point_window_RA[x]=temp_point_window_RA[x]+1 end;
    end    --for x=1,num_of_dim
    if(not(mode))then temp_mode="simple" else temp_mode=mode end;
    print("temp_mode: "..temp_mode);
    size_RA=initialize_size_RA(spectrum);
    limit_RA=initialize_limit_RA(spectrum,input_limit_RA,size_RA);
    max_amplitude,average_amplitude=get_max_average_highest_lowest_amplitude(spectrum,limit_RA);
    print("max_amplitude: "..max_amplitude.."    average_amplitude: "..average_amplitude);
    position_marker_RA=initialize_position_marker_RA(spectrum,position_marker_RA,limit_RA,size_RA);
    --print("ave/max: "..average_amplitude/max_amplitude);
    if (not(threshold)) then temp_threshold=average_amplitude*4 else temp_threshold=threshold end;
    print("threshold: "..temp_threshold);
    for dimension=1,num_of_dim do
        complete_scan_signal=false;
        while(not(complete_scan_signal))do
            if(position_marker_RA[dimension].position==limit_RA[dimension].lower)then
                --print("position[dimension]: "..position_marker_RA[dimension].position);
                for x=1,num_of_dim do temp_position_RA[x]=position_marker_RA[x].position end;
                temp_position_RA[dimension]=nil;
                temp_1D_spectrum_RA=get_1D_from_spectrum(spectrum,temp_position_RA[1],temp_position_RA[2],temp_position_RA[3],temp_position_RA[4],temp_position_RA[5]);
                --for x=1,length_of(temp_spectrum_RA)do print ("x: "..x.."    "..temp_spectrum_RA[x]) end;
                local new_row={};
                --print("length_of(temp_1D_spectrum_RA): "..length_of(temp_1D_spectrum_RA));
                --print("length_of(peak_shape_RA[dimension]): "..length_of(peak_shape_RA[dimension]));
                if(temp_mode=="complex")then
                    new_row=grow_peaks_into_1D_RA(temp_1D_spectrum_RA,peak_shape_RA[dimension],limit_RA[dimension].lower,limit_RA[dimension].upper,temp_threshold);
                    transfer_1D_RA_to_3D_RA(new_row,RA_of_spectra[dimension],num_of_dim,temp_position_RA,temp_threshold);
                end    --if(mode=="complex
                if(temp_mode=="simple")then
                    transfer_1D_RA_to_ND_RA(temp_1D_spectrum_RA,RA_of_spectra[dimension],num_of_dim,temp_position_RA,temp_threshold);
                    --print("length_of(temp_1D_spectrum_RA): "..length_of(temp_1D_spectrum_RA));
                    --print("length_of(RA_of_spectra[dimension]: "..length_of(RA_of_spectra[dimension]));
                end    --if(temp_mode=="simple
            end    --if(position_marker_RA[dimension].position==limit_RA[dimension].lower
            complete_scan_signal=increment_position_RA(position_marker_RA);
        end    --while(not(complete_scan_signal
    end    --for dimension=1,num_of_dim()
    if(temp_mode=="complex")then processed_spectrum_RA=multiply_combine_spectrum_RAs(RA_of_spectra,num_of_dim) end;
    if(temp_mode=="simple")then processed_spectrum_RA=RA_of_spectra[1] end;
    print("length_of(processed_spectrum_RA): "..length_of(processed_spectrum_RA));
    --3-point filtering here.
    local peak_number=0;
    complete_scan_signal=false;
    position_marker_RA=initialize_position_marker_RA(spectrum,position_marker_RA,limit_RA,size_RA);
    while(not(complete_scan_signal))do
        if(num_of_dim==1)then
            local_max_signal=1;
            center_intensity=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position);
            if(center_intensity)then
                center_amp=math.abs(center_intensity);
                for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2 do
                    temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position+x);
                    if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                end    --for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2
                if(local_max_signal&gt;0)then
                    local temp_table={};
                    temp_table[1]=spectrum:getFreq(1,position_marker_RA[1].position);
                    local new_row={};
                    new_row.coordinates_index=temp_table;
                    new_row.intensity_index=center_intensity;
                    new_row.amplitude_index=center_amp;
                    peak_number=peak_number+1;output_peak_table[peak_number]=new_row;
                end    --if(local_max_signal&gt;0
            end    --if(center_intensity
        end    --if(num_of_dim==1
        if(num_of_dim==2)then
            local_max_signal=1;
            center_intensity=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position);
            if(center_intensity)then
                center_amp=math.abs(center_intensity); 
                for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2 do
                    temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position+x,position_marker_RA[2].position);
                    if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                end    --for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[2]/2,temp_point_window_RA[2]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position+x);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[2]/2,temp_point_window_RA[2]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    --print("peak: ["..position_marker_RA[1].position.."]["..position_marker_RA[2].position.."]    "..center_amp);
                    --print("peak: ["..spectrum:getFreq(1,position_marker_RA[1].position).."]["..spectrum:getFreq(2,position_marker_RA[2].position).."]    "..center_amp);
                    local temp_table={};
                    temp_table[1]=spectrum:getFreq(1,position_marker_RA[1].position);
                    temp_table[2]=spectrum:getFreq(2,position_marker_RA[2].position);
                    local new_row={};
                    new_row.coordinates_index=temp_table;
                    new_row.intensity_index=center_intensity;
                    new_row.amplitude_index=center_amp;
                    peak_number=peak_number+1;output_peak_table[peak_number]=new_row;
                end    --if(local_max_signal&gt;0
            end    --if(center_intensity
        end    --if(num_of_dim==2
        if(num_of_dim==3)then
            local_max_signal=1;
            center_intensity=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position);
            if(center_intensity)then
                center_amp=math.abs(center_intensity); 
                for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2 do
                    temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position+x,position_marker_RA[2].position,position_marker_RA[3].position);
                    if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                end    --for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[2]/2,temp_point_window_RA[2]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position+x,position_marker_RA[3].position);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[2]/2,temp_point_window_RA[2]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[3]/2,temp_point_window_RA[3]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position+x);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[3]/2,temp_point_window_RA[3]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    local temp_table={};
                    temp_table[1]=spectrum:getFreq(1,position_marker_RA[1].position);
                    temp_table[2]=spectrum:getFreq(2,position_marker_RA[2].position);
                    temp_table[3]=spectrum:getFreq(3,position_marker_RA[3].position);
                    local new_row={};
                    new_row.coordinates_index=temp_table;
                    new_row.intensity_index=center_intensity;
                    new_row.amplitude_index=center_amp;
                    peak_number=peak_number+1;output_peak_table[peak_number]=new_row;
                end    --if(local_max_signal&gt;0
            end    --if(center_intensity
        end    --if(num_of_dim==3
        if(num_of_dim==4)then
            local_max_signal=1;
            center_intensity=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position,position_marker_RA[4].position);
            if(center_intensity)then
                center_amp=math.abs(center_intensity);
                for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2 do
                    temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position+x,position_marker_RA[2].position,position_marker_RA[3].position,position_marker_RA[4].position);
                    if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                end    --for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[2]/2,temp_point_window_RA[2]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position+x,position_marker_RA[3].position,position_marker_RA[4].position);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[2]/2,temp_point_window_RA[2]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[3]/2,temp_point_window_RA[3]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position+x,position_marker_RA[4].position);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[3]/2,temp_point_window_RA[3]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[4]/2,temp_point_window_RA[4]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position,position_marker_RA[4].position+x);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[4]/2,temp_point_window_RA[4]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    local temp_table={};
                    temp_table[1]=spectrum:getFreq(1,position_marker_RA[1].position);
                    temp_table[2]=spectrum:getFreq(2,position_marker_RA[2].position);
                    temp_table[3]=spectrum:getFreq(3,position_marker_RA[3].position);
                    temp_table[4]=spectrum:getFreq(4,position_marker_RA[4].position);
                    local new_row={};
                    new_row.coordinates_index=temp_table;
                    new_row.intensity_index=center_intensity;
                    new_row.amplitude_index=center_amp;
                    peak_number=peak_number+1;output_peak_table[peak_number]=new_row;
                end    --if(local_max_signal&gt;0
            end    --if(center_intensity
        end    --if(num_of_dim==4
        if(num_of_dim==5)then
            local_max_signal=1;
            center_intensity=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position,position_marker_RA[4].position,position_marker_RA[5].position);
            if(center_intensity)then
                center_amp=math.abs(center_intensity); 
                for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2 do
                    temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position+x,position_marker_RA[2].position,position_marker_RA[3].position,position_marker_RA[4].position,position_marker_RA[5].position);
                    if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                end    --for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[2]/2,temp_point_window_RA[2]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position+x,position_marker_RA[3].position,position_marker_RA[4].position,position_marker_RA[5].position);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[2]/2,temp_point_window_RA[2]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[3]/2,temp_point_window_RA[3]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position+x,position_marker_RA[4].position,position_marker_RA[5].position);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[3]/2,temp_point_window_RA[3]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[4]/2,temp_point_window_RA[4]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position,position_marker_RA[4].position+x,position_marker_RA[5].position);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[4]/2,temp_point_window_RA[4]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[5]/2,temp_point_window_RA[5]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position,position_marker_RA[4].position,position_marker_RA[5].position+x);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[5]/2,temp_point_window_RA[5]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    local temp_table={};
                    temp_table[1]=spectrum:getFreq(1,position_marker_RA[1].position);
                    temp_table[2]=spectrum:getFreq(2,position_marker_RA[2].position);
                    temp_table[3]=spectrum:getFreq(3,position_marker_RA[3].position);
                    temp_table[4]=spectrum:getFreq(4,position_marker_RA[4].position);
                    temp_table[5]=spectrum:getFreq(5,position_marker_RA[5].position);
                    local new_row={};
                    new_row.coordinates_index=temp_table;
                    new_row.intensity_index=center_intensity;
                    new_row.amplitude_index=center_amp;
                    peak_number=peak_number+1;output_peak_table[peak_number]=new_row;
                end    --if(local_max_signal&gt;0
            end    --if(center_intensity
        end    --if(num_of_dim==5
        complete_scan_signal=increment_position_RA(position_marker_RA);
    end    --while(not(complete_scan_signal
    return output_peak_table;
end    --indentify_peaks_in_ND_spectrum


function create_spin_system(project,spectrum,f1,f2,f3,f4,f5)
    local new_spin_system=project:createSystem();
    --print("new_spin_system Id: "..new_spin_system:getId());
    if(f1)then 
        local new_spin=project:createSpin(spectrum:getAtomType(1),f1);
        new_label_RA=spectrum:getType():getLabels(1);
        if(length_of(new_label_RA)==1)then project:setLabel(new_spin,new_label_RA[1]) end;
        project:assignSpin(new_spin,new_spin_system);
    end    --if(f1
    if(f2)then 
        local new_spin=project:createSpin(spectrum:getAtomType(2),f2);
        new_label_RA=spectrum:getType():getLabels(2);
        if(length_of(new_label_RA)==1)then project:setLabel(new_spin,new_label_RA[1]) end;
        project:assignSpin(new_spin,new_spin_system);
    end    --if(f2
    if(f3)then 
        local new_spin=project:createSpin(spectrum:getAtomType(3),f3);
        new_label_RA=spectrum:getType():getLabels(3);
        if(length_of(new_label_RA)==1)then project:setLabel(new_spin,new_label_RA[1]) end;
        project:assignSpin(new_spin,new_spin_system);
    end    --if(f3
    if(f4)then 
        local new_spin=project:createSpin(spectrum:getAtomType(4),f4);
        new_label_RA=spectrum:getType():getLabels(4);
        if(length_of(new_label_RA)==1)then project:setLabel(new_spin,new_label_RA[1]) end;
        project:assignSpin(new_spin,new_spin_system);
    end    --if(f4
    if(f5)then 
        local new_spin=project:createSpin(spectrum:getAtomType(5),f5);
        new_label_RA=spectrum:getType():getLabels(5);
        if(length_of(new_label_RA)==1)then project:setLabel(new_spin,new_label_RA[1]) end;
        project:assignSpin(new_spin,new_spin_system);
    end    --if(f5
end    --create_spin_system

function pick_spin_systems_in_HSQC(project,spectrum,peak_shape_RA,threshold,input_limit_RA,mode,point_window_RA)
    local x,y;
    local peak_table={};
    local num_of_dim=spectrum:getDimCount();
    local amplitude_index=1;
    local intensity_index=2;
    local coordinates_index=3;
    peak_table=identify_peaks_in_ND_spectrum(spectrum,peak_shape_RA,threshold,input_limit_RA,mode,point_window_RA);
    print("number of peaks identified: "..length_of(peak_table));
    for x,peak_entry in pairs(peak_table)do
        --print("["..peak_entry.coordinates_index[1].."]["..peak_entry.coordinates_index[2].."]    "..peak_entry.amplitude_index.."    "..peak_entry.intensity_index);
        create_spin_system(project,spectrum,peak_entry.coordinates_index[1],peak_entry.coordinates_index[2],peak_entry.coordinates_index[3],peak_entry.coordinates_index[4],peak_entry.coordinates_index[5]);
    end    --for x,peak_entry in pairs(peak_table
end    --pick_spin_systems_in_HSQC


function is_local_max_in_1D_RA(point,input_1D_spectrum_RA,window_size)
    local size=length_of(input_1D_spectrum_RA);
    local temp_window_size;
    if(not(window_size))then temp_window_size=math.floor(size/100) else temp_window_size=window_size end;
    if(math.mod(temp_window_size,2)~=0)then temp_window_size=temp_window_size-1 end;
    local x;
    for x=-temp_window_size/2,temp_window_size/2 do
        if((point+x&gt;0)and(point+x&lt;=size))then
            if(math.abs(input_1D_spectrum_RA[point+x])&gt;input_1D_spectrum_RA[point])then return false end;
            if((math.abs(input_1D_spectrum_RA[point+x])==input_1D_spectrum_RA[point])and(x==-1))then return false end;
        end    --if((point+x&gt;0)and(point+x&lt;=size
    end    --for x=-temp_window_size/2,temp_window_size/2
    return true;
end    --is_local_max_in_1D_RA


function get_local_max_delta_from_1D_RA(point,input_1D_spectrum_RA,window_size)
    --print(input_1D_spectrum_RA);
    local size=length_of(input_1D_spectrum_RA);
    local temp_window_size;
    if(not(window_size))then temp_window_size=math.floor(size/100) else temp_window_size=window_size end;
    if(math.mod(temp_window_size,2)~=0)then temp_window_size=temp_window_size-1 end;
    --print("window_size: "..window_size.."    point: "..point);
    local x;
    --print("size: "..size);
    local max_minus_pos=nil;
    for x=0,temp_window_size/2 do
        if((point-x&gt;0)and(point-x&lt;=size))then
            if(is_local_max_in_1D_RA(point-x,input_1D_spectrum_RA,temp_window_size))then max_minus_pos=point-x;break end;
        end    --if((point-x&gt;0)and(point-x&lt;=size
    end    --for x=0,temp_window_size/2
    local max_plus_pos=nil;
    for x=point,point+temp_window_size/2 do
        if((x&gt;0)and(x&lt;=size))then
            if(is_local_max_in_1D_RA(x,input_1D_spectrum_RA,temp_window_size))then max_plus_pos=x;break end;
        end    --if((x&gt;0)and(x&lt;=size
    end    --for x=point,point-temp_window_size/2
    --print("======= "..max_plus_pos);
    --print("======= "..max_minus_pos);
    local delta_minus=nil;if(max_minus_pos)then delta_minus=point-max_minus_pos end;
    --print("======= "..delta_minus);
    local delta_plus=nil;if(max_plus_pos)then delta_plus=max_plus_pos-point end;
    --print("======= "..delta_plus);
    if((not(delta_minus))and(not(delta_plus)))then closest_max_pos=nil;
    else if((max_minus_pos)and(not(max_plus_pos)))then closest_max_pos=delta_minus;
         else if((max_plus_pos)and(not(max_minus_pos)))then closest_max_pos=delta_plus;
              else closest_max_pos=delta_minus;if(delta_plus&lt;delta_minus)then closest_max_pos=delta_plus end;
              end;
         end;
    end;
    --if(closest_max_pos)then print("closest_max_pos: "..closest_max_pos) else print("closest_max_pos: nil") end;
    return closest_max_pos;
end    --get_local_max_delta_from_1D_RA


function pick_spins_in_3D(project,input_3D_spectrum,input_2D_spectrum,input_threshold,input_limit_RA,window_width_RA)
    local size_RA_3D={};
    local limit_RA={};
    local spin_system_RA={};
    local label_RA_3D={};
    local label_RA_2D={};
    local dimension_map_RA_2_3={};
    local dimension_map_RA_3_2={};
    local temp_coor_RA={};
    local temp_1D_spectrum_RA_2={};
    local x,y;
    local upper=2;
    local lower=1;
    local temp_3D_spectrum,temp_3D_spectrum;
    local num_of_dim_3D=input_3D_spectrum:getDimCount();
    local num_of_dim_2D=input_2D_spectrum:getDimCount();
    local temp_lower_point_limit;
    local temp_lower_point_limit;
    local temp_window_width_RA={};
    local temp_threshold;
    if((num_of_dim_3D==2)and(num_of_dim_2D==3))then
        temp_3D_spectrum=input_2D_spectrum;temp_2D_spectrum=input_3D_spectrum;
        else    --if((num_of_dim_3D==2)and(num_of_dim_2D==3
        temp_3D_spectrum=input_3D_spectrum;temp_2D_spectrum=input_2D_spectrum;
    end    --if((num_of_dim_3D==2)and(num_of_dim_2D==3
    size_RA_3D=initialize_size_RA(temp_3D_spectrum);
    limit_RA=initialize_limit_RA(temp_3D_spectrum,input_limit_RA,size_RA_3D);
    max_amplitude_2D,average_amplitude_2D=get_max_average_highest_lowest_amplitude(temp_2D_spectrum);
    if (not(input_threshold)) then temp_threshold=2.5*average_amplitude_2D else temp_threshold=input_threshold end;
    if (window_width_RA) then temp_window_width_RA=window_width_RA end;
    if (not(temp_window_width_RA[1])) then temp_window_width_RA[1]=math.floor(size_RA_3D[1]/100+0.5) end;
    print(temp_window_width_RA[1]);
    if (not(temp_window_width_RA[2])) then temp_window_width_RA[2]=math.floor(size_RA_3D[2]/100+0.5) end;
    print(temp_window_width_RA[2]);
    if (not(temp_window_width_RA[3])) then temp_window_width_RA[3]=math.floor(size_RA_3D[3]/100+0.5) end;
    print(temp_window_width_RA[3]);
    ID_of_3D=temp_3D_spectrum:getId();
    ID_of_2D=temp_2D_spectrum:getId();
    --figure out dimensional equivalence
    label_RA_3D[1]=temp_3D_spectrum:getType():getLabels(1);
    label_RA_3D[2]=temp_3D_spectrum:getType():getLabels(2);
    label_RA_3D[3]=temp_3D_spectrum:getType():getLabels(3);
    label_RA_2D[1]=temp_2D_spectrum:getType():getLabels(1);
    label_RA_2D[2]=temp_2D_spectrum:getType():getLabels(2);
    for x,label_3D in label_RA_3D do   --this loop uses dimension labels to determine which dimensions in 2D and 3D are equivalent.
        dimension_map_RA_3_2[x]=0;
        for y,label_2D in label_RA_2D do
            if(length_of(label_3D)==1)then
                if(label_3D[1]==label_2D[1])then dimension_map_RA_3_2[x]=y;dimension_map_RA_2_3[y]=x; end;
            end    --if(length_of(label_3D)==1
        end    --for y,label_2D in label_RA_2D
    end    --for x,label_3D in label_RA_3D
    --for x,y in pairs(dimension_map_RA_3_2)do print(x.."    "..y) end;
    for x,y in pairs(dimension_map_RA_3_2)do if(y==0)then xpeak_dim=x end end;
    local lower_limit=limit_RA[xpeak_dim].lower;
    local upper_limit=limit_RA[xpeak_dim].upper;
    --print(xpeak_dim);
    --get all spin systems
    spin_system_RA=project:getSystems();
    for spin_sys_Id,spin_system in pairs(spin_system_RA)do
        HSQC_spin_1=nil;HSQC_spin_2=nil;
        for spin_Id,spin in pairs(spin_system:getSpins()) do
            if(spin:getLabel()==label_RA_2D[1][1])then HSQC_spin_1=spin end;
            if(spin:getLabel()==label_RA_2D[2][1])then HSQC_spin_2=spin end;
            --print(spin:getLabel().."    "..label_RA_2D[1][1]);
        end    --for spin_Id,spin in pairs(spin_system:getSpins
        if((HSQC_spin_1)and(HSQC_spin_2))then
            HSQC_dim_shift_1=HSQC_spin_1:getShift(temp_2D_spectrum);
            HSQC_dim_shift_2=HSQC_spin_2:getShift(temp_2D_spectrum);
            --print(HSQC_dim_1_shift.."    "..HSQC_dim_2_shift);
            temp_coor_RA[dimension_map_RA_2_3[1]]=temp_3D_spectrum:getIndex(dimension_map_RA_2_3[1],HSQC_dim_shift_1);
            temp_coor_RA[dimension_map_RA_2_3[2]]=temp_3D_spectrum:getIndex(dimension_map_RA_2_3[2],HSQC_dim_shift_2);
            temp_coor_RA[xpeak_dim]=nil;
            temp_1D_RA=get_1D_from_spectrum(temp_3D_spectrum,temp_coor_RA[1],temp_coor_RA[2],temp_coor_RA[3]);
            print("spin_system: "..spin_system:getId());
            for x=lower_limit,upper_limit do
                if (math.abs(temp_1D_RA[x])&gt;temp_threshold) then
                    if(is_local_max_in_1D_RA(x,temp_1D_RA,temp_window_width_RA[xpeak_dim]))then
                        if(xpeak_dim==1)then
                            local_max_signal=1;
                            temp_1D_spectrum_RA_2=get_1D_from_spectrum(temp_3D_spectrum,x,temp_coor_RA[2],nil);
                            closest_max_delta=get_local_max_delta_from_1D_RA(temp_coor_RA[3],temp_1D_spectrum_RA_2,temp_window_width_RA[3]);
                            if(not(closest_max_delta))then local_max_signal=0;
                            else if(closest_max_delta&gt;temp_window_width_RA[3]/2)then local_max_signal=0; end;
                            end    --if(not(closest_max_delta...else
                            temp_1D_spectrum_RA_2=get_1D_from_spectrum(temp_3D_spectrum,x,nil,temp_coor_RA[3]);
                            closest_max_delta=get_local_max_delta_from_1D_RA(temp_coor_RA[2],temp_1D_spectrum_RA_2,temp_window_width_RA[2]);
                            if(not(closest_max_delta))then local_max_signal=0;
                            else if(closest_max_delta&gt;temp_window_width_RA[2]/2)then local_max_signal=0 end;
                            end    --if(not(closest_max_delta...else
                        end    --if(xpeak_dim==1
                        if(xpeak_dim==2)then
                            local_max_signal=1;
                            --print("temp_window_width_RA[3]: "..temp_window_width_RA[3]);
                            temp_1D_spectrum_RA_2=get_1D_from_spectrum(temp_3D_spectrum,temp_coor_RA[1],x,nil);
                            --for temp=1,length_of(temp_1D_spectrum_RA_2)do print(temp.."  "..temp_3D_spectrum:getFreq(3,temp).." &lt;&gt; "..temp_1D_spectrum_RA_2[temp]) end;
                            --print(temp_1D_spectrum_RA_2);
                            --print("center: "..temp_coor_RA[3]);
                            closest_max_delta=get_local_max_delta_from_1D_RA(temp_coor_RA[3],temp_1D_spectrum_RA_2,temp_window_width_RA[3]);
                            --print("temp_window_width_RA[3]: "..temp_window_width_RA[3]);
                            --print("closest_max_delta: "..closest_max_delta);
                            if(not(closest_max_delta))then local_max_signal=0;
                            else if(closest_max_delta&gt;temp_window_width_RA[3]/2)then local_max_signal=0; end;
                            end    --if(not(closest_max_delta...else
                            temp_1D_spectrum_RA_2=get_1D_from_spectrum(temp_3D_spectrum,nil,x,temp_coor_RA[3]);
                            closest_max_delta=get_local_max_delta_from_1D_RA(temp_coor_RA[1],temp_1D_spectrum_RA_2,temp_window_width_RA[1]);
                            if(not(closest_max_delta))then local_max_signal=0;
                            else if(closest_max_delta&gt;temp_window_width_RA[1]/2)then local_max_signal=0 end;
                            end    --if(not(closest_max_delta...else
                        end    --if(xpeak_dim==2
                        if(xpeak_dim==3)then
                            local_max_signal=1;
                            temp_1D_spectrum_RA_2=get_1D_from_spectrum(temp_3D_spectrum,temp_coor_RA[1],nil,x);
                            closest_max_delta=get_local_max_delta_from_1D_RA(temp_coor_RA[2],temp_1D_spectrum_RA_2,temp_window_width_RA[2]);
                            if(not(closest_max_delta))then local_max_signal=0;
                            else if(closest_max_delta&gt;temp_window_width_RA[2]/2)then local_max_signal=0; end;
                            end    --if(not(closest_max_delta...else
                            temp_1D_spectrum_RA_2=get_1D_from_spectrum(temp_3D_spectrum,nil,temp_coor_RA[2],x);
                            closest_max_delta=get_local_max_delta_from_1D_RA(temp_coor_RA[1],temp_1D_spectrum_RA_2,temp_window_width_RA[1]);
                            if(not(closest_max_delta))then local_max_signal=0;
                            else if(closest_max_delta&gt;temp_window_width_RA[1]/2)then local_max_signal=0 end;
                            end    --if(not(closest_max_delta...else
                        end    --if(xpeak_dim==3
                        if(local_max_signal&gt;0)then
                            local new_spin=project:createSpin(temp_3D_spectrum:getAtomType(xpeak_dim),temp_3D_spectrum:getFreq(xpeak_dim,x));
                            project:assignSpin(new_spin,spin_system);
                            --print(x.."    "..temp_3D_spectrum:getFreq(xpeak_dim,x).."    "..string.rep("*",temp_1D_RA[x]/10000));
                        end    --if(local_max_signal&gt;0
                    end    --if(is_local_max_in_1D_RA(x,temp_1D_RA,window_width
                end    --if(math.abs(temp_1D_RA[x])&gt;temp_threshold
            end    --for x=lower_limit,upper_limit
        end    --if((HSQC_spin_1)and(HSQC_spin_2            
    end    --for spin_sys_Id,spin_system in pairs(spin_system_RA
end    --pick_spins_in_3D

-- END OF FUNCTION DEFINITIONS -----------------------------------------------------

--MAIN:-----------------------------------------------------------------------------

-- create table for temporary variables:
t = {}
--input_parameter_processing--------------------------------------------------------

-- NEW CONTROL PANEL ------------------------------------------------

-- ============Set up menu window for user preferences===================


--1. Create main menu window

v = gui.createMainWindow()
v:setCaption( "Selection Dialog for Pick_2D_Peaks" )
t.frm = gui.createGrid( v, 2, false )
v:setCentralWidget( t.frm )
v:show()
t.frm:show()

-- Define ProjectList Combobox and its Label
t.ProjectListLabel = gui.createLabel( t.frm, "Select Project" )
t.ProjectListCB = gui.createComboBox( t.frm )


--2. Read ProjectNames into ProjectList combobox

SelectedItemIndex = nil
for Id,Project in pairs( cara:getProjects() ) do
	ItemIndex = t.ProjectListCB:addItem( Project:getName() )
	t.ProjectListCB:setCurrentItem( ItemIndex )
	if Pick_2D_Peaks_ProjectName == t.ProjectListCB:getCurrentText() then
		SelectedItemIndex = ItemIndex
	end
end -- for all projects

if SelectedItemIndex then -- set to previous choice if it exists
	t.ProjectListCB:setCurrentItem( SelectedItemIndex )
end

-- Display ProjectList Combobox
t.ProjectListLabel:show()
t.ProjectListCB:show()

--3. Select Spectrum Combobox

-- Define SpectrumList Combobox and its Label
t.SpectrumListLabel = gui.createLabel( t.frm, "Select spectrum" )
t.SpectrumListCB = gui.createComboBox( t.frm )

SelectedItemIndex=nil
for SpectrumId,Spectrum in pairs( cara:getProject( t.ProjectListCB:getCurrentText() ):getSpectra() ) do
	if Spectrum:getDimCount() == 2 then
		ItemIndex = t.SpectrumListCB:addItem( Spectrum:getName() )
		t.SpectrumListCB:setCurrentItem( ItemIndex )
		if Pick_2D_Peaks_SpectrumName == t.SpectrumListCB:getCurrentText() then
			SelectedItemIndex = ItemIndex
		end
	end -- if 2D spectrum
end -- for all spectra

if SelectedItemIndex then -- set to previous choice if it exists
	t.SpectrumListCB:setCurrentItem( SelectedItemIndex )
end

-- Display SpectrumList ComboBox
t.SpectrumListLabel:show()
t.SpectrumListCB:show()

--4. Select Threshhold cutoff

--t.ThreshholdLE:getCurrentText()

-- Create Label and LineEdit Box for Threshhold
t.ThreshholdLELabel = gui.createLabel( t.frm, "Cutoff threshhold to pick peaks: " )
t.ThreshholdLE = gui.createLineEdit( t.frm )

if Pick_2D_Peaks_Threshhold then -- determine if Threshhold already exists
	t.ThreshholdLE:setText( Pick_2D_Peaks_Threshhold )
else
	t.ThreshholdLE:setText( "70000" )
	proj = cara:getProject( t.ProjectListCB:getCurrentText() )
	spectra = proj:getSpectra()
	SelectedSpec = nil
	for SpecId,Spec in pairs( spectra ) do
		if t.SpectrumListCB:getCurrentText() == Spec:getName() then
			SelectedSpec = Spec
		end -- if spectrum is selected spectrum
	end -- for all spectra
	if SelectedSpec == nil then
		print("Trying to set Threshhold: No spectrum found")
	else
		dummy,ave_amplitude = get_max_average_highest_lowest_amplitude(SelectedSpec,1000000)
		t.ThreshholdLE:setText( ave_amplitude*10 )
	end
end
-- Display Label and LineEdit window
t.ThreshholdLELabel:show()
t.ThreshholdLE:show()

--5. Get ppm ranges for peak-picking

-- Create Label and Lineedit Box for Dim1 range
t.StartDim1RangeLELabel = gui.createLabel( t.frm, "Starting Shift (dim 1): " )
t.StartDim1RangeLE = gui.createLineEdit( t.frm )
t.EndDim1RangeLELabel = gui.createLabel( t.frm, " Ending Shift (dim 1): " )
t.EndDim1RangeLE = gui.createLineEdit( t.frm )

if Pick_2D_Peaks_StartDim1Range then -- determine if StartRes already exists
	t.StartDim1RangeLE:setText( Pick_2D_Peaks_StartDim1Range )
	t.EndDim1RangeLE:setText( Pick_2D_Peaks_EndDim1Range )
else
	t.StartDim1RangeLE:setText( "5.5" ) -- default value
	if SelectedSpec == nil then
		print("PpmRanges: No spectrum found")
	else
		StartRange,EndRange = SelectedSpec:getPpmRange( 1 )
		t.StartDim1RangeLE:setText( StartRange )
		t.EndDim1RangeLE:setText( EndRange )	
	end -- if Spectrum found
end

-- Display Label and LineEdit windows
t.StartDim1RangeLELabel:show()
t.StartDim1RangeLE:show()
-- Display Label and LineEdit windows
t.EndDim1RangeLELabel:show()
t.EndDim1RangeLE:show()

-- Create Label and Lineedit Box for Dim1 range
t.StartDim2RangeLELabel = gui.createLabel( t.frm, "Starting Shift (dim 2): " )
t.StartDim2RangeLE = gui.createLineEdit( t.frm )
t.EndDim2RangeLELabel = gui.createLabel( t.frm, " Ending Shift (dim 2): " )
t.EndDim2RangeLE = gui.createLineEdit( t.frm )

if Pick_2D_Peaks_StartDim2Range then -- determine if StartRes already exists
	t.StartDim2RangeLE:setText( Pick_2D_Peaks_StartDim2Range )
	t.EndDim2RangeLE:setText( Pick_2D_Peaks_EndDim2Range )
else
	t.StartDim2RangeLE:setText( "108" ) -- default value
	if SelectedSpec == nil then
		print("PpmRange D2: No spectrum found" )
	else
		StartRange,EndRange = SelectedSpec:getPpmRange( 2 )
		t.StartDim2RangeLE:setText( StartRange )
		t.EndDim2RangeLE:setText( EndRange )
	end -- if spectrum found
end

-- Display Label and LineEdit windows
t.StartDim2RangeLELabel:show()
t.StartDim2RangeLE:show()
-- Display Label and LineEdit windows
t.EndDim2RangeLELabel:show()
t.EndDim2RangeLE:show()



-- END OF NEW CONTROL PANEL -----------------------------------------

--. OK and Cancel Buttons

t.okbutton = gui.createPushButton(t.frm, "OK" )
t.cancelbutton = gui.createPushButton( t.frm, "Cancel" )

t.okbutton:show()
t.cancelbutton:show()

-- ============Callbacks for menu window ===================

-- Define Callbacks for the buttons


-- cancel button Callback
t.cancelbutton:setCallback( gui.event.Clicked,
	function (self)
		v:close()
	end
)

-- OK button Callback
t.okbutton:setCallback( gui.event.Clicked,
	function (self)
-- =============== Determine User Preferences ===========================
		t.P = cara:getProject( t.ProjectListCB:getCurrentText() )
		Pick_2D_Peaks_ProjectName = t.P:getName()
		Pick_2D_Peaks_SpectrumName = t.SpectrumListCB:getCurrentText()
		Pick_2D_Peaks_Threshhold = t.ThreshholdLE:getText() + 0
		Pick_2D_Peaks_StartDim1Range = t.StartDim1RangeLE:getText() + 0
		Pick_2D_Peaks_EndDim1Range = t.EndDim1RangeLE:getText() + 0
		Pick_2D_Peaks_StartDim2Range = t.StartDim2RangeLE:getText() + 0
		Pick_2D_Peaks_EndDim2Range = t.EndDim2RangeLE:getText() + 0
		
		dimension_1_lower_ppm_limit_1 = Pick_2D_Peaks_StartDim1Range;
		dimension_1_upper_ppm_limit_1 = Pick_2D_Peaks_EndDim1Range;
		dimension_2_lower_ppm_limit_1 = Pick_2D_Peaks_StartDim2Range;
		dimension_2_upper_ppm_limit_1 = Pick_2D_Peaks_EndDim2Range;
		threshold_1 = Pick_2D_Peaks_Threshhold

-- get SpectrumId from the selected SpectrumName
		for SpectrumId,Spectrum in pairs( t.P:getSpectra() ) do
			if Spectrum:getName() == Pick_2D_Peaks_SpectrumName then
				spectrum_1_ID = SpectrumId
			end
		end
-- error if SpectrumId is nil
if spectrum_1_ID == nil then
	error( " No valid spectrum selected. ")
end

upper=2;
lower=1;
spectrum_1=t.P:getSpectrum(spectrum_1_ID); 
num_of_dim_1=spectrum_1:getDimCount();
size_RA_1=initialize_size_RA(spectrum_1);
limit_RA_1=initialize_limit_RA(spectrum_1,nil,size_RA_1);

--spectrum_2=t.P:getSpectrum(spectrum_2_ID); 


dimension_1_lower_point_limit_1=spectrum_1:getIndex(1,dimension_1_lower_ppm_limit_1);
dimension_1_upper_point_limit_1=spectrum_1:getIndex(1,dimension_1_upper_ppm_limit_1);
if(dimension_1_upper_point_limit_1&lt;dimension_1_lower_point_limit_1)then local temp=dimension_1_upper_point_limit_1;dimension_1_upper_point_limit_1=dimension_1_lower_point_limit_1;dimension_1_lower_point_limit_1=temp; end;
limit_RA_1[1].lower=dimension_1_lower_point_limit_1;limit_RA_1[1].upper=dimension_1_upper_point_limit_1;
--print(dimension_1_lower_point_limit_1.."    "..dimension_1_upper_point_limit_1);
dimension_2_lower_point_limit_1=spectrum_1:getIndex(2,dimension_2_lower_ppm_limit_1);
dimension_2_upper_point_limit_1=spectrum_1:getIndex(2,dimension_2_upper_ppm_limit_1);
if(dimension_2_upper_point_limit_1&lt;dimension_2_lower_point_limit_1)then local temp=dimension_2_upper_point_limit_1;dimension_2_upper_point_limit_1=dimension_2_lower_point_limit_1;dimension_2_lower_point_limit_1=temp; end;
limit_RA_1[2].lower=dimension_2_lower_point_limit_1;limit_RA_1[2].upper=dimension_2_upper_point_limit_1;
--print(dimension_2_lower_point_limit_1.."    "..dimension_2_upper_point_limit_1);




-----------------------------------------------------------------------------------
print_information_about_spectrum(spectrum_1);
--print_information_about_spectrum(spectrum_2);
if(print_spectral_information_only==0)then


--print("number_of_dimensions: "..spectrum:getDimCount());
--local temp_spectrum_RA={};
--temp_spectrum_RA=get_1D_from_spectrum(cara:getProject():getSpectrum(13),nil,23);
--for x=1,length_of(temp_spectrum_RA)do print("x: "..x.."    "..temp_spectrum_RA[x]) end;
--closest_max_delta=get_local_max_delta_from_1D_RA(470,temp_spectrum_RA,40);
--print("closest_max_delta: "..closest_max_delta);
--local temp_peak_shape_RA={};
--temp_peak_shape_RA=get_peak_shape_from_1D_RA(temp_spectrum_RA,40);
--for x,y in pairs(temp_peak_shape_RA)do print("x: "..x.."    temp_peak_shape_RA[x]: "..y) end;

--local window_width_RA={40,40}
--local limit_RA={};
--peak_shape_RA=get_peak_shape_from_ND(spectrum,window_width_RA,0);
--for x,y in pairs(peak_shape_RA[1])do print("x: "..x.."    peak_shape_RA[1][x]: "..y) end;
--d1_peak_shape_RA=scale_RA(peak_shape_RA[1],1);
--for x,y in pairs(d1_peak_shape_RA)do print("x: "..x.."    d1_peak_shape_RA: "..d1_peak_shape_RA[x]) end;

--local peak_RA={};
--max_amplitude=get_max_average_highest_lowest_amplitude(spectrum);
--print("max_amplitude: "..max_amplitude);
--print("&gt;1");for x=1,length_of(temp_spectrum_RA) do print("temp_spectrum_RA: "..x.."    "..temp_spectrum_RA[x]) end;
--peak_RA=grow_peaks_into_1D_RA(temp_spectrum_RA,d1_peak_shape_RA,100,900);
--print("&gt;2");for x=1,length_of(temp_spectrum_RA) do print("temp_spectrum_RA: "..temp_spectrum_RA[x]) end;
--print("&gt;3");for x=1,length_of(peak_RA) do print("peak_RA: "..x.."    "..peak_RA[x]) end;
--identify_peaks_in_ND_spectrum(spectrum,peak_shape_RA);
--function pick_spin_systems_in_HSQC(project,spectrum,peak_shape_RA,threshold,input_limit_RA,mode,point_window_RA)
pick_spin_systems_in_HSQC(t.P,spectrum_1,peak_shape_RA_1,threshold_1,limit_RA_1,peak_picking_mode_1,point_window_RA_1);

--print("testing transfer");
--local temp_position_RA={};
--temp_position_RA[1]=nil;
--temp_position_RA[2]=512;
--local temp_1D_spectrum_RA={};
--temp_1D_spectrum_RA=get_1D_from_spectrum(spectrum,nil,23);--local temp_2D_spectrum_RA={};
--transfer_1D_RA_to_ND_RA(temp_1D_spectrum_RA,temp_2D_spectrum_RA,2,temp_position_RA,10000);
--for x=1,1024 do for y=1,1024 do if(temp_2D_spectrum_RA[x])then if(temp_2D_spectrum_RA[x][y])then print("x: "..x.."    y: "..y.."    "..temp_2D_spectrum_RA[x][y]) end;end;end;end;

--pick_spins_in_3D(project,spectrum_2,spectrum_1,threshold_2);

end    --if(print_spectral_information_only==0

v:close() -- close dialog window and execute peak-picking
end
) -- close Callback OK

t.ProjectListCB:setCallback( gui.event.Activated,
	function (self)
		t.SpectrumListCB:clear()
		SelectedItemIndex = nil
		Proj = cara:getProject( t.ProjectListCB:getCurrentText() )
		if Proj then
			Pick_2D_Peaks_ProjectName = Proj:getName()
			for SpectrumID,Spectrum in pairs( Proj:getSpectra() ) do
				if Spectrum:getDimCount() == 2 then
					ItemIndex = t.SpectrumListCB:addItem( Spectrum:getName() )
					t.SpectrumListCB:setCurrentItem( ItemIndex )
				end -- if 2D spectrum
			end -- for all spectra in project
		else
			print("Callback ProjectList: No projects found")
		end -- if project exists
		t.SpectrumListLabel:show()
		t.SpectrumListCB:show()
	end -- function self
) -- close Callback ProjectListCB

t.SpectrumListCB:setCallback( gui.event.Activated,
	function (self)
--[[		t.StartDim1RangeLE:clear()
		t.EndDim1RangeLE:clear()
		t.StartDim2RangeLE:clear()
		t.EndDim2RangeLE:clear()
]]
		SelectedSpec = nil
		Proj = cara:getProject( t.ProjectListCB:getCurrentText() )
		if Proj then
			SpecName = t.SpectrumListCB:getCurrentText()
			if SpecName then
				for SpecId,Spec in pairs( Proj:getSpectra() ) do
					if Spec:getName() == SpecName then
						SelectedSpec = Spec
					end -- spectrum name matches selected spectrum name
				end -- all Spectra in Project
			end -- if SpecName selected
		end -- if Proj selected
		if SelectedSpec then
			print("Arrived at Callback SpectrumList: changing ppm ranges")
			-- store new spectrum name
			Pick_2D_Peaks_SpectrumName = t.SpectrumListCB:getCurrentText()
			dummy,ave_amplitude = get_max_average_highest_lowest_amplitude(SelectedSpec,1000000)
			t.ThreshholdLE:setText( ave_amplitude*10 )

			Pick_2D_Peaks_Threshhold = 100000
			-- get PPM ranges of selected Spectrum
			StartRange,EndRange = SelectedSpec:getPpmRange( 1 )
			t.StartDim1RangeLE:setText( StartRange )
			t.EndDim1RangeLE:setText( EndRange )
			
			StartRange,EndRange = SelectedSpec:getPpmRange( 2 )
			t.StartDim2RangeLE:setText( StartRange )
			t.EndDim2RangeLE:setText( EndRange )
			
			Pick_2D_Peaks_StartDim1Range = t.StartDim1RangeLE:getText() + 0
			Pick_2D_Peaks_EndDim1Range = t.EndDim1RangeLE:getText() + 0
			Pick_2D_Peaks_StartDim2Range = t.StartDim2RangeLE:getText() + 0
			Pick_2D_Peaks_EndDim2Range = t.EndDim2RangeLE:getText() + 0
			
			dimension_1_lower_ppm_limit_1 = Pick_2D_Peaks_StartDim1Range;
			dimension_1_upper_ppm_limit_1 = Pick_2D_Peaks_EndDim1Range;
			dimension_2_lower_ppm_limit_1 = Pick_2D_Peaks_StartDim2Range;
			dimension_2_upper_ppm_limit_1 = Pick_2D_Peaks_EndDim2Range;
		end
	end -- function self
) -- close Callback SpectrumListCB

</code>
<fld name='Author' type='String'>James E. Masse</fld>
<fld name='Creation Date' type='Date'>2005-4-1</fld>
<fld name='Description' type='Memo'>A 2D automated peak-picker (actually it picks systems in an HSQC15N). All systems are assumed to be HN/N anchors.

User must adjust Threshold intensity to an appropriate value to avoid a huge list. Check intensities of a few peaks with MonoScope before running the script.

version 0.
written by James E. Masse.

version 1.
modified by F.Damberger to introduce a user dialog.</fld>
</script>
<script name='ReplaceDegenerateSpinsByGroup'>
<code lang='Lua'>-- script to replace degenerate spins by their pseudoatom
-- e.g. HB2 3.20 and HB3 3.20 are replaced by HB 3.20
-- e.g. PHE HD1 6.65 and HD2 6.65 are replaced by HD 6.65

-- This is necessary after creating a project from a BMRB *.str file.
-- BMRB reports two entries for degenerate shifts. These are
-- treated with a single pseudoatom in CARA.

-- Note: the script requires that there are no SpinLinks in the project.
-- It would be quite a bit more complex to transfer the SpinLinks from
-- all the Spins in a Group to the Pseudoatom Spin - so I opted to
-- exclude this possibility. 

-- F.Damberger Feb.23.2005

-- -----------------------------------------------------------------------------


-- Function GroupAssignedAndDegenerate --------------------------------------------------------------------------------------
function GroupAssignedAndDegenerate( Group, System, Project )
	Atoms = Group:getAtoms()
	Result = false -- assume condition is not fulfilled
	AllShiftsAssigned = true -- assume all are assigned and then try to disprove
	Shifts = {}
	SpinsInGroup = {}
	i = 0
	for AtomLabel,Atom in pairs( Atoms ) do
		local Match = false
		for SpinId,Spin in pairs( System:getSpins() ) do
			if Atom:getName() == Spin:getLabel() then
				Match = true
				i = i + 1
				Shifts[ i ] = Spin:getShift() --collect the shifts of spins in group
				SpinsInGroup[ i ] = Spin -- collect the spins in group
			end
		end -- for System loop : search for Spin with match
		if not Match then AllShiftsAssigned = false end
	end --for Atoms loop : search all Atoms in Group to see if all assigned
	-- check whether shifts are all identical
	ShiftsDegenerate = true
	for ShiftId,Shift in pairs( Shifts ) do
		if ShiftId == 1 then
			ShiftOfFirst = Shift
		else -- not first Shift, so compare
			if Shift ~= ShiftOfFirst then
				ShiftsDegenerate = false
			end
		end -- if FirstShift in Table
	end -- for all Shifts in Table
	if i &gt; 1 and AllShiftsAssigned and ShiftsDegenerate then
		-- Remove degenerate spins	
		print( "Degenerate spins found: ")
		for SpinId,SpinInGroup in pairs( SpinsInGroup ) do
			if SpinId == 1 then
				print("Keeping spin: "..SpinInGroup:getLabel().." "..string.format( "%5.2f", Shifts[ SpinId ] ) )
			else -- not first spin in group, so remove it
				print("Erase spin: "..SpinInGroup:getLabel().." "..string.format( "%5.2f", Shifts[ SpinId ] ) )
				Project:unassignSpin( SpinInGroup )
				Project:removeSpin( SpinInGroup )
				-- I here assume that No spins are linked! Otherwise this will fail
			end
		end
		print( "Renaming Spin "..SpinsInGroup[ 1 ]:getLabel().." to "..Group:getName() )
		Project:setLabel( SpinsInGroup[ 1 ], Group:getName() )
		Result = true
	end
	return Result
end -- Function GroupAssignedAndDegenerate

-- Function GetGroups --------------------------------------------------------------------
function GetGroups( Atoms )
	Groups = {}
	i = 0
	for AtomLabel,Atom in pairs( Atoms ) do
		Group = Atom:getGroup()
		NewGroup = true
		if Group then
			for GroupId,GroupInGroups in pairs( Groups ) do
				if Group:getName() == GroupInGroups:getName() then
					NewGroup = false
				end
			end
			if NewGroup then
				i = i + 1
				Groups[ i ] = Group
			end
		end -- if Group
	end -- for all Atoms in Res
	if i &gt; 0 then
		return i,Groups
	else
		return i
	end
end -- function GetGroups --------------------------------------------------------------

-- Function LinksExist
function LinksExist( Project )	
	NumLinks = table.getn( Project:getSpinLinks() )
	if NumLinks &gt; 0 then
		return true
	else
		return false
	end
end

-- MAIN BODY of Script -----------------------------------------------------------------

--1. Get ProjectName
local ProjectNames = {}
i = 0
for a,b in pairs(cara:getProjects()) do
	i = i + 1
	ProjectNames[ i ] = b:getName()
end
local ProjectName = dlg.getSymbol("Select Project","", unpack( ProjectNames ) )
local Project = cara:getProject( ProjectName )

--2. Check whether links exist (if yes, then abort)
if LinksExist( Project ) then
	error( "\nERROR: Links found in project. \nThis script cannot remove spins when links are present\nReplaceDegenerateSpinsByPseudoAtom is finished." )
end

--2. Scan sequence for Groups,
--   eliminate spins with degenerate shifts,
--   reassign the shift to Group (pseudoatom)
local Seq = Project:getSequence()

NumGroupsModified = 0
for ResNum,Res in pairs( Seq ) do
	local System = Res:getSystem()
	local Type = Res:getType()
	local Atoms = Type:getAtoms()
	if System then
		NumGroups,Groups = GetGroups( Atoms )
		if NumGroups &gt; 0 then
			for GroupId,Group in pairs ( Groups ) do
				if GroupAssignedAndDegenerate( Group, System, Project ) then
					-- remove the degenerate spins and assign the first spin to group (pseudoatom)
					print( "Degenerate spins removed for "..Type:getShort().." "..ResNum.." ".."Group:"..Group:getName() )
					print( "--------------------------------------------------------------------" )
					NumGroupsModified = NumGroupsModified + 1
				end
			end -- for all Groups
		end --if Groups exist
	end -- if System exists
end -- for all Residues

--3. Summarize Results: -----------------------------------------------------------------------------

print( " SUMMARY: consolidated a total of "..NumGroupsModified.." Groups." )

print( "ReplaceDegenerateSpinsByPseudoAtom is finished")
</code>
<fld name='Author' type='String'>Fred Damberger</fld>
<fld name='Creation Date' type='Date'>2005-4-1</fld>
<fld name='Description' type='Memo'>This script replaces all degenerate spin pairs by a single group (pseudoatom) shift. Apply this to projects generated with "Project-Import Projects from Bmrb" to eliminate degenerate atoms like
HE1 7.05
HE2 7.05
and replace them by the group shift HE 7.05.</fld>
</script>
<script name='ShiftSpinsAndAliases'>
<code lang='Lua'>-- Script to shift the ppm of selected spins and their aliases by a fixed amount
-- F. Damberger 22. Feb.2005

-- WARNING: always back-up your repository before executing script!
-- Undo by repeating the script with oppposite sign for Delta

-- Below are the User defineable variables. READ points 4 &amp; 5 carefully!
-- resetting default values next

-- Do not change the following 3 lines!! They reset options so that your flags work
ShiftAliases = nil
Filter = nil
SelectedResidueType = nil
ReportOnly = nil

-- **********************************************************************************************
-- ***********  USER OPTIONS, you can edit items below to change selected spins ************
-- -------------------------------------------------------------------------------------------
-- 0. Report what will be done without doing it (comment out, to really change shifts in project)
		ReportOnly = true

-- 1. The Project you want to modify shifts in:
         ProjectName = "MyProjectsName"

-- 2. Atom Type of spins whose shifts are changed:
         AtomType = "C"

-- 3. Amount to shift the ppm value of spin: newPpm = oldPpm + Shift
         Delta = 2.448

-- 4. Label of spins whose shifts are (NOT) changed:
         Label = "CG"

-- 5. Filter for INCLUDE or EXCEPT
--      If the NOT is defined, only spins which do NOT have the label are shifted.
--      If the NOT definition is commented out, only spins which DO have the label are shifted.
--        Filter = "NOT"

-- 6. Flag to shift alias positions or not
--		If the flag ShiftAliases is defined, then alias positions for shifts are shifted also
		-- ShiftAliases = true
		
-- 7. Filter to select only a certain residue type (active if commented in)
		SelectedResidueTypes = {"MET"}
-- ---------------------------------------------------------------------------------------------
-- ******* END OF USER OPTIONS, don't edit below unless you know what you are doing :-) *********
-- **********************************************************************************************

-- function definitions

function GetSpinsSystemTypeName( Spin )
	Sys = Spin:getSystem()
	if not Sys then return nil end
	Res = Sys:getResidue()
	if not Res then
		SystemType = Sys:getSystemType()
		if SystemType then
			Name=SystemType:getName()
		else
			return nil
		end
	else -- Sys is assigned to Res, get Type from Residue
		ResidueType = Res:getType()
		Name = ResidueType:getShort()
	end -- if not Res
	if not Name then return nil end
	return Name
end -- function GetSpinsSystemTypeName

function NameOfSpin( Spin )
	Sys = Spin:getSystem()
	if Sys then -- Spin belongs to system
		Res = Sys:getResidue()
		if Res then -- Spin belongs to residue
			Typ = Res:getType()
			Name = Typ:getShort().." "..Res:getId().." "..Spin:getLabel()
		else -- spin is in unassigned system
			Name = "SystemId: "..Sys:getId().." SpinId "..Spin:getId()
		end
	else -- spin is orphaned
		Name = "orphaned spin SpinId: "..Spin:getId()
	end
	return Name
end -- function NameOfSpin

function ShiftSpin( Spin )
	Project:setShift( Spin, Spin:getShift() + Delta )
	if ShiftAliases then
		Shifts = Spin:getShifts()
		for SpecId,Shift in pairs( Shifts ) do -- check all spectra for alias
			Spectrum = Project:getSpectrum( SpecId )
			Project:setShift( Spin, Spin:getShift( Spectrum ) + Delta, Spectrum ) -- then shift it
		end -- for all Shift aliases
	end --- if ShiftAliases
end -- function ShiftSpin


-- ======= END function definitions ======



-- Set the header text depending on whether ReportOnly is defined
if ReportOnly then
	Header = "Will change"
else
	Header = "Changing"
end


-- get Project

if cara:getProject( ProjectName ) then
	Project = cara:getProject( ProjectName )
else
	error( "\nERROR: You must edit the header of the script\n to define a valid ProjectName." )
end
-- get Spins into table
SpinsTable = Project:getSpins()

-- go through all spins in table and shift by amount Delta if they are incl. by filter

Spectra = Project:getSpectra()

local i = 0
for SpinId,Spin in pairs( SpinsTable ) do
	ResidueTypeMatches = false
	if SelectedResidueTypes then -- check if spin is in a residue that	matches a selected residue type
		for Id,ResTyp in pairs( SelectedResidueTypes ) do
			if GetSpinsSystemTypeName( Spin ) == ResTyp then ResidueTypeMatches = true end
		end -- for all selected residuetypes
	else
		ResidueTypeMatches = true -- if not defined, then it always matches (filter is not active)
	end
	if Spin:getAtomType() == AtomType then
	-- Atom type matches
		if Filter == "NOT" then
			-- use NOT filter
			if not ( Spin:getLabel() == Label ) and ResidueTypeMatches then
				-- shift the spin
				if not ReportOnly then
					ShiftSpin( Spin )
				end
				i = i + 1 -- keep count of spins shifted
				print( Header.." "..NameOfSpin( Spin ) )
			end -- label match
		else
			-- use filter without NOT
			if ( Spin:getLabel() == Label ) and ResidueTypeMatches then
				-- shift the spin
				if not ReportOnly then
					ShiftSpin( Spin )
				end
				i = i + 1 -- keep count of spins shifted
				print( Header.." "..NameOfSpin( Spin ) )				
			end -- if label matches
		end -- if Filter == "NOT"
	end -- if AtomType matches
end -- for all spins

print( Header.." the position of "..i.." spins." )
if ReportOnly then
	print("You must comment out the ReportOnly option in the header of the script to really shift the spins!")
end
print( "ShiftSpinsAndAliases.lua is done" )
</code>
<fld name='Author' type='String'>Fred Damberger</fld>
<fld name='Creation Date' type='Date'>2005-4-1</fld>
<fld name='Description' type='Memo'>Shifts a user-selected group of spins by a fixed amount in ppm. E.g. all CA shifts by + 2ppm. 

Instructions:
You must edit the script directly to set it up. (Its easy: just enter the ProjectName, the AtomType of the spins, the Label of spins to shift, and the size of the shift Delta. If you want to shift all spins EXCEPT spins with a specific label, comment in the Filter = "NOT" line.

e.g. To shift only CA by +2 ppm:
AtomType = "C"
Delta = 2.0
Label = "CA"
-- Filter = "NOT"

e.g. To shift all 1H spins by +0.05:
AtomType = "H"
Delta = 0.05
Label = "XXX" -- this label never used in project
-- Filter = "NOT"

e.g. To shift all 1H spins except HA by -0.03 ppm:
AtomType = "H"
Delta = -0.03
Label = "HA"
Filter = "NOT"
</fld>
</script>
<script name='XeasySeqToThreeLetter'>
<code lang='Lua'>-- Description: Converts an Xeasy peaklist file which uses the extended residue
-- code from the DYANA library to the standard three letter code used by
-- IUPAC, BMRB, and PDB and the CARA template Start1.2.cara
-- i.e. it removes the + and - and CYSS 
--(more of a demo script since this can easily be done in an editor with search/replace functions)

-- 2.Mar.2005 F. Damberger

-- FUNCTIONS DEFINITIONS

function GetFirstThreeLetters( String )
-- get first three letters
	StartChar,EndChar,FirstThreeLetters = string.find( String, "(%u%u%u)" )
	if FirstThreeLetters then -- return first three uppercase letters or nil
		return FirstThreeLetters
	else
		return nil
	end
end -- function GetFirstThreeLetters

function IsComment( Line )
-- get first character
	StartChar,EndChar,FirstLetter = string.find( Line, "(%S)" )
	if StartChar and FirstLetter == "#" then
		return true
	else
		return false
	end
end -- function IsComment


function GetResLine( Line )
	local StartChar
	local EndChar
	local ResName
	local ResNum
	local SysNum
	local Comment

	function IsResName( ResName )
		Result = false
		for Id,NameFromList in pairs( ResList ) do
			if NameFromList == ResName then
				Result = true
			end
		end
		return Result
	end -- function IsResName

	StartChar,EndChar,ResName = string.find( Line, "(%S+)" )
	if IsResName( ResName ) then -- found ResName
		StartChar,EndChar,ResNum = string.find( Line, "%S+%s+(%d+)" )
		if StartChar then -- found ResNum
			StartChar,EndChar,SysNum = string.find( Line, "%S+%s+%d+%s+(%d+)" )
			if StartChar then -- found SysNum
				StartChar,EndChar,Comment = string.find( Line, "%S+%s+%d+%s+%d+%s+(\".+\")" )
				if StartChar then
				end
			end
		end
	return ResName,ResNum,SysNum,Comment
	end -- parsing of Line	
	
	if IsResName( ResName ) then -- Residue Exists
		if not ResNum and not SysNum then
			return true -- ResName only format
		elseif ResNum and not SysNum then
			return true -- ResName ResNum format
		elseif ResNum and SysNum then
			return true -- ResName ResNum SysNum format
		else
			return false -- does not match a format
		end
	end
end -- function IsResLine

function GetSSLine( Line )
	StartChar,EndChar,ResName,SysNum = string.find( Line, "SS%s+(%d+)" )
	if StartChar then
		return Line
	else
		return false
	end
end -- IsSSLine

function SubstituteThreeLetterCode( ResName, ResNum, SysNum, Comment )
	ResName = GetFirstThreeLetters( ResName )
	Line = ResName
	if ResNum then Line = Line.." "..ResNum end
	if SysNum then Line = Line.." "..SysNum end
	if Comment then Line = Line.." "..Comment end
	return Line
end -- SubstituteThreeLetterCode

function ReportBadLine( Line, NumLine )
	print( "Bad syntax at Line "..NumLine.." : "..Line )
end

function WriteLine( Line, OutFile, FirstLine )
	print( Line )
	if FirstLine then
		OutFile:write( Line )
	else
		OutFile:write( "\n"..Line )
	end
end --function WriteLine

function GetLine( File )
	Line = File:read()
	if Line then
		return false,Line
	else
		return true -- EOF reached
	end
end

-- MAIN BODY of Script ---------------------------------------------------------

-- Define ResidueList:
ResList = { "ALA", "ASP-", "CYS", "CYSS", "ASP", "ASP-", "GLU", "GLU-", "PHE",
            "GLY", "HIS", "HIST", "HIS+", "ILE", "LEU", "LYS", "LYS+", "MET", "ASN",
			"PRO", "GLN", "ARG", "ARG+", "SER", "THR", "VAL", "TRP", "TYR" }

-- All lines below are Xeasy seq file format:
--Line = "# this is a comment"
--Line = "ARG+ 17 22"
--Line = "SS 123"
--Line = "ARG+ 17 22 \"-1: 203\""
--Line = "SER  1   1"
--Line = "LYS+"

-- 1. Get Sequence input file: -------------------------------------------------------
local SequenceInputFileLocation = dlg.getOpenFileName( "Select the Sequence input file : Script will write a new seq file compatible with Start1.2.cara.", "*.seq" )
SeqInputFile = io.open( SequenceInputFileLocation )

--2. Get Converted Sequence output filename: -----------------------------------
SequenceOutputFileName = dlg.getText( "Enter output filename for sequence converted to format compatible with Start1.2.cara.", "output filename","Sequence_Start12.seq" )

NumComment = 0
NumResLine = 0
NumSSLine = 0
NumBadLine = 0
NumLine = 0
Eof = false

OutFile = io.output( SequenceOutputFileName )
while not Eof do

	Eof,Line = GetLine( SeqInputFile )
	if not Eof then
		NumLine = NumLine + 1
		if NumLine == 1 then
			FirstLine = true
		else
			FirstLine = false
		end
		if IsComment( Line ) then
			WriteLine( Line, OutFile )
			NumComment = NumComment + 1
		elseif GetResLine( Line, ResList ) then
			WriteLine( SubstituteThreeLetterCode( GetResLine( Line ) ), OutFile, FirstLine )
			NumResLine = NumResLine + 1
		elseif GetSSLine( Line ) then
			WriteLine( Line, OutFile )
			NumSSLine = NumSSLine + 1
		else
			ReportBadLine( Line, NumLine )
			NumBadLine = NumBadLine + 1
		end
	end -- if not Eof
end -- while not EOF
 
 SeqInputFile:close()
 OutFile:close()
 

print(" comment-only lines found: "..NumComment )
print(" Residue lines written     : "..NumResLine )
print(" SS lines written          : "..NumSSLine )
print(" Number of lines with bad format : "..NumBadLine )


print( "XeasySeqToThreeLetter.lua is finished" )
</code>
<fld name='Creation Date' type='Date'>2005-4-8</fld>
</script>
<script name='XeasyToBmrBLabelsInProtonList'>
<code lang='Lua'>-- replaces the names of atoms in a protonlist from Xeasy to Bmrb nomenclature
-- E.g. HN(Xeasy) -&gt; H(Bmrb), QB(Xeasy) -&gt; HB(Bmrb)
-- This is to allow old Xeasy projects to be imported into Cara with the new
-- Template Start1.2.cara loaded. This template uses nomenclature consistent with
-- the BMRB and PDB.

-- F.Damberger 3.March 2005

function FirstLetter( Label )
-- get first letter
	StartChar,EndChar,FirstChar = string.find( Label, "(%u)" )
	if StartChar then -- return first letter or nil
		return FirstChar
	else
		return nil
	end
end -- function FirstLetter

function SecondLetter( Label )
-- get second letter
	StartChar,EndChar,SecondChar = string.find( Label, "%u(%u)" )
	if StartChar then -- return second letter or nil
		return SecondChar
	else
		return nil
	end
end -- function SecondLetter

function ReplaceQwithH( Label )
	StartChar,EndChar,LabelMinusStartingQ = string.find( Label, "%u(%w+)" )
	return "H"..LabelMinusStartingQ
end

function ReplaceQQwithH( Label )
	StartChar,EndChar,LabelMinusStartingQQ = string.find( Label, "%u%u(%w+)" )
	return "H"..LabelMinusStartingQQ
end

-- MAIN BODY of Script -----------------------------------------------------------------

--4. Select input ProtonList and get a pointer to it ---------------------------------------

InputProtonList = spec.openProtonList( dlg.getOpenFileName( "Select Input ProtonList", "Protonlist (*.prot)" ) )

--2. Get Converted ProtonList output filename: -----------------------------------
OutputProtonListName = dlg.getText( "Enter output filename for protonlist converted to format compatible with Start1.2.cara.", "output filename","ProtonList_Start12.prot" )

OutFile = io.output( OutputProtonListName )

Error = string.format("%5.3f", 0)

for i = 1,InputProtonList:getCount() do
	SpinId,Shift,AtomLabel,ResNum = InputProtonList:getAtom( i )
	if FirstLetter( AtomLabel ) == "Q" then
		if SecondLetter( AtomLabel ) == "Q" then
			AtomLabel = ReplaceQQwithH( AtomLabel )
		else
			AtomLabel = ReplaceQwithH( AtomLabel )
		end
	end
	if AtomLabel == "HN" then AtomLabel = "H" end
	Shift = string.format("%7.3f", Shift)
	SpinId = string.format("%4d", SpinId )
	AtomLabel = string.format("%-5s", AtomLabel )
	ResNum = string.format("%3d", ResNum )
	Line =SpinId.." "..Shift.." "..Error.." "..AtomLabel.." "..ResNum
	print( Line )
	OutFile:write( Line.."\n" )
end -- for InputProtonList


OutFile:close()
print( "XeasyToBmrbLabelsInProtonList.lua is finished" )

</code>
<fld name='Author' type='String'>Fred Damberger</fld>
<fld name='Creation Date' type='Date'>2005-4-1</fld>
<fld name='Description' type='Memo'>Converts the atom labels in an Xeasy protonlist to labels compatible with Start1.2.cara (e.g. HN -&gt; H) and writes the converted list to a new file.</fld>
</script>
<script name='OneLetterFileToSeqFile'>
<code lang='Lua'>-- Description: this script converts a file containing one letter codes for
-- residues in a sequence into a standard XEASY sequence file. Useful for
-- generating sequence files from Swissprot entries.

-- Notes: it ignores CASE and all characters which are not one of the twenty
-- standard amino acid residue codes. See Table "T" for the conversion code.

-- F. Damberger 27.Feb.2005

-- FD 8.Apr.2005. modified so it does not generate an empty last line.


-- Function Definitions

function WriteResToSeqFile( Line, SeqFile, FirstLine )
	NumAAFound = 0
	FirstRes = true
	for Letter in string.gfind( Line, ("%a") ) do
		OneLetter = string.upper( Letter )
		if T[ OneLetter ] then
			NumAAFound = NumAAFound + 1
			if FirstLine and FirstRes then
				SeqFile:write( T[ OneLetter ] )
			else
				SeqFile:write( "\n"..T[ OneLetter ] )
			end
			FirstRes = false
		end
--		print( T[ OneLetter ])
--		print( T[ tostring( string.upper( Letter ) ) ].."\n" )
	end
	return NumAAFound
end

T = {}
T.A = "ALA"
T.C = "CYS"
T.D = "ASP"
T.E = "GLU"
T.F = "PHE"
T.G = "GLY"
T.H = "HIS"
T.I = "ILE"
T.K = "LYS"
T.L = "LEU"
T.M = "MET"
T.N = "ASN"
T.P = "PRO"
T.Q = "GLN"
T.R = "ARG"
T.S = "SER"
T.T = "THR"
T.V = "VAL"
T.W = "TRP"
T.Y = "TYR"


--1. Get OneLetterCode File Location
local OneLetterCodeFileLocation = dlg.getOpenFileName( "Select the one letter residue code file", "*.aa" )

local OneLetterCodeFile = io.open( OneLetterCodeFileLocation )
local NotEof = true

--2. Get SequenceFileName to write out
local SequenceFileName = dlg.getText( "Enter output sequence filename", "output filename","ConvertedSequence_cara.seq" )
--open the file to write
outfile = io.output( SequenceFileName )


--3. Read in the onelettercode and write out the three letter code

-- Read in Statistics

local NumLines = 0
local Eof = false
local NumReps = 0
NumRes = 0
while not Eof or NumReps &lt; 10000 do
	NumReps = NumReps + 1
	Line = OneLetterCodeFile:read()
	if Line then
		StartChar,EndChar,String = string.find( Line,"(%a+)" )
		if StartChar then
			NumLines = NumLines + 1
			if NumLines == 1 then
				FirstLine = true
			else
				FirstLine = false
			end
			NumRes = NumRes + WriteResToSeqFile( Line, outfile, FirstLine )
		else
			Eof = true
		end
	else
		Eof = true
	end
end

OneLetterCodeFile:close()
outfile:close()

print( "total number of lines read : "..NumLines )
print( "total number of residues : "..NumRes )
print( "OneLetterFileToSeqFile is done.")
</code>
<fld name='Author' type='String'>Fred Damberger</fld>
<fld name='Creation Date' type='Date'>2005-4-1</fld>
<fld name='Description' type='Memo'>Converts a file containing one letter code for an amino acid sequence to a seq file readable by Xeasy and Cara (Start1.2.cara).

It ignores whitespaces and any other characters which do not correspond the the one letter code. You can therefore copy-paste directly from online sources like SWISSPROT.</fld>
</script>
<script name='RenameSpins'>
<code lang='Lua'>-- F.Damberger 14.Dec.2004

-- Short description
-- renames spins with name "A" to have new name "B"

-- e.g. after creating a new project from a BMRB file, you can rename the amide protons
-- which have the label "H" in the BMRB format to have the label "HN" which is the
-- standard label for CARA template Start1.1.cara

-- WARNING:
-- The script does not check whether another spin exists with the same label as the NewLabel 

-- define temporary table for script
t = {}

-- Get Input from user

--1. Get ProjectName
local ProjectNames = {}
i = 0
for a,b in pairs(cara:getProjects()) do
	i = i + 1
	ProjectNames[ i ] = b:getName()
end
t.ProjectName=dlg.getSymbol("Select Project","", unpack( ProjectNames ) )
t.P = cara:getProject( t.ProjectName )

--2. Get OldLabel
t.OldLabel = dlg.getText("Enter Old Spin Label", "Enter Old Label","H")

--3. Get NewLabel
t.NewLabel = dlg.getText("Enter New Spin Label", "Enter New Label","HN")

-- Start to change labels

t.SpinsTable = t.P:getSpins()

local SpinsChanged = 0
local SpinsChecked = 0
for id,spin in pairs (t.SpinsTable) do
  SpinsChecked = SpinsChecked + 1
--  print("label is "..spin:getLabel() )
  if spin:getLabel() == t.OldLabel then
     t.P:setLabel(spin,t.NewLabel)
     SpinsChanged = SpinsChanged + 1
  end
end
print("checked "..SpinsChecked.." spins")
print("changed "..SpinsChanged.." spins")
print("RenameSpins is done")
t = nil
</code>
<fld name='Author' type='String'>Fred Damberger</fld>
<fld name='Creation Date' type='Date'>2005-4-1</fld>
<fld name='Description' type='Memo'>Rename all spins with label "OldLabel" with the new label "NewLabel".

e.g. rename all spins named "H" to "HN".</fld>
</script>
<script name='WriteTitrationCurveDataToFile'>
<code lang='Lua'>-- Mar. 30 2005.
-- written by F.Damberger

-- Writes out a Textfile with the chemical shifts (aliases) for selected spins in a series of spectra
-- The elements are separated by ';' for easy import in Excel / OpenOffice

-- To set up: create a peaklist for the first spectrum in the list (the peaklist can be empty)
-- Then create a batchlist for the first spectrum including all the spectra in the appropriate order
-- Store the peaklist in the repository.

-- Now execute the script 
-- You will be asked for:

--1. The Project containing the spectra (unless there is only one project)
--2. The Output filename for EXCEL table (see below)
--3. The Label of the spin whose shifts are written out (e.g. HA)
--4. The peaklist you created (unless there is only one peaklist)

-- The output in "shiftstable.txt" looks similar to:

--[[
Spin label;SpecName1;SpecName2;SpecName3
N7;  7.550;  7.680;  7.730
L8;  9.174;  9.157;  9.200
S9;  8.410;  8.430;  8.450
L10;  8.100;  8.160;  8.220
]]

-- first line gives the names of the spectra
-- following lines give the Spin Label and a list of shifts for each spectrum in the batchlist.

-- HINT: If you want the first line to give the parameter thats varied for each spectrum (e.g pH or concentration )
-- then rename your spectra to the corresponding value (spectrum 1 -&gt; 2.0, spectrum 2 -&gt; 3.2, spectrum 3 -&gt; 6.3 ...)

-- Another more elegant option is to create a new attribute for spectra (e.g. pH ) and assign the correct value to each spectrum.
--The instructions for this approach are given below:

-- I.  In the CONTROL PANEL (see below): 
--   1. Change the AttributeName definition to give the name of the appropriate attribute (e.g. AttributeName = "Conc")
--   2. Define UseAttribute = true

-- II. Next define the value of the attribute for each Spectrum:

--   1. In CARA-Explorer right-click on a spectrum and select "Edit Attribute" or "Open Object Table". You will see a table with all attributes for Spectra.
--   2. Enter the values in the appropriate field (e.g. pH value 3.4 in the field with that name)

-- Now run the script.

-- If the appropriate attribute does not exist, you can create a new attribute for spectra as follows:
--1. Click on "Attribute Definitions" in Cara-Explorer
--2. Click on Spectrum. CARA displays all defined attributes for spectra in the right window.
--3. Right-click in the right window and select "New Attribute"
--4. Enter the Name for the attribute: e.g. "Conc"
--5. Select the type for the attribute: e.g. "Float" for a floating point value like pH or Concentration


-- -------------------------------------------------------------------------------------------------------------------
-- CONTROL PANEL

UseAttribute = false -- set to true to use the attributes for spectra which must be defined for each spectrum
AttributeName = "pH" -- edit to define the name of the spectrum attribute you want to use (if UseAttribute = true)

-- ----------------------------------------------------------------
t={}

-- Get Parameters from User

-- 1. Get Project: ------------------------------------------------
local projectnames = {}
i=0
for a,b in pairs( cara:getProjects() ) do
	i = i + 1
	projectnames[ i ] = a
end

if i==1 then
	t.ProjectName = projectnames[ i ]
else
	t.ProjectName = dlg.getSymbol( "Choose project", "select one", unpack( projectnames ) )
end
if not t.ProjectName then
	error( "No project name defined")
else
	t.Project = cara:getProject( t.ProjectName )
end

-- 2. Get Output filename: -----------------------------------------
t.FileName = dlg.getText( "Enter output filename", "output filename","shiftstable.txt" )

--3. Get Label of Spin to write out chemical shifts from

t.Label = dlg.getText( "Enter label of the spins whose chemical shifts you want to write out : ", "Enter Label of spins whose shifts will be written out (e.g. HA): ")

-- 4. Get PeakList: ------------------------------------------------

local PeakListNames = {}
local PeakListIds = {}
i=0
for PeakListId,PeakList in pairs( t.Project:getPeakLists() ) do
	i=i+1
	PeakListIds[ i ] = PeakList:getId()
	PeakListNames[ i ] = PeakList:getId()..":"..PeakList:getName()
end

if i==1 then
	t.PeakListName = PeakListNames[ 1 ]
else
	t.PeakListName = dlg.getSymbol("Choose Peaklist","select one", unpack( PeakListNames ) )
end

for i=1,table.getn( PeakListNames ) do
	if t.PeakListName  == PeakListNames[ i ] then
		t.PeakListId = PeakListIds[ i ]
	end
end

-- Get PeakList and Write out Batch Table --------------------------

if t.PeakListId == nil then
	error( "No peaklist was defined" )
end
t.peaklist = t.Project:getPeakList( t.PeakListId )

t.spectra={}
t.batchlist=t.peaklist:getBatchList()
local specID,spectrum
for specID,spectrum in pairs( t.batchlist ) do
  t.spectra[ specID ]=t.Project:getSpectrum( t.batchlist[ specID ] )
end

file = io.open( t.FileName, "w" )

-- write out titles for columns ------------------------------------
  t.list="Spin label"
  for specID,spectrum in pairs( t.batchlist ) do
	if UseAttribute then
		t.list = t.list..";"..t.spectra[ specID ]:getAttr( AttributeName )
	else
		t.list = t.list..";"..t.spectra[ specID ]:getName()
	end -- if UseAttribute
  end
  t.list=t.list.."\n"

NumShifts = 0
for ResId,Res in pairs( t.Project:getSequence() ) do
	if Res:getSystem() then
		for SpinId,Spin in pairs( Res:getSystem():getSpins() ) do
			if Spin:getLabel() == t.Label then
				NumShifts = NumShifts + 1
				SpinLabel = Res:getType():getLetter()..ResId
				t.list = t.list..SpinLabel
				for Index,SpecId in pairs( t.batchlist ) do
					Spectrum = t.Project:getSpectrum( SpecId )
					Shift = string.format( "%7.3f", Spin:getShift( Spectrum ) )
					t.list = t.list..";"..string.format( "%7.3f", Spin:getShift( Spectrum ) )
					print( SpinLabel.." : "..Shift )
				end -- for all Spectra in batchlist
			t.list = t.list.."\n"
			-- file:write( t.list )
			end -- if label of spin matches the given label
		end -- for all spins in system
	end -- if residue assigned
end -- for all residues in sequence
print( "Wrote out "..NumShifts.." shifts to file "..t.FileName )
file:write( t.list )
file:flush()
file:close()

t = nil
</code>
<fld name='Author' type='String'>Fred Damberger</fld>
<fld name='Creation Date' type='Date'>2005-4-1</fld>
<fld name='Description' type='Memo'>Summary: Writes out a file appropriate for a spreadsheet to plot chemical shift titration curves.

Instructions:
(1) Set up a peaklist in the project and define a batchlist containing the series of spectra in the appropriate order (in MonoScope).  (2) Run the script.
It will ask you for the Project, the PeakList, the name of the output file, and the label of the spins that you want to write out (e.g. HA).

What it does:
Reads the alias shifts for the selected spins from each spectrum in the series and writes them out to the file. Read the header of the script for more details.</fld>
</script>
<script name='PeakListToAliases'>
<code lang='Lua'>-- Description: Opens an external peaklist and for every peak, the script creates an
-- alias shift for a selected spectrum, every time an atom number is found which matches
-- a spinnumber in the selected project.

-- This script was written as a workaround for cases where the MonoScope Menu Item
-- "Peaks-Import Alias shifts" gives the error message:
-- "Cannot import: There are 4 ambiguous shifts"
-- which occurs when atom number of the spins appear several times with different shifts
-- in the list. This prevents the aliases from being imported even when the shift
-- differences for the same shift are very small. Cara does not allow it.
-- You can use the menu item after you edit the peaklist so that every occurance of a
-- given atom has exactly the same shift. Or you can use the script...

-- This script simply ignores the inconsistency and creates a new alias for each occurance of the atom
-- so that the last shift read for a given atom/spin is taken to define the alias.

-- It is up to the user to decide that this is an acceptable method to define aliases
-- from a peaklist.

-- created 28.Dec.2004 by F.Damberger

t = {}

--1. Select Project -------------------------

local ProjectNames = {}
i = 0
for a,b in pairs(cara:getProjects()) do
	i = i + 1
	ProjectNames[ i ] = b:getName()
end
t.ProjectName=dlg.getSymbol("Select Project","", unpack( ProjectNames ) )
t.P = cara:getProject( t.ProjectName )

--2. Select Spectrum to create Aliases in ---------------------------

local SpectrumNames = {}
local SpectrumIds = {}
i = 0

for a,b in pairs(t.P:getSpectra() ) do
   i = i + 1
   SpectrumNames[ i ] = b:getName()
   SpectrumIds[ i ] = a
end

t.SpectrumName=dlg.getSymbol("Select Spectrum","", unpack( SpectrumNames ) )

for i=1,table.getn( SpectrumNames ) do
   if SpectrumNames[ i ] == t.SpectrumName then
      t.SpectrumId = SpectrumIds[ i ]
      t.Spectrum = t.P:getSpectrum( t.SpectrumId )
   end
end

if t.SpectrumId == nil then error("No spectrum selected") end

--3. Select external PeakList and get a pointer to it -------------------------------

t.pl = spec.openPeakList( dlg.getOpenFileName( "Load Peaklist",
       "Peaklist (*.peaks)" ) )

-- 4. Get the dimensionality of the peaklist

t.dim = t.pl:getDimCount()
t.peaks = t.pl:getPeaks()
t.spins = t.P:getSpins()

print("DimCount for peaklist "..t.dim)
print("Number of peaks in list "..table.getn( t.peaks ) )


--4. Scan through PeakList and create aliases ---------------------------------------

local numaliases = 0
for a,b in pairs( t.peaks ) do
    t.assign = { b:getAssig() }
    t.pos = { b:getPos() }
    for i = 1,t.dim do
       if t.assign[ i ] ~= nil then
           for spinid,spin in pairs( t.spins ) do
              if spinid == t.assign[ i ] then
                    t.P:setShift( spin, t.pos[ i ], t.Spectrum )
                    numaliase = numaliases + 1
              end
           end
       end
    end
end
print("created "..numaliases.." aliases. Some may be redundant.")
t = nil

print("PeakListToAliases is done")</code>
<fld name='Author' type='String'>Fred Damberger</fld>
<fld name='Creation Date' type='Date'>2005-4-1</fld>
<fld name='Description' type='Memo'>Reads an external peaklist and defines aliases for the spins in a selected spectrum.</fld>
</script>
<script name='CountSystems'>
<code lang='Lua'>-- Script to count spin systems in a project

-- Version 1: 2.March 2006 F. Damberger
-- modified to introduce user dialog window which remembers values

-- ----------------------------------------------------------------------
-- Create array to hold all script variables
t={}

-- User can edit parameters below to adapt to the project:
-- ----------------------------------------------------------------------
-- ======================== Define functions ============================

-- ----------------------------------------------------------------------

-- ----------------------------------------------------------------------

-- ====================== Get Selections from User ======================

--1. Set up dialog window
v = gui.createMainWindow()
v:setCaption( "RemoveSelectedSystems dialog" )
t.frm = gui.createGrid( v, 2, false )
v:setCentralWidget( t.frm )
v:show()
t.frm:show()

-- Labels for first two columns
t.ProjectListLabel = gui.createLabel( t.frm, "Select Project" )
t.ProjectListCB = gui.createComboBox( t.frm )


--2. Read ProjectNames into ProjectList combobox

SelectedItemIndex = nil
for Id,Project in pairs( cara:getProjects() ) do
	ItemIndex = t.ProjectListCB:addItem( Project:getName() )
	t.ProjectListCB:setCurrentItem( ItemIndex )
	if CountSystemsProjectName == t.ProjectListCB:getCurrentText() then
		SelectedItemIndex = ItemIndex
	end
end -- for all projects

if SelectedItemIndex then -- set to previous choice if it exists
	t.ProjectListCB:setCurrentItem( SelectedItemIndex )
end

-- Display ProjectList Combobox
t.ProjectListLabel:show()
t.ProjectListCB:show()

--3. ResidueRange 


-- Checkboxes follow ------------------------------------------


-- ----------------------------------------------------------------------

--5. Checkbox Ignore ResidueAssignments

t.IgnoreResidues_ChBxLabel = gui.createLabel( t.frm, "Ignore residue assignments (remove system numbers): " )
t.IgnoreResidues_ChBx = gui.createCheckBox( t.frm )

if CountSystemsIgnoreResidues == true then -- determine if Selection was made previously
	t.IgnoreResidues_ChBx:setChecked()
end
t.IgnoreResidues_ChBxLabel:show()
t.IgnoreResidues_ChBx:show()

--6. OK and Cancel Buttons

t.okbutton = gui.createPushButton(t.frm, "OK" )
t.cancelbutton = gui.createPushButton( t.frm, "Cancel" )

t.okbutton:show()
t.cancelbutton:show()

-- ============ Callbacks for menu window ===============================

-- Define Callbacks for the buttons


-- cancel button Callback
t.cancelbutton:setCallback( gui.event.Clicked,
	function (self)
		v:close()
	end
)

-- OK button Callback
t.okbutton:setCallback( gui.event.Clicked,
	function (self)
-- =============== Determine User Preferences ===========================
		t.P = cara:getProject( t.ProjectListCB:getCurrentText() )
		CountSystemsProjectName = t.P:getName()

-- =============== Count Residues ================================
		NumSys = 0
		NumSysWithNoCA = 0
		-- get Sequence
		t.Seq = t.P:getSequence()
			-- get Systems			
		t.Sys = t.P:getSystems()
					
		-- loop through the Systems
		for a,b in pairs( t.Sys ) do
			CA_assigned = false -- assume its not assigned
			NumSys = NumSys + 1
			t.Spins = b:getSpins()
			-- check whether CA or CA-1 are assigned
			for c,d in pairs( t.Spins ) do
				t.Label = d:getLabel()
				-- if t.Label == "C" or t.Label == "C-1" then
				if t.Label == "C" or t.Label == "?C" then
					CA_assigned = true
				end
			end -- for all spins in system
			if not CA_assigned then
				print("System with no C or C-1 found: "..a)
				NumSysWithNoCA  = NumSysWithNoCA + 1
			end
		end
		print("total number of systems: "..NumSys)
		print("number of system with missing C or C-1:"..NumSysWithNoCA)
		v:close()
	end
)


-- t = {}
</code>
<fld name='Creation Date' type='Date'>2006-3-2</fld>
</script>
<script name='CorrectAtomMagnitudes'>
<code lang='Lua'>-- CorrectAtomMagnitudes.lua
-- by F.Damberger 31.Jan.2006

-- Purpose: correct the atom magnitudes for atom labels in ResidueTypes that correspond to more than one Atom
--  e.g. HG2 of THR is a methyl resonance and corresponds to three H atoms. It should have magnitude of 3.
-- In the Start1.2.cara it mistakenly has a magnitude of 1.
-- This is mainly important for the script CalcMassOfLabeledProtein.lua

-- get ResidueTypes

function SetValue( ResidueTypeName, AtomName )
	Result = true
	ResType = cara:getResidueType( ResidueTypeName )
	if ResType then
		Atom = ResType:getAtom(AtomName)
		if Atom then
			Atom:setMagnitude( 3 )
		else
			MissingAtom = true
			print("Did not find the atom "..AtomName.." in ResidueType "..ResTypeName )
		end -- if Atom exists
	else
		MissingResidueType = true
		print(" Did not find the ResidueType "..ResidueTypeName )
	end -- if ResType exists
	return Result
end

MissingAtom = false
MissingResidueType = false
SetValue( "ALA", "HB" )
SetValue( "THR", "HG2" )
SetValue( "LYS", "HZ" )
SetValue( "MET", "HE" )
SetValue( "VAL", "HG1" )
SetValue( "VAL", "HG2" )
SetValue( "LEU", "HD1" )
SetValue( "LEU", "HD2" )
SetValue( "ILE", "HD1" )
SetValue( "ILE", "HG2" )





	if ResType:getName() == "Alanine" then
		Atom = ResType:getAtom("HB")
		
	if ResType:getName() == "Threonine" then
		Atom = ResType:getAtom( "HG2" )
		if Atom then
			Atom:setMagnitude( 3 )
		else
			NotTemplateStart12 = true
			print("Did not find the atom HG2 in ResidueType Threonine")
		end
	end
end

if MissingAtom or MissingResidueType then
	print("WARNING: this does not appear to be a Start1.2.cara template. This script looks for specific atoms and residuetypes and some of these are missing!")
end
</code>
<fld name='Creation Date' type='Date'>2006-3-16</fld>
</script>
<script name='WriteShiftsInColumns'>
<code lang='Lua'>-- WriteShiftsInColumns.lua
-- Purpose: writes shifts from different spins to separate columns in an external file

-- written by F.Damberger 11:14 April 4 2006  to 11:40
-- modified to allow export of secondary shifts or raw shifts F.Damberger 2.June 2006

function Format( Number ) -- function to format the chemical shifts
	FormattedNumber = string.format( "%3.2f", Number )
	return FormattedNumber
end

-- User editable parameters are below: ===========================

-- Spacer between elements of table to write out:
Spacer = ";"

-- Table of spin labels whose shifts should be written to a column

SpinsInColumns = {}
SpinsInColumns[ 1 ] = "H"
SpinsInColumns[ 2 ] = "HA"
SpinsInColumns[ 3 ] = "N"
SpinsInColumns[ 4 ] = "CA"
SpinsInColumns[ 5 ] = "CB"

-- End of user editable section ==================================
-- define a table of temporary script variables
t={}

-- Get Parameters from User

--0. Get Preference RawShifts or SecondaryShifts (Shift - LibraryValue)

ShiftType = dlg.getSymbol( "Raw Shift of Secondary Shifts (Shift - LibraryValue)?", "select one", "Raw Shift", "SecondaryShift" )

-- 1. Get Project: ------------------------------------------------
local projectnames = {}
i=0
for ProjName,Proj in pairs( cara:getProjects() ) do
	i = i + 1
	projectnames[ i ] = ProjName
end

if i==1 then
	t.ProjectName = projectnames[ i ]
else
	t.ProjectName = dlg.getSymbol( "Choose project", "select one", unpack( projectnames ) )
end
if not t.ProjectName then
	error( "No project name defined")
else
	t.P = cara:getProject( t.ProjectName )
end

-- 2. Get Output filename: -----------------------------------------
t.FileName = dlg.getText( "Enter output filename", "output filename",t.ProjectName.."_ShiftsTable.csv" )

--3. Get Label of Spin to write out chemical shifts from
-- I replaced this step with a table , see the top of the script
--t.Label = dlg.getText( "Enter label of the spins whose chemical shifts you want to write out : ", "Enter Label of spins whose shifts will be written out (e.g. HA): ")


-- loop through the sequence and for each residue, create a Line
-- then for each Line look for each column entry in turn
-- add it to the end of the growing line

Seq = t.P:getSequence()
j = 0
Lines = {}
for ResId,Res in pairs( Seq ) do
	Sys = Res:getSystem()
	if Sys then -- if residue is assigned
		SpinsInSys = Sys:getSpins()
		j = j + 1
		Lines[ j ] = ResId
		for k = 1,table.getn( SpinsInColumns ) do
			LabelToFind = SpinsInColumns[ k ]
			MatchingSpin = nil -- reset to none found
			for SpinId,Spin in pairs( SpinsInSys ) do -- search for a match to LabelToFind
				if Spin:getLabel() == LabelToFind then
					MatchingSpin = Spin
				end -- if Spins label matches LabelToFind
			end -- for all Spins in System (look for match to this Label)
			if MatchingSpin then
				Shift = MatchingSpin:getShift()
				if ShiftType == "SecondaryShift" then
					LibValue = MatchingSpin:getSystem():getResidue():getValue( LabelToFind )
					Shift = Shift - LibValue
				end
				FormShift = Format( Shift )
				Lines[ j ] = Lines[ j ]..Spacer..FormShift
			else
				Lines[ j ] = Lines[ j ]..Spacer -- no shift assigned, leave empty
			end
		end -- for all elements k of SpinsInColumns (try to find a shift for this label)
		--Lines[ j ] = Lines[ j ].."\n" -- next line
	end -- if System is assigned
end -- for all residues in sequence

--create string "Table" with lines

--create the first line of table
for m = 1,table.getn( SpinsInColumns ) do
	if m == 1 then
		Labels = SpinsInColumns[ 1 ]
	else
		Labels = Labels..Spacer..SpinsInColumns[ m ]
	end
end
Header = "Residue"..Spacer..Labels

for l=1,table.getn( Lines ) do
	if l==1 then
		Table = Header.."\n"..Lines[ l ]
	else
		Table = Table.."\n"..Lines[ l ]
	end
end

-- Now write out all lines to a file
file = io.open( t.FileName, "w" )
file:write( Table )
file:flush()
file:close()
print("Wrote out "..table.getn( Lines ).." lines to file "..t.FileName )
print( "script WriteShiftsInColumns is done" )
t = nil


</code>
<fld name='Creation Date' type='Date'>2006-6-2</fld>
</script>
<script name='ChemShiftDeviationsFile'>
<code lang='Lua'>-- Script to calculate chemical shift deviations from random coil
-- and write them to a text file in X,Y format

-- define table for Script variables (all script variable have names t.something)
t={}

-------------------------------------------------------------------------------
-- Get the Data from User

-- 1. Get Project:
local projectnames = {}
i=0
for a,b in pairs( cara:getProjects() ) do
	any2Dspectra=false
	for c,d in pairs( b:getSpectra() ) do
		if d:getDimCount()==2 then
			any2Dspectra=true
		end
	end
	if any2Dspectra then
	i = i + 1
	projectnames[ i ] = a
	end
end
if i==1 then
	t.ProjectName = projectnames[ i ]
else
	t.ProjectName = dlg.getSymbol("Choose project", "select one", unpack( projectnames ) )
end
t.Project=cara:getProject( t.ProjectName )

--2. Get Spin Label Name

local response_which_spins

t.Label = dlg.getText("Enter Label of Spins to determine shift deviations for","e.g. HA")
if t.Label == nil then
	print("no label selected: please enter HA or HB or CA etc...")
end

--3. Get FileName
t.filename = t.Label.."dev_"..t.ProjectName..".dat"
t.filename= dlg.getText("Enter Name of File to write out shift deviations to: default is ChemShiftDeviationsFile.txt", " Enter Filename", t.filename )
if t.filename==nil then
	t.filename="ChemShiftDeviationsFile.txt"
end

-- ----------------------------------------------------------------------------

-- define tables and initialize sum variables
t.ShiftTable={}
t.Index={}
t.Spins=t.Project:getSpins()
resmin=100000
resmax=-100000
devmin=100000
devmax=-100000
i=1

-- determine shift deviations and store in ShiftTable -------------------------

for a,b in pairs(t.Spins) do
  if b:getLabel()==t.Label and b:getSystem()~=nil then
     if b:getSystem():getResidue()~=nil then
         local resnum=b:getSystem():getResidue():getId()
         local libvalue=b:getSystem():getResidue():getValue(t.Label)
         t.Deviation=b:getShift()-libvalue
         if resnum&gt;resmax then resmax=resnum end
         if resnum&lt;resmin then resmin=resnum end
         if t.Deviation&gt;devmax then devmax=t.Deviation end
         if t.Deviation&lt;devmin then devmin=t.Deviation end
         t.ShiftTable[ resnum ]=t.Deviation
         t.Index[ i ] = resnum
        i = i + 1
    end
  end
end

-- sort the table by residue

table.sort( t.Index )

-- write out the table to text file

-- open file to write
outfile=io.output(t.filename)

for i=1,table.getn(t.Index) do
  local sysId = t.Index[ i ]
   Shift=t.ShiftTable[ sysId ]
   x = sysId
   y= Shift
   outfile:write(x.."	"..y.."\n")
end

outfile:close()
print("Wrote out file: "..t.filename)
print("ChemShiftDeviationsFile.lua is done")
</code>
<fld name='Creation Date' type='Date'>2006-6-2</fld>
</script>
<script name='Pick_3D_Peaks_withPanel2'>
<code lang='Lua'>--PickPeaks

--This script is for peak picking 3D spectra using a 2D spectra (i.e.)
--an HSQC to guide the peak picking and group peaks into CARA spin systems.
--
--Author: J.E.M.

--CONTROL_PANEL------------------------------------------------------

--2D spectrum to guide 3D peak picking:
spectrum_1_ID=4;
peak_picking_mode_1="simple";
dimension_1_lower_ppm_limit_1=5.5;
dimension_1_upper_ppm_limit_1=10.5;
dimension_2_lower_ppm_limit_1=98.5;
dimension_2_upper_ppm_limit_1=132.7;
threshold_1=70000;

--3D spectrum for peak picking:
spectrum_2_ID=6;
peak_picking_mode_2="simple";
dimension_1_lower_ppm_limit_2=5.5;
dimension_1_upper_ppm_limit_2=10.5;
dimension_2_lower_ppm_limit_2=99.0;
dimension_2_upper_ppm_limit_2=132.7;
threshold_2=50000;

print_spectral_information_only=0;


--end_of_control_panel-----------------------------------------------

function print_information_about_spectrum(spectrum)
    local num_of_dim=spectrum:getDimCount();
    local x,y,label,temp_string;
    local ppm_range_1,ppm_range_2;
    local label_RA={};
    print("\nspectrum&gt;    ID: "..spectrum:getId().."    name: "..spectrum:getName());
    for x=1,num_of_dim do
        ppm_range_1,ppm_range_2=spectrum:getPpmRange(x);
        print("    dimension: "..x.."    range: "..ppm_range_1.."&lt;--&gt;"..ppm_range_2.." (ppm)");
        label_RA=spectrum:getType():getLabels(x);
        temp_string="";for y,label in pairs(label_RA)do temp_string=temp_string.." "..label end;
        if(length_of(label_RA)==1)then print("        label:"..temp_string) else print("        labels:"..temp_string) end;
    end    --for x=1,num_of_dim
    print("\n");
end    --print_information_about_spectrum


function length_of(input_table)

    if(not(input_table))then return 0 end;
    xx=0;
    for x,y in pairs(input_table) do
        xx=xx+1
    end    --for x,y in pairs(input_table
    return xx;
end    --function length_of


function get_1D_from_spectrum(spectrum,d1,d2,d3,d4,d5)
    --test peak at d1=1H:470,d2=15N:23
    local amplitude;
    local output_1D_RA={};
    if(not(spectrum))then print("No spectrum with Id: "..input_spectrum_Id); return; end;
    local num_of_dim=spectrum:getDimCount();
    --print("num_of_dim: "..num_of_dim);
    --print("label 1: "..spectrum:getLabel(1));
    --print("label 2: "..spectrum:getLabel(2));
    local size_RA={};for x=1,num_of_dim do size_RA[x]=spectrum:getSampleCount(x) end;
    --print("size_RA[1]: "..size_RA[1].."    size_RA[2]: "..size_RA[2]);
    --print(d1);
    if((not(d1))and(num_of_dim&gt;=1))then
        for x=1,size_RA[1] do
            if(num_of_dim==5)then amplitude=spectrum:getAt(x,d2,d3,d4,d5);
            else if(num_of_dim==4)then amplitude=spectrum:getAt(x,d2,d3,d4);
            else if(num_of_dim==3)then amplitude=spectrum:getAt(x,d2,d3);
            else if(num_of_dim==2)then amplitude=spectrum:getAt(x,d2);
            else if(num_of_dim==1)then amplitude=spectrum:getAt(x);
            end;end;end;end;end    --if(num_of_dim==5
            output_1D_RA[x]=amplitude;
        end    --for x=0,size_RA[1
    end    --if((not(d1))and(num_of_dim&gt;=1
    if((not(d2))and(num_of_dim&gt;=2))then
        for x=1,size_RA[2] do
            if(num_of_dim==5)then amplitude=spectrum:getAt(d1,x,d3,d4,d5);
            else if(num_of_dim==4)then amplitude=spectrum:getAt(d1,x,d3,d4);
            else if(num_of_dim==3)then amplitude=spectrum:getAt(d1,x,d3);
            else if(num_of_dim==2)then amplitude=spectrum:getAt(d1,x);
            end;end;end;end   --if(num_of_dim==5
            output_1D_RA[x]=amplitude;
        end    --for x=0,size_RA[1
    end    --if((not(d2))and(num_of_dim&gt;=2
    if((not(d3))and(num_of_dim&gt;=3))then
        for x=1,size_RA[3] do
            if(num_of_dim==5)then amplitude=spectrum:getAt(d1,d2,x,d4,d5);
            else if(num_of_dim==4)then amplitude=spectrum:getAt(d1,d2,x,d4);
            else if(num_of_dim==3)then amplitude=spectrum:getAt(d1,d2,x);
            end;end;end    --if(num_of_dim==5
            output_1D_RA[x]=amplitude;
        end    --for x=0,size_RA[1
    end    --if((not(d3))and(num_of_dim&gt;=3
    if((not(d4))and(num_of_dim&gt;=4))then
        for x=1,size_RA[4] do
            if(num_of_dim==5)then amplitude=spectrum:getAt(d1,d2,d3,x,d5);
            else if(num_of_dim==4)then amplitude=spectrum:getAt(d1,d2,d3,x);
            end;end    --if(num_of_dim==5
            output_1D_RA[x]=amplitude;
        end    --for x=0,size_RA[1
    end    --if((not(d4))and(num_of_dim&gt;=4
    if((not(d5))and(num_of_dim&gt;=5))then
        for x=1,size_RA[5] do
            if(num_of_dim==5)then amplitude=spectrum:getAt(d1,d2,d3,d4,x);
            end    --if(num_of_dim==5
            output_1D_RA[x]=amplitude;
        end    --for x=0,size_RA[1
    end    --if((not(d5))and(num_of_dim&gt;=5
    --for x=1,length_of(output_1D_RA)do print("x: "..x.."    output_1D_RA[x]: "..output_1D_RA[x]) end;
    --for x=1,length_of(output_1D_RA)do print("x: "..x.."    "..output_1D_RA[x].."\n"..string.rep("=",output_1D_RA[x]/10000).."*") end;
    --getAt(d1,d2,d3,d4,d5)
    return output_1D_RA;

end    --function get_1D_from_spectrum


function increment_position_RA(input_position_RA)
    local position=3;
    local upper_limit=2;
    local lower_limit=1;
    local RA_length=length_of(input_position_RA)
    for row=1,RA_length do
        input_position_RA[row].position=(input_position_RA[row].position)+1;
        --if(row==RA_length)then print(input_position_RA[RA_length].position) end;
        if(input_position_RA[row].position&gt;input_position_RA[row].upper_limit)then
            input_position_RA[row].position=input_position_RA[row].lower_limit;
            if(row==RA_length)then return true end;
        else break;
        end    --if(input_position_RA[row].position&gt;input_pos
    end    --for row=1,RA_length
    return false;
end    --increment_position_RA


function initialize_size_RA(spectrum)
    local dimension;
    local size_RA={};
    local num_of_dim=spectrum:getDimCount();
    for dimension=1,num_of_dim do
        size_RA[dimension]=spectrum:getSampleCount(dimension);
    end    --for dimension=1,num_of_dim
    return size_RA;
end    --initialize_size_RA


function initialize_limit_RA(spectrum,input_limit_RA,size_RA)
    local upper=2;
    local lower=1;
    local dimension;
    local num_of_dim=spectrum:getDimCount();
    local limit_RA={};
    if(not(input_limit_RA))then
        for dimension=1,num_of_dim do
            local new_row={};
            limit_RA[dimension]=new_row;
            limit_RA[dimension].upper=math.floor(0.9*size_RA[dimension]+0.5);
            --print("limit_RA[dimension].upper: "..limit_RA[dimension].upper);
            limit_RA[dimension].lower=math.floor(0.1*size_RA[dimension]+0.5);
        end    --dimension=1,num_of_dim
        --print("limit_RA[1].upper: "..limit_RA[1].upper);
    else    limit_RA=input_limit_RA;
    end    --if(not(input_limit_RA
    return limit_RA;
end    --initialize_limit_RA


function initialize_position_marker_RA(spectrum,input_position_marker_RA,limit_RA,size_RA)
    local dimension;
    local num_of_dim=spectrum:getDimCount();
    local upper=2;
    local lower=1;
    local position=3;
    local upper_limit=2;
    local lower_limit=1;
    local position_marker_RA={};
    position_marker_RA=input_position_marker_RA;
    --print("limit_RA[1].upper: "..limit_RA[1].upper);
    for dimension=1,num_of_dim do
        local new_row={};
        position_marker_RA[dimension]=new_row;
        position_marker_RA[dimension].position=limit_RA[dimension].lower;
        if(limit_RA[dimension].upper)then position_marker_RA[dimension].upper_limit=limit_RA[dimension].upper;
        else position_marker_RA[dimension].upper_limit=math.floor(0.9*size_RA[dimension]+0.5) end;
        position_marker_RA[dimension].lower_limit=limit_RA[dimension].lower;
        --if(not(position_marker_RA[dimension].lower_limit))then position_marker_RA[dimension].lower_limit=math.floor(0.1*size_RA[dimension]+0.5) end;
    end    --for dimension=1,num_of_dim
    --for x=1,num_of_dim do print("dimension: "..x.."    lower_limit: "..position_marker_RA[x].lower_limit.."    upper_limit: "..position_marker_RA[x].upper_limit.."    position: "..position_marker_RA[x].position) end;
    --temp=false;while(not(temp))do temp=increment_position_RA(position_marker_RA) end;
    --for x=1,num_of_dim do print("dimension: "..x.."    lower_limit: "..position_marker_RA[x].lower_limit.."    upper_limit: "..position_marker_RA[x].upper_limit.."    position: "..position_marker_RA[x].position) end;
    return position_marker_RA;
end    --initialize_position_marker_RA

--REPLACED THIS FUNCTION WITH THE FUNCTION BELOW IT -FFD
function original_get_max_average_highest_lowest_amplitude(spectrum,input_limit_RA)
    local complete_scan_signal;
    local amplitude;
    local size_RA={};
    local position_marker_RA={};
    local num_of_dim=spectrum:getDimCount();
    local position=3;
    size_RA=initialize_size_RA(spectrum);
    limit_RA=initialize_limit_RA(spectrum,input_limit_RA,size_RA);
    position_marker_RA=initialize_position_marker_RA(spectrum,position_marker_RA,limit_RA,size_RA);
    complete_scan_signal=false;
    local average_amplitude=0;local num_of_points=0;local max_amplitude=0;local highest_intensity=0;local lowest_intensity=0;
    while(not(complete_scan_signal))do
        if(num_of_dim==1)then amplitude=spectrum:getAt(position_marker_RA[1].position) end;
        if(num_of_dim==2)then amplitude=spectrum:getAt(position_marker_RA[1].position,position_marker_RA[2].position) end;
        if(num_of_dim==3)then amplitude=spectrum:getAt(position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position) end;
        if(num_of_dim==4)then amplitude=spectrum:getAt(position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position,position_marker_RA[4].position) end;
        if(num_of_dim==5)then amplitude=spectrum:getAt(position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position,position_marker_RA[4].position,position_marker_RA[5].position) end;
        complete_scan_signal=increment_position_RA(position_marker_RA);
        num_of_points=num_of_points+1;average_amplitude=average_amplitude+math.abs(amplitude);
        if(math.abs(amplitude)&gt;max_amplitude)then max_amplitude=math.abs(amplitude) end;
        if(amplitude&gt;highest_intensity)then highest_intensity=amplitude end;
        if(amplitude&lt;lowest_intensity)then lowest_intensity=amplitude end;
    end    --while(not(complete_scan_signal
    average_amplitude=average_amplitude/num_of_points;
    return max_amplitude,average_amplitude,highest_intensity,lowest_intensity;
end    --get_max_average_highest_lowest_amplitude

-- SIMPLER FUNCTION TO GET MAXIMA FROM CARA VALUES -FFD
function get_max_average_highest_lowest_amplitude(spectrum,input_limit_RA)
	pmax,pnoise,nmax,nnoise = spectrum:getLevels()
	average_amplitude = ( math.abs(pnoise) + math.abs(nnoise) )/2
	if ( math.abs(pmax) &gt; math.abs(nmax) ) then
		max_amplitude = math.abs(pmax)
	else
		max_amplitude = math.abs(nmax)
	end
	return max_amplitude,average_amplitude,pmax,nmax
end


function scale_RA(input_RA,input_max_amplitude)
    local x,y,max_amplitude;
    local output_RA={};
    max_amplitude=0;
    for x,y in pairs(input_RA)do
        if(y&gt;max_amplitude)then max_amplitude=y end;
    end    --for x,y in pairs(input_RA
    for x,y in pairs(input_RA)do
        output_RA[x]=(y/max_amplitude)*input_max_amplitude;
    end    --for x,y in pairs(input_RA
    return output_RA,max_amplitude
end    --scale_RA


function transfer_1D_RA_to_ND_RA(input_1D_spectrum_RA,input_ND_spectrum_RA,num_of_dim,position_RA,threshold,dimension_of_1D)

    local temp_threshold;
    local x,y,temp_dimension_of_1D,signal;
    local temp_ND_spectrum_RA={};
    local temp_pos_RA={};
    if(threshold)then temp_threshold=threshold else temp_threshold=0 end;
    signal=0;
    for x,y in pairs(input_1D_spectrum_RA) do
        if(math.abs(y)&gt;temp_threshold)then signal=1 end;
    end    --for x,y in pairs(input_1D_spectrum_RA
    if(signal&gt;0)then
        if(input_ND_spectrum_RA)then temp_ND_spectrum_RA=input_ND_spectrum_RA ;end;
        if(not(dimension_of_1D))then
        for x=1,num_of_dim do if(not(position_RA[x]))then temp_dimension_of_1D=x end;end;
        else temp_dimension_of_1D=dimension_of_1D end;
        for x,y in pairs(position_RA) do temp_pos_RA[x]=y end;
        for x,y in pairs(input_1D_spectrum_RA) do
            if(math.abs(y)&gt;temp_threshold)then
                temp_pos_RA[temp_dimension_of_1D]=x;
                if(num_of_dim==1)then
                    temp_ND_spectrum_RA[temp_pos_RA[1]]=y;
                end    --if(num_of_dim==5
                if(num_of_dim==2)then
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]]=new_row end;
                    temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]]=y;
                end    --if(num_of_dim==5
                if(num_of_dim==3)then
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]]=new_row end;
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]]=new_row end;
                    temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]][temp_pos_RA[3]]=y;
                end    --if(num_of_dim==5
                if(num_of_dim==4)then
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]]=new_row end;
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]]=new_row end;
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]][temp_pos_RA[3]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]][temp_pos_RA[3]]=new_row end;
                    temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]][temp_pos_RA[3]][temp_pos_RA[4]]=y;
                end    --if(num_of_dim==5
                if(num_of_dim==5)then
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]]=new_row end;
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]]=new_row end;
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]][temp_pos_RA[3]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]][temp_pos_RA[3]]=new_row end;
                    if(not(temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]][temp_pos_RA[3]][temp_pos_RA[4]]))then local new_row={};temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]][temp_pos_RA[3]][temp_pos_RA[4]]=new_row end;
                    temp_ND_spectrum_RA[temp_pos_RA[1]][temp_pos_RA[2]][temp_pos_RA[3]][temp_pos_RA[4]][temp_pos_RA[5]]=y;
                end    --if(num_of_dim==5
            end    --if(math.abs(y)&gt;temp_threshold
        end    --for x,y in pairs(input_1D_spectrum_RA
    input_ND_spectrum_RA=temp_ND_spectrum_RA;
    end    --if(signal&gt;0
    return;
end    --transfer_1D_RA_to_3D_RA


function multiply_combine_spectrum_RAs(input_RA_of_spectra,num_of_dim)

    local spectrum_num=1;
    local marker_1,marker_2,marker_3,marker_4,marker_5;
    num_of_spectra=length_of(input_RA_of_spectra);
    if(num_of_dim&gt;=1)then local size_1=length_of(input_RA_of_spectra[spectrum_num]) end;
    if(num_of_dim&gt;=2)then local size_2=length_of(input_RA_of_spectra[spectrum_num][1]) end;
    if(num_of_dim&gt;=3)then local size_3=length_of(input_RA_of_spectra[spectrum_num][1][1]) end;
    if(num_of_dim&gt;=4)then local size_4=length_of(input_RA_of_spectra[spectrum_num][1][1][1]) end;
    if(num_of_dim&gt;=5)then local size_5=length_of(input_RA_of_spectra[spectrum_num][1][1][1][1]) end;
    if(num_of_dim&gt;=1)then
        for d1=1,size_1 do
            if(num_of_dim&gt;=2)then
                for d2=1,size_2 do
                    if(num_of_dim&gt;=3)then
                        for d3=1,size_3 do
                            if(num_of_dim&gt;=4)then
                                for d4=1,size_4 do
                                    if(num_of_dim&gt;=5)then
                                        marker_5=0;
                                        for d5=1,size_5 do
                                            --5 dimensions:
                                            for x=1,num_of_spectra do
                                                if(not(output_spectra[d1]))then local new_row={};output_spectra[d1]=new_row;end;
                                                if(not(output_spectra[d1][d2]))then local new_row={};output_spectra[d1][d2]=new_row;end;
                                                if(not(output_spectra[d1][d2][d3]))then local new_row={};output_spectra[d1][d2][d3]=new_row;end;
                                                if(not(output_spectra[d1][d2][d3][d4]))then local new_row={};output_spectra[d1][d2][d3][d4]=new_row;end;
                                                if(not(output_spectra[d1][d2][d3][d4][d5]))then output_spectra[d1][d2][d3][d4][d5]=0;if(x==1)then output_spectra[d1][d2][d3][d4][d5]=1 end;end;
                                                new_int=nil;if(input_RA_of_spectra[x][d1])then if(input_RA_of_spectra[x][d1][d2])then if(input_RA_of_spectra[x][d1][d2][d3])then if(input_RA_of_spectra[x][d1][d2][d3][d4])then if(input_RA_of_spectra[x][d1][d2][d3][d4][d5])then new_int=input_RA_of_spectra[x][d1][d2][d3][d4][d5] end;end;end;end;end;
                                                if(new_int)then output_spectra[d1][d2][d3][d4][d5]=output_spectra[d1][d2][d3][d4][d5]*new_int else output_spectra[d1][d2][d3][d4][d5]=0 end    --if(new_int
                                                --if(output_spectra[d1][d2][d3][d4][d5]==0)then output_spectra[d1][d2][d3][d4][d5]=nil end;
                                            end    --for x=1,num_of_spectra
                                            if(output_spectra[d1][d2][d3][d4][d5]~=0)then output_spectra[d1][d2][d3][d4][d5]=output_spectra[d1][d2][d3][d4][d5]^(1/num_of_spectra);marker_1=1;marker_2=1;marker_3=1;marker_4=1;marker_1=5; end;
                                        end    --for d5=1,size_5
                                        if(marker_5==0)then output_spectra[d1][d2][d3][d4][d5]=nil end;
                                    else    --if(num_of_dim&gt;=5
                                        --4 dimensions:
                                        for x=1,num_of_spectra do
                                            if(not(output_spectra[d1]))then local new_row={};output_spectra[d1]=new_row;end;
                                            if(not(output_spectra[d1][d2]))then local new_row={};output_spectra[d1][d2]=new_row;end;
                                            if(not(output_spectra[d1][d2][d3]))then local new_row={};output_spectra[d1][d2][d3]=new_row;end;
                                            if(not(output_spectra[d1][d2][d3][d4]))then output_spectra[d1][d2][d3][d4]=0;if(x==1)then output_spectra[d1][d2][d3][d4]=1 end;end;
                                            new_int=nil;if(input_RA_of_spectra[x][d1])then if(input_RA_of_spectra[x][d1][d2])then if(input_RA_of_spectra[x][d1][d2][d3])then if(input_RA_of_spectra[x][d1][d2][d3][d4])then new_int=input_RA_of_spectra[x][d1][d2][d3][d4] end;end;end;end;
                                            if(new_int)then output_spectra[d1][d2][d3][d4]=output_spectra[d1][d2][d3][d4]*new_int else output_spectra[d1][d2][d3][d4]=0 end    --if(new_int
                                            --if(output_spectra[d1][d2][d3][d4]==0)then output_spectra[d1][d2][d3][d4]=nil end;
                                        end    --for x=1,num_of_spectra
                                        if(output_spectra[d1][d2][d3][d4]~=0)then output_spectra[d1][d2][d3][d4]=output_spectra[d1][d2][d3][d4]^(1/num_of_spectra);marker_1=1;marker_2=1;marker_3=1;marker_4=1; end;
                                    end    --if(num_of_dim&gt;=5...else
                                end    --for d4=1,size_4
                                if(marker_4==0)then output_spectra[d1][d2][d3][d4]=nil end;
                            else    --if(num_of_dim&gt;=4
                                --3 dimensions:
                                for x=1,num_of_spectra do
                                    if(not(output_spectra[d1]))then local new_row={};output_spectra[d1]=new_row;end;
                                    if(not(output_spectra[d1][d2]))then local new_row={};output_spectra[d1][d2]=new_row;end;
                                    if(not(output_spectra[d1][d2][d3]))then output_spectra[d1][d2][d3]=0;if(x==1)then output_spectra[d1][d2][d3]=1 end;end;
                                    new_int=nil;if(input_RA_of_spectra[x][d1])then if(input_RA_of_spectra[x][d1][d2])then if(input_RA_of_spectra[x][d1][d2][d3])then new_int=input_RA_of_spectra[x][d1][d2][d3] end;end;end;
                                    if(new_int)then output_spectra[d1][d2][d3]=output_spectra[d1][d2][d3]*new_int else output_spectra[d1][d2][d3]=0 end    --if(new_int
                                    --if(output_spectra[d1][d2][d3]==0)then output_spectra[d1][d2][d3]=nil end;
                                end    --for x=1,num_of_spectra
                                if(output_spectra[d1][d2][d3]~=0)then output_spectra[d1][d2][d3]=output_spectra[d1][d2][d3]^(1/num_of_spectra);marker_1=1;marker_2=1;marker_3=1; end;
                            end    --if(num_of_dim&gt;=4...else
                        end    --for d3=1,size_3
                        if(marker_3==0)then output_spectra[d1][d2][d3]=nil end;
                    else    --if(num_of_dim&gt;=3
                        --2 dimensions:
                        for x=1,num_of_spectra do
                            if(not(output_spectra[d1]))then local new_row={};output_spectra[d1]=new_row;end;
                            if(not(output_spectra[d1][d2]))then output_spectra[d1][d2]=0;if(x==1)then output_spectra[d1][d2]=1 end;end;
                            new_int=nil;if(input_RA_of_spectra[x][d1])then if(input_RA_of_spectra[x][d1][d2])then new_int=input_RA_of_spectra[x][d1][d2] end;end;
                            if(new_int)then output_spectra[d1][d2]=output_spectra[d1][d2]*new_int else output_spectra[d1][d2]=0 end    --if(new_int
                            --if(output_spectra[d1][d2]==0)then output_spectra[d1][d2]=nil end;
                        end    --for x=1,num_of_spectra
                        if(output_spectra[d1][d2]~=0)then output_spectra[d1][d2]=output_spectra[d1][d2]^(1/num_of_spectra);marker_1=1;marker_2=1; end;
                    end    --if(num_of_dim&gt;=3...else
                end    --for d2=1,size_2
                if(marker_2==0)then output_spectra[d1][d2]=nil end;
            else    --if(num_of_dim&gt;=2
                --1 dimensions:
                for x=1,num_of_spectra do
                    if(not(output_spectra[d1]))then output_spectra[d1]=0;if(x==1)then output_spectra[d1]=1 end;end;
                    new_int=nil;if(input_RA_of_spectra[x][d1])then new_int=input_RA_of_spectra[x][d1] end;
                    if(new_int)then output_spectra[d1]=output_spectra[d1]*new_int else output_spectra[d1]=0 end    --if(new_int
                    --if(output_spectra[d1]==0)then output_spectra[d1]=nil end;
                end    --for x=1,num_of_spectra
                if(output_spectra[d1]~=0)then output_spectra[d1]=output_spectra[d1]^(1/num_of_spectra);marker_1=1; end;
            end    --if(num_of_dim&gt;=2...else
        end    --for d1=1,size_1
        if(marker_1==0)then output_spectra[d1]=nil end;
    else    --if(num_of_dim&gt;=1
        print("dimensionality=0");
    end    --if(num_of_dim&gt;=1...else
    return output_spectra;
end    --multiply_combine_spectrum_RAs


function get_intensity_from_nD_RA(input_spectrum_RA,x1,x2,x3,x4,x5)
    if(x5)then
        if(not(input_spectrum_RA[x1]))then return nil end;
        if(not(input_spectrum_RA[x1][x2]))then return nil end;
        if(not(input_spectrum_RA[x1][x2][x3]))then return nil end;
        if(not(input_spectrum_RA[x1][x2][x3][x4]))then return nil end;
        if(not(input_spectrum_RA[x1][x2][x3][x4][x5]))then return nil end;
        return input_spectrum_RA[x1][x2][x3][x4][x5];
    end    --if(x5
    if(x4)then
        if(not(input_spectrum_RA[x1]))then return nil end;
        if(not(input_spectrum_RA[x1][x2]))then return nil end;
        if(not(input_spectrum_RA[x1][x2][x3]))then return nil end;
        if(not(input_spectrum_RA[x1][x2][x3][x4]))then return nil end;
        return input_spectrum_RA[x1][x2][x3][x4];
    end    --if(x4
    if(x3)then
        if(not(input_spectrum_RA[x1]))then return nil end;
        if(not(input_spectrum_RA[x1][x2]))then return nil end;
        if(not(input_spectrum_RA[x1][x2][x3]))then return nil end;
        return input_spectrum_RA[x1][x2][x3];
    end    --if(x3
    if(x2)then
        if(not(input_spectrum_RA[x1]))then return nil end;
        if(not(input_spectrum_RA[x1][x2]))then return nil end;
        return input_spectrum_RA[x1][x2];
    end    --if(x2
    if(x1)then
        if(not(input_spectrum_RA[x1]))then return nil end;
        return input_spectrum_RA[x1];
    end    --if(x1
    return nil;
end    --get_intensity_from_nD_RA


function identify_peaks_in_ND_spectrum(spectrum,peak_shape_RA,threshold,input_limit_RA,mode,point_window_RA)
    local size_RA={};
    local position_marker_RA={};
    local num_of_dim=spectrum:getDimCount();
    local position_marker_RA={};
    local temp_position_RA={};
    local temp_1D_spectrum_RA={};
    local new_row={};
    local output_peak_shape_RA={};
    local RA_of_spectra={};
    local temp_point_window_RA={};
    local processed_spectrum_RA={};
    local output_peak_table={};
    local upper=2;
    local lower=1;
    local position=3;
    local upper_limit=2;
    local lower_limit=1;
    local amplitude_index=1;
    local intensity_index=2;
    local coordinates_index=3;
    local max_amplitude,average_amplitude,local_max_signal,center_amp,center_intensity;
    for x=1,num_of_dim do local new_row={};RA_of_spectra[x]=new_row; end;
    if(not(point_window_RA))then for x=1,num_of_dim do temp_point_window_RA[x]=10 end; else temp_point_window_RA=point_window_RA end;
    for x=1,num_of_dim do
        if(temp_point_window_RA[x]&lt;4)then temp_point_window_RA[x]=4 end;
        if(math.mod(temp_point_window_RA[x],2)==1)then temp_point_window_RA[x]=temp_point_window_RA[x]+1 end;
    end    --for x=1,num_of_dim
    if(not(mode))then temp_mode="simple" else temp_mode=mode end;
    print("temp_mode: "..temp_mode);
    size_RA=initialize_size_RA(spectrum);
    limit_RA=initialize_limit_RA(spectrum,input_limit_RA,size_RA);
    max_amplitude,average_amplitude=get_max_average_highest_lowest_amplitude(spectrum,limit_RA);
    print("max_amplitude: "..max_amplitude.."    average_amplitude: "..average_amplitude);
    position_marker_RA=initialize_position_marker_RA(spectrum,position_marker_RA,limit_RA,size_RA);
    --print("ave/max: "..average_amplitude/max_amplitude);
    if(not(threshold))then temp_threshold=average_amplitude*4 else temp_threshold=threshold end;
    print("threshold: "..temp_threshold);
    for dimension=1,num_of_dim do
        complete_scan_signal=false;
        while(not(complete_scan_signal))do
            if(position_marker_RA[dimension].position==limit_RA[dimension].lower)then
                --print("position[dimension]: "..position_marker_RA[dimension].position);
                for x=1,num_of_dim do temp_position_RA[x]=position_marker_RA[x].position end;
                temp_position_RA[dimension]=nil;
                temp_1D_spectrum_RA=get_1D_from_spectrum(spectrum,temp_position_RA[1],temp_position_RA[2],temp_position_RA[3],temp_position_RA[4],temp_position_RA[5]);
                --for x=1,length_of(temp_spectrum_RA)do print ("x: "..x.."    "..temp_spectrum_RA[x]) end;
                local new_row={};
                --print("length_of(temp_1D_spectrum_RA): "..length_of(temp_1D_spectrum_RA));
                --print("length_of(peak_shape_RA[dimension]): "..length_of(peak_shape_RA[dimension]));
                if(temp_mode=="complex")then
                    new_row=grow_peaks_into_1D_RA(temp_1D_spectrum_RA,peak_shape_RA[dimension],limit_RA[dimension].lower,limit_RA[dimension].upper,temp_threshold);
                    transfer_1D_RA_to_3D_RA(new_row,RA_of_spectra[dimension],num_of_dim,temp_position_RA,temp_threshold);
                end    --if(mode=="complex
                if(temp_mode=="simple")then
                    transfer_1D_RA_to_ND_RA(temp_1D_spectrum_RA,RA_of_spectra[dimension],num_of_dim,temp_position_RA,temp_threshold);
                    --print("length_of(temp_1D_spectrum_RA): "..length_of(temp_1D_spectrum_RA));
                    --print("length_of(RA_of_spectra[dimension]: "..length_of(RA_of_spectra[dimension]));
                end    --if(temp_mode=="simple
            end    --if(position_marker_RA[dimension].position==limit_RA[dimension].lower
            complete_scan_signal=increment_position_RA(position_marker_RA);
        end    --while(not(complete_scan_signal
    end    --for dimension=1,num_of_dim()
    if(temp_mode=="complex")then processed_spectrum_RA=multiply_combine_spectrum_RAs(RA_of_spectra,num_of_dim) end;
    if(temp_mode=="simple")then processed_spectrum_RA=RA_of_spectra[1] end;
    print("length_of(processed_spectrum_RA): "..length_of(processed_spectrum_RA));
    --3-point filtering here.
    local peak_number=0;
    complete_scan_signal=false;
    position_marker_RA=initialize_position_marker_RA(spectrum,position_marker_RA,limit_RA,size_RA);
    while(not(complete_scan_signal))do
        if(num_of_dim==1)then
            local_max_signal=1;
            center_intensity=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position);
            if(center_intensity)then
                center_amp=math.abs(center_intensity);
                for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2 do
                    temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position+x);
                    if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                end    --for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2
                if(local_max_signal&gt;0)then
                    local temp_table={};
                    temp_table[1]=spectrum:getFreq(1,position_marker_RA[1].position);
                    local new_row={};
                    new_row.coordinates_index=temp_table;
                    new_row.intensity_index=center_intensity;
                    new_row.amplitude_index=center_amp;
                    peak_number=peak_number+1;output_peak_table[peak_number]=new_row;
                end    --if(local_max_signal&gt;0
            end    --if(center_intensity
        end    --if(num_of_dim==1
        if(num_of_dim==2)then
            local_max_signal=1;
            center_intensity=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position);
            if(center_intensity)then
                center_amp=math.abs(center_intensity); 
                for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2 do
                    temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position+x,position_marker_RA[2].position);
                    if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                end    --for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[2]/2,temp_point_window_RA[2]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position+x);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[2]/2,temp_point_window_RA[2]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    --print("peak: ["..position_marker_RA[1].position.."]["..position_marker_RA[2].position.."]    "..center_amp);
                    --print("peak: ["..spectrum:getFreq(1,position_marker_RA[1].position).."]["..spectrum:getFreq(2,position_marker_RA[2].position).."]    "..center_amp);
                    local temp_table={};
                    temp_table[1]=spectrum:getFreq(1,position_marker_RA[1].position);
                    temp_table[2]=spectrum:getFreq(2,position_marker_RA[2].position);
                    local new_row={};
                    new_row.coordinates_index=temp_table;
                    new_row.intensity_index=center_intensity;
                    new_row.amplitude_index=center_amp;
                    peak_number=peak_number+1;output_peak_table[peak_number]=new_row;
                end    --if(local_max_signal&gt;0
            end    --if(center_intensity
        end    --if(num_of_dim==2
        if(num_of_dim==3)then
            local_max_signal=1;
            center_intensity=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position);
            if(center_intensity)then
                center_amp=math.abs(center_intensity); 
                for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2 do
                    temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position+x,position_marker_RA[2].position,position_marker_RA[3].position);
                    if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                end    --for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[2]/2,temp_point_window_RA[2]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position+x,position_marker_RA[3].position);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[2]/2,temp_point_window_RA[2]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[3]/2,temp_point_window_RA[3]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position+x);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[3]/2,temp_point_window_RA[3]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    local temp_table={};
                    temp_table[1]=spectrum:getFreq(1,position_marker_RA[1].position);
                    temp_table[2]=spectrum:getFreq(2,position_marker_RA[2].position);
                    temp_table[3]=spectrum:getFreq(3,position_marker_RA[3].position);
                    local new_row={};
                    new_row.coordinates_index=temp_table;
                    new_row.intensity_index=center_intensity;
                    new_row.amplitude_index=center_amp;
                    peak_number=peak_number+1;output_peak_table[peak_number]=new_row;
                end    --if(local_max_signal&gt;0
            end    --if(center_intensity
        end    --if(num_of_dim==3
        if(num_of_dim==4)then
            local_max_signal=1;
            center_intensity=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position,position_marker_RA[4].position);
            if(center_intensity)then
                center_amp=math.abs(center_intensity);
                for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2 do
                    temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position+x,position_marker_RA[2].position,position_marker_RA[3].position,position_marker_RA[4].position);
                    if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                end    --for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[2]/2,temp_point_window_RA[2]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position+x,position_marker_RA[3].position,position_marker_RA[4].position);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[2]/2,temp_point_window_RA[2]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[3]/2,temp_point_window_RA[3]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position+x,position_marker_RA[4].position);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[3]/2,temp_point_window_RA[3]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[4]/2,temp_point_window_RA[4]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position,position_marker_RA[4].position+x);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[4]/2,temp_point_window_RA[4]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    local temp_table={};
                    temp_table[1]=spectrum:getFreq(1,position_marker_RA[1].position);
                    temp_table[2]=spectrum:getFreq(2,position_marker_RA[2].position);
                    temp_table[3]=spectrum:getFreq(3,position_marker_RA[3].position);
                    temp_table[4]=spectrum:getFreq(4,position_marker_RA[4].position);
                    local new_row={};
                    new_row.coordinates_index=temp_table;
                    new_row.intensity_index=center_intensity;
                    new_row.amplitude_index=center_amp;
                    peak_number=peak_number+1;output_peak_table[peak_number]=new_row;
                end    --if(local_max_signal&gt;0
            end    --if(center_intensity
        end    --if(num_of_dim==4
        if(num_of_dim==5)then
            local_max_signal=1;
            center_intensity=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position,position_marker_RA[4].position,position_marker_RA[5].position);
            if(center_intensity)then
                center_amp=math.abs(center_intensity); 
                for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2 do
                    temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position+x,position_marker_RA[2].position,position_marker_RA[3].position,position_marker_RA[4].position,position_marker_RA[5].position);
                    if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                end    --for x=-temp_point_window_RA[1]/2,temp_point_window_RA[1]/2
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[2]/2,temp_point_window_RA[2]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position+x,position_marker_RA[3].position,position_marker_RA[4].position,position_marker_RA[5].position);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[2]/2,temp_point_window_RA[2]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[3]/2,temp_point_window_RA[3]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position+x,position_marker_RA[4].position,position_marker_RA[5].position);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[3]/2,temp_point_window_RA[3]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[4]/2,temp_point_window_RA[4]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position,position_marker_RA[4].position+x,position_marker_RA[5].position);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[4]/2,temp_point_window_RA[4]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    for x=-temp_point_window_RA[5]/2,temp_point_window_RA[5]/2 do
                        temp_amp=get_intensity_from_nD_RA(processed_spectrum_RA,position_marker_RA[1].position,position_marker_RA[2].position,position_marker_RA[3].position,position_marker_RA[4].position,position_marker_RA[5].position+x);
                        if(temp_amp)then if(math.abs(temp_amp)&gt;center_amp)then local_max_signal=0 end;end;
                    end    --for x=-temp_point_window_RA[5]/2,temp_point_window_RA[5]/2
                end    --if(local_max_signal&gt;0
                if(local_max_signal&gt;0)then
                    local temp_table={};
                    temp_table[1]=spectrum:getFreq(1,position_marker_RA[1].position);
                    temp_table[2]=spectrum:getFreq(2,position_marker_RA[2].position);
                    temp_table[3]=spectrum:getFreq(3,position_marker_RA[3].position);
                    temp_table[4]=spectrum:getFreq(4,position_marker_RA[4].position);
                    temp_table[5]=spectrum:getFreq(5,position_marker_RA[5].position);
                    local new_row={};
                    new_row.coordinates_index=temp_table;
                    new_row.intensity_index=center_intensity;
                    new_row.amplitude_index=center_amp;
                    peak_number=peak_number+1;output_peak_table[peak_number]=new_row;
                end    --if(local_max_signal&gt;0
            end    --if(center_intensity
        end    --if(num_of_dim==5
        complete_scan_signal=increment_position_RA(position_marker_RA);
    end    --while(not(complete_scan_signal
    return output_peak_table;
end    --indentify_peaks_in_ND_spectrum


function create_spin_system(spectrum,f1,f2,f3,f4,f5)
    local new_spin_system=t.P:createSystem();
    --print("new_spin_system Id: "..new_spin_system:getId());
    if(f1)then 
        local new_spin=t.P:createSpin(spectrum:getAtomType(1),f1);
        new_label_RA=spectrum:getType():getLabels(1);
        if(length_of(new_label_RA)==1)then t.P:setLabel(new_spin,new_label_RA[1]) end;
        t.P:assignSpin(new_spin,new_spin_system);
    end    --if(f1
    if(f2)then 
        local new_spin=t.P:createSpin(spectrum:getAtomType(2),f2);
        new_label_RA=spectrum:getType():getLabels(2);
        if(length_of(new_label_RA)==1)then t.P:setLabel(new_spin,new_label_RA[1]) end;
        t.P:assignSpin(new_spin,new_spin_system);
    end    --if(f2
    if(f3)then 
        local new_spin=t.P:createSpin(spectrum:getAtomType(3),f3);
        new_label_RA=spectrum:getType():getLabels(3);
        if(length_of(new_label_RA)==1)then t.P:setLabel(new_spin,new_label_RA[1]) end;
        t.P:assignSpin(new_spin,new_spin_system);
    end    --if(f3
    if(f4)then 
        local new_spin=t.P:createSpin(spectrum:getAtomType(4),f4);
        new_label_RA=spectrum:getType():getLabels(4);
        if(length_of(new_label_RA)==1)then t.P:setLabel(new_spin,new_label_RA[1]) end;
        t.P:assignSpin(new_spin,new_spin_system);
    end    --if(f4
    if(f5)then 
        local new_spin=t.P:createSpin(spectrum:getAtomType(5),f5);
        new_label_RA=spectrum:getType():getLabels(5);
        if(length_of(new_label_RA)==1)then t.P:setLabel(new_spin,new_label_RA[1]) end;
        t.P:assignSpin(new_spin,new_spin_system);
    end    --if(f5
end    --create_spin_system

function pick_spin_systems_in_HSQC(spectrum,peak_shape_RA,threshold,input_limit_RA,mode,point_window_RA)
    local x,y;
    local peak_table={};
    local num_of_dim=spectrum:getDimCount();
    local amplitude_index=1;
    local intensity_index=2;
    local coordinates_index=3;
    peak_table=identify_peaks_in_ND_spectrum(spectrum,peak_shape_RA,threshold,input_limit_RA,mode,point_window_RA);
    print("number of peaks identified: "..length_of(peak_table));
    for x,peak_entry in pairs(peak_table)do
        --print("["..peak_entry.coordinates_index[1].."]["..peak_entry.coordinates_index[2].."]    "..peak_entry.amplitude_index.."    "..peak_entry.intensity_index);
        create_spin_system(spectrum,peak_entry.coordinates_index[1],peak_entry.coordinates_index[2],peak_entry.coordinates_index[3],peak_entry.coordinates_index[4],peak_entry.coordinates_index[5]);
    end    --for x,peak_entry in pairs(peak_table
end    --pick_spin_systems_in_HSQC


function is_local_max_in_1D_RA(point,input_1D_spectrum_RA,window_size)
    local size=length_of(input_1D_spectrum_RA);
    local temp_window_size;
    if(not(window_size))then temp_window_size=math.floor(size/100) else temp_window_size=window_size end;
    if(math.mod(temp_window_size,2)~=0)then temp_window_size=temp_window_size-1 end;
    local x;
    for x=-temp_window_size/2,temp_window_size/2 do
        if((point+x&gt;0)and(point+x&lt;=size))then
            if(math.abs(input_1D_spectrum_RA[point+x])&gt;input_1D_spectrum_RA[point])then return false end;
            if((math.abs(input_1D_spectrum_RA[point+x])==input_1D_spectrum_RA[point])and(x==-1))then return false end;
        end    --if((point+x&gt;0)and(point+x&lt;=size
    end    --for x=-temp_window_size/2,temp_window_size/2
    return true;
end    --is_local_max_in_1D_RA


function get_local_max_delta_from_1D_RA(point,input_1D_spectrum_RA,window_size)
    --print(input_1D_spectrum_RA);
    local size=length_of(input_1D_spectrum_RA);
    local temp_window_size;
    if(not(window_size))then temp_window_size=math.floor(size/100) else temp_window_size=window_size end;
    if(math.mod(temp_window_size,2)~=0)then temp_window_size=temp_window_size-1 end;
    --print("window_size: "..window_size.."    point: "..point);
    local x;
    --print("size: "..size);
    local max_minus_pos=nil;
    for x=0,temp_window_size/2 do
        if((point-x&gt;0)and(point-x&lt;=size))then
            if(is_local_max_in_1D_RA(point-x,input_1D_spectrum_RA,temp_window_size))then max_minus_pos=point-x;break end;
        end    --if((point-x&gt;0)and(point-x&lt;=size
    end    --for x=0,temp_window_size/2
    local max_plus_pos=nil;
    for x=point,point+temp_window_size/2 do
        if((x&gt;0)and(x&lt;=size))then
            if(is_local_max_in_1D_RA(x,input_1D_spectrum_RA,temp_window_size))then max_plus_pos=x;break end;
        end    --if((x&gt;0)and(x&lt;=size
    end    --for x=point,point-temp_window_size/2
    --print("======= "..max_plus_pos);
    --print("======= "..max_minus_pos);
    local delta_minus=nil;if(max_minus_pos)then delta_minus=point-max_minus_pos end;
    --print("======= "..delta_minus);
    local delta_plus=nil;if(max_plus_pos)then delta_plus=max_plus_pos-point end;
    --print("======= "..delta_plus);
    if((not(delta_minus))and(not(delta_plus)))then closest_max_pos=nil;
    else if((max_minus_pos)and(not(max_plus_pos)))then closest_max_pos=delta_minus;
         else if((max_plus_pos)and(not(max_minus_pos)))then closest_max_pos=delta_plus;
              else closest_max_pos=delta_minus;if(delta_plus&lt;delta_minus)then closest_max_pos=delta_plus end;
              end;
         end;
    end;
    --if(closest_max_pos)then print("closest_max_pos: "..closest_max_pos) else print("closest_max_pos: nil") end;
    return closest_max_pos;
end    --get_local_max_delta_from_1D_RA


function pick_spins_in_3D(input_3D_spectrum,input_2D_spectrum,input_threshold,input_limit_RA,window_width_RA)
    local size_RA_3D={};
    local limit_RA={};
    local spin_system_RA={};
    local label_RA_3D={};
    local label_RA_2D={};
    local dimension_map_RA_2_3={};
    local dimension_map_RA_3_2={};
    local temp_coor_RA={};
    local temp_1D_spectrum_RA_2={};
    local x,y;
    local upper=2;
    local lower=1;
    local temp_3D_spectrum,temp_3D_spectrum;
    local num_of_dim_3D=input_3D_spectrum:getDimCount();
    local num_of_dim_2D=input_2D_spectrum:getDimCount();
    local temp_lower_point_limit;
    local temp_lower_point_limit;
    local temp_window_width_RA={};
    local temp_threshold;
    if((num_of_dim_3D==2)and(num_of_dim_2D==3))then
        temp_3D_spectrum=input_2D_spectrum;temp_2D_spectrum=input_3D_spectrum;
        else    --if((num_of_dim_3D==2)and(num_of_dim_2D==3
        temp_3D_spectrum=input_3D_spectrum;temp_2D_spectrum=input_2D_spectrum;
    end    --if((num_of_dim_3D==2)and(num_of_dim_2D==3
    size_RA_3D=initialize_size_RA(temp_3D_spectrum);
    limit_RA=initialize_limit_RA(temp_3D_spectrum,input_limit_RA,size_RA_3D);
    max_amplitude_2D,average_amplitude_2D=get_max_average_highest_lowest_amplitude(temp_2D_spectrum);
    if(not(input_threshold))then temp_threshold=2.5*average_amplitude_2D else temp_threshold=input_threshold end;
    if(window_width_RA)then temp_window_width_RA=window_width_RA end;
    if(not(temp_window_width_RA[1]))then temp_window_width_RA[1]=math.floor(size_RA_3D[1]/100+0.5) end;
    print(temp_window_width_RA[1]);
    if(not(temp_window_width_RA[2]))then temp_window_width_RA[2]=math.floor(size_RA_3D[2]/100+0.5) end;
    print(temp_window_width_RA[2]);
    if(not(temp_window_width_RA[3]))then temp_window_width_RA[3]=math.floor(size_RA_3D[3]/100+0.5) end;
    print(temp_window_width_RA[3]);
    ID_of_3D=temp_3D_spectrum:getId();
    ID_of_2D=temp_2D_spectrum:getId();
    --figure out dimensional equivalence
    label_RA_3D[1]=temp_3D_spectrum:getType():getLabels(1);
    label_RA_3D[2]=temp_3D_spectrum:getType():getLabels(2);
    label_RA_3D[3]=temp_3D_spectrum:getType():getLabels(3);
    label_RA_2D[1]=temp_2D_spectrum:getType():getLabels(1);
    label_RA_2D[2]=temp_2D_spectrum:getType():getLabels(2);
    for x,label_3D in label_RA_3D do   --this loop uses dimension labels to determine which dimensions in 2D and 3D are equivalent.
        dimension_map_RA_3_2[x]=0;
        for y,label_2D in label_RA_2D do
            if(length_of(label_3D)==1)then
                if(label_3D[1]==label_2D[1])then dimension_map_RA_3_2[x]=y;dimension_map_RA_2_3[y]=x; end;
            end    --if(length_of(label_3D)==1
        end    --for y,label_2D in label_RA_2D
    end    --for x,label_3D in label_RA_3D
    --for x,y in pairs(dimension_map_RA_3_2)do print(x.."    "..y) end;
    for x,y in pairs(dimension_map_RA_3_2)do if(y==0)then xpeak_dim=x end end;
    local lower_limit=limit_RA[xpeak_dim].lower;
    local upper_limit=limit_RA[xpeak_dim].upper;
    --print(xpeak_dim);
    --get all spin systems
    spin_system_RA=t.P:getSystems();
    for spin_sys_Id,spin_system in pairs(spin_system_RA)do
        HSQC_spin_1=nil;HSQC_spin_2=nil;
        for spin_Id,spin in pairs(spin_system:getSpins()) do
            if(spin:getLabel()==label_RA_2D[1][1])then HSQC_spin_1=spin end;
            if(spin:getLabel()==label_RA_2D[2][1])then HSQC_spin_2=spin end;
            --print(spin:getLabel().."    "..label_RA_2D[1][1]);
        end    --for spin_Id,spin in pairs(spin_system:getSpins
        if((HSQC_spin_1)and(HSQC_spin_2))then
            HSQC_dim_shift_1=HSQC_spin_1:getShift(temp_2D_spectrum);
            HSQC_dim_shift_2=HSQC_spin_2:getShift(temp_2D_spectrum);
            --print(HSQC_dim_1_shift.."    "..HSQC_dim_2_shift);
            temp_coor_RA[dimension_map_RA_2_3[1]]=temp_3D_spectrum:getIndex(dimension_map_RA_2_3[1],HSQC_dim_shift_1);
            temp_coor_RA[dimension_map_RA_2_3[2]]=temp_3D_spectrum:getIndex(dimension_map_RA_2_3[2],HSQC_dim_shift_2);
            temp_coor_RA[xpeak_dim]=nil;
            temp_1D_RA=get_1D_from_spectrum(temp_3D_spectrum,temp_coor_RA[1],temp_coor_RA[2],temp_coor_RA[3]);
            print("spin_system: "..spin_system:getId());
            for x=lower_limit,upper_limit do
                if(math.abs(temp_1D_RA[x])&gt;temp_threshold)then
                    if(is_local_max_in_1D_RA(x,temp_1D_RA,temp_window_width_RA[xpeak_dim]))then
                        if(xpeak_dim==1)then
                            local_max_signal=1;
                            temp_1D_spectrum_RA_2=get_1D_from_spectrum(temp_3D_spectrum,x,temp_coor_RA[2],nil);
                            closest_max_delta=get_local_max_delta_from_1D_RA(temp_coor_RA[3],temp_1D_spectrum_RA_2,temp_window_width_RA[3]);
                            if(not(closest_max_delta))then local_max_signal=0;
                            else if(closest_max_delta&gt;temp_window_width_RA[3]/2)then local_max_signal=0; end;
                            end    --if(not(closest_max_delta...else
                            temp_1D_spectrum_RA_2=get_1D_from_spectrum(temp_3D_spectrum,x,nil,temp_coor_RA[3]);
                            closest_max_delta=get_local_max_delta_from_1D_RA(temp_coor_RA[2],temp_1D_spectrum_RA_2,temp_window_width_RA[2]);
                            if(not(closest_max_delta))then local_max_signal=0;
                            else if(closest_max_delta&gt;temp_window_width_RA[2]/2)then local_max_signal=0 end;
                            end    --if(not(closest_max_delta...else
                        end    --if(xpeak_dim==1
                        if(xpeak_dim==2)then
                            local_max_signal=1;
                            --print("temp_window_width_RA[3]: "..temp_window_width_RA[3]);
                            temp_1D_spectrum_RA_2=get_1D_from_spectrum(temp_3D_spectrum,temp_coor_RA[1],x,nil);
                            --for temp=1,length_of(temp_1D_spectrum_RA_2)do print(temp.."  "..temp_3D_spectrum:getFreq(3,temp).." &lt;&gt; "..temp_1D_spectrum_RA_2[temp]) end;
                            --print(temp_1D_spectrum_RA_2);
                            --print("center: "..temp_coor_RA[3]);
                            closest_max_delta=get_local_max_delta_from_1D_RA(temp_coor_RA[3],temp_1D_spectrum_RA_2,temp_window_width_RA[3]);
                            --print("temp_window_width_RA[3]: "..temp_window_width_RA[3]);
                            --print("closest_max_delta: "..closest_max_delta);
                            if(not(closest_max_delta))then local_max_signal=0;
                            else if(closest_max_delta&gt;temp_window_width_RA[3]/2)then local_max_signal=0; end;
                            end    --if(not(closest_max_delta...else
                            temp_1D_spectrum_RA_2=get_1D_from_spectrum(temp_3D_spectrum,nil,x,temp_coor_RA[3]);
                            closest_max_delta=get_local_max_delta_from_1D_RA(temp_coor_RA[1],temp_1D_spectrum_RA_2,temp_window_width_RA[1]);
                            if(not(closest_max_delta))then local_max_signal=0;
                            else if(closest_max_delta&gt;temp_window_width_RA[1]/2)then local_max_signal=0 end;
                            end    --if(not(closest_max_delta...else
                        end    --if(xpeak_dim==2
                        if(xpeak_dim==3)then
                            local_max_signal=1;
                            temp_1D_spectrum_RA_2=get_1D_from_spectrum(temp_3D_spectrum,temp_coor_RA[1],nil,x);
                            closest_max_delta=get_local_max_delta_from_1D_RA(temp_coor_RA[2],temp_1D_spectrum_RA_2,temp_window_width_RA[2]);
                            if(not(closest_max_delta))then local_max_signal=0;
                            else if(closest_max_delta&gt;temp_window_width_RA[2]/2)then local_max_signal=0; end;
                            end    --if(not(closest_max_delta...else
                            temp_1D_spectrum_RA_2=get_1D_from_spectrum(temp_3D_spectrum,nil,temp_coor_RA[2],x);
                            closest_max_delta=get_local_max_delta_from_1D_RA(temp_coor_RA[1],temp_1D_spectrum_RA_2,temp_window_width_RA[1]);
                            if(not(closest_max_delta))then local_max_signal=0;
                            else if(closest_max_delta&gt;temp_window_width_RA[1]/2)then local_max_signal=0 end;
                            end    --if(not(closest_max_delta...else
                        end    --if(xpeak_dim==3
                        if(local_max_signal&gt;0)then
                            local new_spin=t.P:createSpin(temp_3D_spectrum:getAtomType(xpeak_dim),temp_3D_spectrum:getFreq(xpeak_dim,x));
                            t.P:assignSpin(new_spin,spin_system);
                            --print(x.."    "..temp_3D_spectrum:getFreq(xpeak_dim,x).."    "..string.rep("*",temp_1D_RA[x]/10000));
                        end    --if(local_max_signal&gt;0
                    end    --if(is_local_max_in_1D_RA(x,temp_1D_RA,window_width
                end    --if(math.abs(temp_1D_RA[x])&gt;temp_threshold
            end    --for x=lower_limit,upper_limit
        end    --if((HSQC_spin_1)and(HSQC_spin_2            
    end    --for spin_sys_Id,spin_system in pairs(spin_system_RA
end    --pick_spins_in_3D
--MAIN:-----------------------------------------------------------------------------

-- create table for temporary variables:
t = {}
--input_parameter_processing--------------------------------------------------------

-- NEW CONTROL PANEL ------------------------------------------------

-- ============Set up menu window for user preferences===================


--1. Create main menu window

v = gui.createMainWindow()
v:setCaption( "Selection Dialog for Pick_2D_Peaks" )
t.frm = gui.createGrid( v, 2, false )
v:setCentralWidget( t.frm )
v:show()
t.frm:show()

-- Define ProjectList Combobox and its Label
t.ProjectListLabel = gui.createLabel( t.frm, "Select Project" )
t.ProjectListCB = gui.createComboBox( t.frm )


--2. Read ProjectNames into ProjectList combobox

SelectedItemIndex = nil
for Id,Project in pairs( cara:getProjects() ) do
	ItemIndex = t.ProjectListCB:addItem( Project:getName() )
	t.ProjectListCB:setCurrentItem( ItemIndex )
	if Pick_2D_Peaks_ProjectName == t.ProjectListCB:getCurrentText() then
		SelectedItemIndex = ItemIndex
	end
end -- for all projects

if SelectedItemIndex then -- set to previous choice if it exists
	t.ProjectListCB:setCurrentItem( SelectedItemIndex )
end

-- Display ProjectList Combobox
t.ProjectListLabel:show()
t.ProjectListCB:show()

--3. Select Spectrum Combobox

-- Define SpectrumList Combobox and its Label
t.SpectrumListLabel = gui.createLabel( t.frm, "Select 2D spectrum for picking Systems" )
t.SpectrumListCB = gui.createComboBox( t.frm )

SelectedItemIndex=nil
for SpectrumId,Spectrum in pairs( cara:getProject( t.ProjectListCB:getCurrentText() ):getSpectra() ) do
	if Spectrum:getDimCount() == 2 then
		ItemIndex = t.SpectrumListCB:addItem( Spectrum:getName() )
		t.SpectrumListCB:setCurrentItem( ItemIndex )
		if Pick_2D_Peaks_SpectrumName == t.SpectrumListCB:getCurrentText() then
			SelectedItemIndex = ItemIndex
		end
	end -- if 2D spectrum
end -- for all spectra

if SelectedItemIndex then -- set to previous choice if it exists
	t.SpectrumListCB:setCurrentItem( SelectedItemIndex )
end

-- Display SpectrumList ComboBox
t.SpectrumListLabel:show()
t.SpectrumListCB:show()

--4. Select Threshhold cutoff

--t.ThreshholdLE:getCurrentText()

-- Create Label and LineEdit Box for Threshhold
t.ThreshholdLELabel = gui.createLabel( t.frm, "Cutoff threshhold to pick peaks: " )
t.ThreshholdLE = gui.createLineEdit( t.frm )

if Pick_2D_Peaks_Threshhold then -- determine if Threshhold already exists
	t.ThreshholdLE:setText( Pick_2D_Peaks_Threshhold )
else
	t.ThreshholdLE:setText( "70000" )
	proj = cara:getProject( t.ProjectListCB:getCurrentText() )
	spectra = proj:getSpectra()
	SelectedSpec = nil
	for SpecId,Spec in pairs( spectra ) do
		if t.SpectrumListCB:getCurrentText() == Spec:getName() then
			SelectedSpec = Spec
		end -- if spectrum is selected spectrum
	end -- for all spectra
	if SelectedSpec == nil then
		print("Trying to set Threshhold: No spectrum found")
	else
		dummy,ave_amplitude = get_max_average_highest_lowest_amplitude( SelectedSpec,1000000 )
		t.ThreshholdLE:setText( string.format( "%i10", ave_amplitude*10 ) )
	end
end
-- Display Label and LineEdit window
t.ThreshholdLELabel:show()
t.ThreshholdLE:show()

--5. Get ppm ranges for peak-picking

-- Create Label and Lineedit Box for Dim1 range
t.StartDim1RangeLELabel = gui.createLabel( t.frm, "Starting Shift (dim 1): " )
t.StartDim1RangeLE = gui.createLineEdit( t.frm )
t.EndDim1RangeLELabel = gui.createLabel( t.frm, " Ending Shift (dim 1): " )
t.EndDim1RangeLE = gui.createLineEdit( t.frm )

if Pick_2D_Peaks_StartDim1Range then -- determine if StartRes already exists
	t.StartDim1RangeLE:setText( string.format( "%3.3f", Pick_2D_Peaks_StartDim1Range ) )
	t.EndDim1RangeLE:setText( string.format( "%3.3f", Pick_2D_Peaks_EndDim1Range ) )
else
	t.StartDim1RangeLE:setText( "5.500" ) -- default value
	if SelectedSpec == nil then
		print("PpmRanges: No spectrum found")
	else
		StartRange,EndRange = SelectedSpec:getPpmRange( 1 )
		t.StartDim1RangeLE:setText( string.format( "%3.3f", StartRange ) )
		t.EndDim1RangeLE:setText( string.format( "%3.3f", EndRange ) )	
	end -- if Spectrum found
end

-- Display Label and LineEdit windows
t.StartDim1RangeLELabel:show()
t.StartDim1RangeLE:show()
-- Display Label and LineEdit windows
t.EndDim1RangeLELabel:show()
t.EndDim1RangeLE:show()

-- Create Label and Lineedit Box for Dim2 range
t.StartDim2RangeLELabel = gui.createLabel( t.frm, "Starting Shift (dim 2): " )
t.StartDim2RangeLE = gui.createLineEdit( t.frm )
t.EndDim2RangeLELabel = gui.createLabel( t.frm, " Ending Shift (dim 2): " )
t.EndDim2RangeLE = gui.createLineEdit( t.frm )

if Pick_2D_Peaks_StartDim2Range then -- determine if StartRes already exists
	t.StartDim2RangeLE:setText( string.format( "%3.3f", Pick_2D_Peaks_StartDim2Range ) )
	t.EndDim2RangeLE:setText( string.format( "%3.3f", Pick_2D_Peaks_EndDim2Range ) )
else
	t.StartDim2RangeLE:setText( "108.000" ) -- default value
	if SelectedSpec == nil then
		print("PpmRange D2: No spectrum found" )
	else
		StartRange,EndRange = SelectedSpec:getPpmRange( 2 )
		t.StartDim2RangeLE:setText( string.format( "%3.3f", StartRange ) )
		t.EndDim2RangeLE:setText( string.format( "%3.3f", EndRange ) )
	end -- if spectrum found
end

-- Display Label and LineEdit windows
t.StartDim2RangeLELabel:show()
t.StartDim2RangeLE:show()
-- Display Label and LineEdit windows
t.EndDim2RangeLELabel:show()
t.EndDim2RangeLE:show()

-- PANEL ELEMENTS for 3D spectrum

--3b. Select Spectrum Combobox

-- Define SpectrumList Combobox and its Label
t.SpectrumList3DLabel = gui.createLabel( t.frm, "Select 3D spectrum for picking Spins" )
t.SpectrumList3DCB = gui.createComboBox( t.frm )

SelectedItemIndex=nil
for SpectrumId,Spectrum in pairs( cara:getProject( t.ProjectListCB:getCurrentText() ):getSpectra() ) do
	if Spectrum:getDimCount() == 3 then
		ItemIndex = t.SpectrumList3DCB:addItem( Spectrum:getName() )
		t.SpectrumList3DCB:setCurrentItem( ItemIndex )
		print( t.SpectrumList3DCB:getCurrentText() ) -- TEST ONLY
		if Pick_3D_Peaks_SpectrumName == t.SpectrumList3DCB:getCurrentText() then
			SelectedItemIndex = ItemIndex
		end
	end -- if 2D spectrum
end -- for all spectra


if SelectedItemIndex then -- set to previous choice if it exists
	t.SpectrumList3DCB:setCurrentItem( SelectedItemIndex )
end

-- Display SpectrumList ComboBox
t.SpectrumList3DLabel:show()
t.SpectrumList3DCB:show()

--4b. Select 3D Threshhold cutoff

--t.ThreshholdLE:getCurrentText()

-- Create Label and LineEdit Box for Threshhold
t.Threshhold3DLELabel = gui.createLabel( t.frm, "Cutoff threshhold to pick peaks: " )
t.Threshhold3DLE = gui.createLineEdit( t.frm )

if Pick_3D_Peaks_Threshhold then -- determine if Threshhold already exists
	t.Threshhold3DLE:setText( Pick_3D_Peaks_Threshhold )
else
	t.Threshhold3DLE:setText( "70000" )
	proj = cara:getProject( t.ProjectListCB:getCurrentText() )
	spectra = proj:getSpectra()
	SelectedSpec = nil
	for SpecId,Spec in pairs( spectra ) do
		if t.SpectrumList3DCB:getCurrentText() == Spec:getName() then
			SelectedSpec = Spec
		end -- if spectrum is selected spectrum
	end -- for all spectra
	if SelectedSpec == nil then
		print("Trying to set Threshhold: No spectrum found")
	else
		dummy,ave_amplitude = get_max_average_highest_lowest_amplitude( SelectedSpec, 1000000 )
		t.Threshhold3DLE:setText( string.format( "%i10", ave_amplitude*10 ) )
	end
end
-- Display Label and LineEdit window
t.Threshhold3DLELabel:show()
t.Threshhold3DLE:show()

--5b. Get ppm ranges for peak-picking

-- Create Label and Lineedit Box for Dim1 range
t.StartDim1Range3DLELabel = gui.createLabel( t.frm, "Starting Shift (dim 1): " )
t.StartDim1Range3DLE = gui.createLineEdit( t.frm )
t.EndDim1Range3DLELabel = gui.createLabel( t.frm, " Ending Shift (dim 1): " )
t.EndDim1Range3DLE = gui.createLineEdit( t.frm )

if Pick_3D_Peaks_StartDim1Range then -- determine if StartRes already exists
	t.StartDim1Range3DLE:setText( string.format( "%3.3f", Pick_3D_Peaks_StartDim1Range ) )
	t.EndDim1Range3DLE:setText( string.format( "%3.3f", Pick_3D_Peaks_EndDim1Range ) )
else
	t.StartDim1Range3DLE:setText( "5.500" ) -- default value
	if SelectedSpec == nil then
		print("PpmRanges: No spectrum found")
	else
		StartRange,EndRange = SelectedSpec:getPpmRange( 1 )
		t.StartDim1Range3DLE:setText( StartRange )
		t.EndDim1Range3DLE:setText( EndRange )	
	end -- if Spectrum found
end

-- Display Label and LineEdit windows
t.StartDim1Range3DLELabel:show()
t.StartDim1Range3DLE:show()
-- Display Label and LineEdit windows
t.EndDim1Range3DLELabel:show()
t.EndDim1Range3DLE:show()

-- Create Label and Lineedit Box for Dim2 range
t.StartDim2Range3DLELabel = gui.createLabel( t.frm, "Starting Shift (dim 2): " )
t.StartDim2Range3DLE = gui.createLineEdit( t.frm )
t.EndDim2Range3DLELabel = gui.createLabel( t.frm, " Ending Shift (dim 2): " )
t.EndDim2Range3DLE = gui.createLineEdit( t.frm )

if Pick_3D_Peaks_StartDim2Range then -- determine if StartRes already exists
	t.StartDim2Range3DLE:setText( string.format( "%3.3f", Pick_3D_Peaks_StartDim2Range ) )
	t.EndDim2Range3DLE:setText( string.format( "%3.3f", Pick_3D_Peaks_EndDim2Range ) )
else
	t.StartDim2Range3DLE:setText( "5.500" ) -- default value
	if SelectedSpec == nil then
		print("PpmRanges: No spectrum found")
	else
		StartRange,EndRange = SelectedSpec:getPpmRange( 2 )
		t.StartDim2Range3DLE:setText( string.format( "%3.3f", StartRange ) )
		t.EndDim2Range3DLE:setText( string.format( "%3.3f", EndRange ) )	
	end -- if Spectrum found
end

-- Display Label and LineEdit windows
t.StartDim2Range3DLELabel:show()
t.StartDim2Range3DLE:show()
-- Display Label and LineEdit windows
t.EndDim2Range3DLELabel:show()
t.EndDim2Range3DLE:show()

-- Create Label and Lineedit Box for Dim3 range
t.StartDim3Range3DLELabel = gui.createLabel( t.frm, "Starting Shift (dim 3): " )
t.StartDim3Range3DLE = gui.createLineEdit( t.frm )
t.EndDim3Range3DLELabel = gui.createLabel( t.frm, " Ending Shift (dim 3): " )
t.EndDim3Range3DLE = gui.createLineEdit( t.frm )

if Pick_3D_Peaks_StartDim3Range then -- determine if StartRes already exists
	t.StartDim3Range3DLE:setText( string.format( "%3.3f", Pick_3D_Peaks_StartDim3Range ) )
	t.EndDim3Range3DLE:setText( string.format( "%3.3f", Pick_3D_Peaks_EndDim3Range ) )
else
	t.StartDim3Range3DLE:setText( "5.500" ) -- default value
	if SelectedSpec == nil then
		print("PpmRanges: No spectrum found")
	else
		StartRange,EndRange = SelectedSpec:getPpmRange( 3 )
		t.StartDim3Range3DLE:setText( string.format( "%3.3f", StartRange ) )
		t.EndDim3Range3DLE:setText( string.format( "%3.3f", EndRange ) )	
	end -- if Spectrum found
end

-- Display Label and LineEdit windows
t.StartDim3Range3DLELabel:show()
t.StartDim3Range3DLE:show()
-- Display Label and LineEdit windows
t.EndDim3Range3DLELabel:show()
t.EndDim3Range3DLE:show()


-- END OF NEW CONTROL PANEL -----------------------------------------

--. OK and Cancel Buttons

t.okbutton = gui.createPushButton(t.frm, "OK" )
t.cancelbutton = gui.createPushButton( t.frm, "Cancel" )

t.okbutton:show()
t.cancelbutton:show()

-- ============Callbacks for menu window ===================

-- Define Callbacks for the buttons


-- cancel button Callback
t.cancelbutton:setCallback( gui.event.Clicked,
	function (self)
		v:close()
	end
)

-- OK button Callback =============================================================================BEGIN OK Button CALLBACK
t.okbutton:setCallback( gui.event.Clicked,
	function (self)
-- =============== Determine User Preferences ===========================
		t.P = cara:getProject( t.ProjectListCB:getCurrentText() )
		
-- Get PARAMETERS for 2D spectrum ---------------------------------------------------
		Pick_2D_Peaks_ProjectName = t.P:getName()
		Pick_2D_Peaks_SpectrumName = t.SpectrumListCB:getCurrentText()
		Pick_2D_Peaks_Threshhold = t.ThreshholdLE:getText() + 0
		Pick_2D_Peaks_StartDim1Range = t.StartDim1RangeLE:getText() + 0
		Pick_2D_Peaks_EndDim1Range = t.EndDim1RangeLE:getText() + 0
		Pick_2D_Peaks_StartDim2Range = t.StartDim2RangeLE:getText() + 0
		Pick_2D_Peaks_EndDim2Range = t.EndDim2RangeLE:getText() + 0
		
		dimension_1_lower_ppm_limit_1 = Pick_2D_Peaks_StartDim1Range;
		dimension_1_upper_ppm_limit_1 = Pick_2D_Peaks_EndDim1Range;
		dimension_2_lower_ppm_limit_1 = Pick_2D_Peaks_StartDim2Range;
		dimension_2_upper_ppm_limit_1 = Pick_2D_Peaks_EndDim2Range;
		threshold_1 = Pick_2D_Peaks_Threshhold

-- get SpectrumId from the selected SpectrumName
		for SpectrumId,Spectrum in pairs( t.P:getSpectra() ) do
			if Spectrum:getName() == Pick_2D_Peaks_SpectrumName then
				spectrum_1_ID = SpectrumId
			end
		end
-- error if SpectrumId is nil
if spectrum_1_ID == nil then
	error( " No valid spectrum selected. ")
end


-- Get PARAMETERS for 3D spectrum ---------------------------------------------------

		Pick_3D_Peaks_ProjectName = t.P:getName()
		Pick_3D_Peaks_SpectrumName = t.SpectrumList3DCB:getCurrentText()
		Pick_3D_Peaks_Threshhold = t.Threshhold3DLE:getText() + 0
		Pick_3D_Peaks_StartDim1Range = t.StartDim1Range3DLE:getText() + 0
		Pick_3D_Peaks_EndDim1Range = t.EndDim1Range3DLE:getText() + 0
		Pick_3D_Peaks_StartDim2Range = t.StartDim2Range3DLE:getText() + 0
		Pick_3D_Peaks_EndDim2Range = t.EndDim2Range3DLE:getText() + 0
		Pick_3D_Peaks_StartDim3Range = t.StartDim3Range3DLE:getText() + 0
		Pick_3D_Peaks_EndDim3Range = t.EndDim3Range3DLE:getText() + 0
		
		dimension_1_lower_ppm_limit_2 = Pick_3D_Peaks_StartDim1Range;
		dimension_1_upper_ppm_limit_2 = Pick_3D_Peaks_EndDim1Range;
		dimension_2_lower_ppm_limit_2 = Pick_3D_Peaks_StartDim2Range;
		dimension_2_upper_ppm_limit_2 = Pick_3D_Peaks_EndDim2Range;
		dimension_3_lower_ppm_limit_2 = Pick_3D_Peaks_StartDim3Range;
		dimension_3_upper_ppm_limit_2 = Pick_3D_Peaks_EndDim3Range;
		threshold_2 = Pick_3D_Peaks_Threshhold


-- get SpectrumId from the selected SpectrumName
		for SpectrumId,Spectrum in pairs( t.P:getSpectra() ) do
			if Spectrum:getName() == Pick_3D_Peaks_SpectrumName then
				spectrum_2_ID = SpectrumId
			end
		end
-- error if SpectrumId is nil
if spectrum_2_ID == nil then
	error( " No valid spectrum selected. ")
end


-- DONE GETTING INPUT PARAMETERS -------


--input_parameter_processing--------------------------------------------------------

upper=2;
lower=1;
spectrum_1=t.P:getSpectrum(spectrum_1_ID); 
num_of_dim_1=spectrum_1:getDimCount();
size_RA_1=initialize_size_RA(spectrum_1);
limit_RA_1=initialize_limit_RA(spectrum_1,nil,size_RA_1);

spectrum_2=t.P:getSpectrum(spectrum_2_ID); 


dimension_1_lower_point_limit_1=spectrum_1:getIndex(1,dimension_1_lower_ppm_limit_1);
dimension_1_upper_point_limit_1=spectrum_1:getIndex(1,dimension_1_upper_ppm_limit_1);
if(dimension_1_upper_point_limit_1&lt;dimension_1_lower_point_limit_1)then local temp=dimension_1_upper_point_limit_1;dimension_1_upper_point_limit_1=dimension_1_lower_point_limit_1;dimension_1_lower_point_limit_1=temp; end;
limit_RA_1[1].lower=dimension_1_lower_point_limit_1;limit_RA_1[1].upper=dimension_1_upper_point_limit_1;
--print(dimension_1_lower_point_limit_1.."    "..dimension_1_upper_point_limit_1);
dimension_2_lower_point_limit_1=spectrum_1:getIndex(2,dimension_2_lower_ppm_limit_1);
dimension_2_upper_point_limit_1=spectrum_1:getIndex(2,dimension_2_upper_ppm_limit_1);
if(dimension_2_upper_point_limit_1&lt;dimension_2_lower_point_limit_1)then local temp=dimension_2_upper_point_limit_1;dimension_2_upper_point_limit_1=dimension_2_lower_point_limit_1;dimension_2_lower_point_limit_1=temp; end;
limit_RA_1[2].lower=dimension_2_lower_point_limit_1;limit_RA_1[2].upper=dimension_2_upper_point_limit_1;
--print(dimension_2_lower_point_limit_1.."    "..dimension_2_upper_point_limit_1);


-----------------------------------------------------------------------------------
print_information_about_spectrum(spectrum_1);
--print_information_about_spectrum(spectrum_2);
if(print_spectral_information_only==0)then


--print("number_of_dimensions: "..spectrum:getDimCount());
--local temp_spectrum_RA={};
--temp_spectrum_RA=get_1D_from_spectrum(t.P:getSpectrum(13),nil,23);
--for x=1,length_of(temp_spectrum_RA)do print("x: "..x.."    "..temp_spectrum_RA[x]) end;
--closest_max_delta=get_local_max_delta_from_1D_RA(470,temp_spectrum_RA,40);
--print("closest_max_delta: "..closest_max_delta);
--local temp_peak_shape_RA={};
--temp_peak_shape_RA=get_peak_shape_from_1D_RA(temp_spectrum_RA,40);
--for x,y in pairs(temp_peak_shape_RA)do print("x: "..x.."    temp_peak_shape_RA[x]: "..y) end;

--local window_width_RA={40,40}
--local limit_RA={};
--peak_shape_RA=get_peak_shape_from_ND(spectrum,window_width_RA,0);
--for x,y in pairs(peak_shape_RA[1])do print("x: "..x.."    peak_shape_RA[1][x]: "..y) end;
--d1_peak_shape_RA=scale_RA(peak_shape_RA[1],1);
--for x,y in pairs(d1_peak_shape_RA)do print("x: "..x.."    d1_peak_shape_RA: "..d1_peak_shape_RA[x]) end;

--local peak_RA={};
--max_amplitude=get_max_average_highest_lowest_amplitude(spectrum);
--print("max_amplitude: "..max_amplitude);
--print("&gt;1");for x=1,length_of(temp_spectrum_RA) do print("temp_spectrum_RA: "..x.."    "..temp_spectrum_RA[x]) end;
--peak_RA=grow_peaks_into_1D_RA(temp_spectrum_RA,d1_peak_shape_RA,100,900);
--print("&gt;2");for x=1,length_of(temp_spectrum_RA) do print("temp_spectrum_RA: "..temp_spectrum_RA[x]) end;
--print("&gt;3");for x=1,length_of(peak_RA) do print("peak_RA: "..x.."    "..peak_RA[x]) end;
--identify_peaks_in_ND_spectrum(spectrum,peak_shape_RA);
--function pick_spin_systems_in_HSQC(spectrum,peak_shape_RA,threshold,input_limit_RA,mode,point_window_RA)
--pick_spin_systems_in_HSQC(spectrum_1,peak_shape_RA_1,threshold_1,limit_RA_1,peak_picking_mode_1,point_window_RA_1);

--print("testing transfer");
--local temp_position_RA={};
--temp_position_RA[1]=nil;
--temp_position_RA[2]=512;
--local temp_1D_spectrum_RA={};
--temp_1D_spectrum_RA=get_1D_from_spectrum(spectrum,nil,23);--local temp_2D_spectrum_RA={};
--transfer_1D_RA_to_ND_RA(temp_1D_spectrum_RA,temp_2D_spectrum_RA,2,temp_position_RA,10000);
--for x=1,1024 do for y=1,1024 do if(temp_2D_spectrum_RA[x])then if(temp_2D_spectrum_RA[x][y])then print("x: "..x.."    y: "..y.."    "..temp_2D_spectrum_RA[x][y]) end;end;end;end;

pick_spins_in_3D(spectrum_2,spectrum_1,threshold_2);

end    --if(print_spectral_information_only==0

v:close() -- close dialog window and execute peak-picking
end
) -- close Callback OK ====================================================================================END OK button CALLBACK
-- BEGIN of ProjectList Combobox CALLBACK ================================================================ BEGIN ProjectList Combobox CALLBACK
t.ProjectListCB:setCallback( gui.event.Activated,
	function (self)
		t.SpectrumListCB:clear()
		SelectedItemIndex = nil
		Proj = cara:getProject( t.ProjectListCB:getCurrentText() )
		if Proj then
			Pick_2D_Peaks_ProjectName = Proj:getName()
			for SpectrumID,Spectrum in pairs( Proj:getSpectra() ) do
				if Spectrum:getDimCount() == 2 then
					ItemIndex = t.SpectrumListCB:addItem( Spectrum:getName() )
					t.SpectrumListCB:setCurrentItem( ItemIndex )
				end -- if 2D spectrum
			end -- for all spectra in project
		else
			print("Callback ProjectList: No projects found")
		end -- if project exists
		t.SpectrumListLabel:show()
		t.SpectrumListCB:show()
	end -- function self
) -- close Callback ProjectListCB ========================================================================= END ProjectList Combobox CALLBACK

-- BEGIN SpectrumList (2D) Combobox CALLBACK ============================================================== BEGIN SpectrumList (2D) Combobox CALLBACK
t.SpectrumListCB:setCallback( gui.event.Activated,
	function (self)
--[[		t.StartDim1RangeLE:clear()
		t.EndDim1RangeLE:clear()
		t.StartDim2RangeLE:clear()
		t.EndDim2RangeLE:clear()
]]
		SelectedSpec = nil
		Proj = cara:getProject( t.ProjectListCB:getCurrentText() )
		if Proj then
			SpecName = t.SpectrumListCB:getCurrentText()
			if SpecName then
				for SpecId,Spec in pairs( Proj:getSpectra() ) do
					if Spec:getName() == SpecName then
						SelectedSpec = Spec
					end -- spectrum name matches selected spectrum name
				end -- all Spectra in Project
			end -- if SpecName selected
		end -- if Proj selected
		if SelectedSpec then
			print("Arrived at Callback SpectrumList: changing ppm ranges")
			-- store new spectrum name
			Pick_2D_Peaks_SpectrumName = t.SpectrumListCB:getCurrentText()
			dummy,ave_amplitude = get_max_average_highest_lowest_amplitude( SelectedSpec, 1000000 )
			t.ThreshholdLE:setText( string.format( "%i10", ave_amplitude*10 ) )

			Pick_2D_Peaks_Threshhold = 100000
			-- get PPM ranges of selected Spectrum
			StartRange,EndRange = SelectedSpec:getPpmRange( 1 )
			t.StartDim1RangeLE:setText( string.format( "%3.3f", StartRange ) )
			t.EndDim1RangeLE:setText( string.format( "%3.3f", EndRange ) )
			
			StartRange,EndRange = SelectedSpec:getPpmRange( 2 )
			t.StartDim2RangeLE:setText( string.format( "%3.3f", StartRange ) )
			t.EndDim2RangeLE:setText( string.format( "%3.3f", EndRange ) )
			
			Pick_2D_Peaks_StartDim1Range = t.StartDim1RangeLE:getText() + 0
			Pick_2D_Peaks_EndDim1Range = t.EndDim1RangeLE:getText() + 0
			Pick_2D_Peaks_StartDim2Range = t.StartDim2RangeLE:getText() + 0
			Pick_2D_Peaks_EndDim2Range = t.EndDim2RangeLE:getText() + 0
			
			dimension_1_lower_ppm_limit_1 = Pick_2D_Peaks_StartDim1Range;
			dimension_1_upper_ppm_limit_1 = Pick_2D_Peaks_EndDim1Range;
			dimension_2_lower_ppm_limit_1 = Pick_2D_Peaks_StartDim2Range;
			dimension_2_upper_ppm_limit_1 = Pick_2D_Peaks_EndDim2Range;
		end
	end -- function self
) -- close Callback SpectrumListCB ======================================================================= END SpectrumList (2D) Combobox CALLBACK

-- BEGIN SpectrumList3D Combobox CALLBACK ============================================================== BEGIN SpectrumList3D Combobox CALLBACK
t.SpectrumList3DCB:setCallback( gui.event.Activated,
	function (self)
--[[		t.StartDim1RangeLE:clear()
		t.EndDim1RangeLE:clear()
		t.StartDim2RangeLE:clear()
		t.EndDim2RangeLE:clear()
]]
		SelectedSpec = nil
		Proj = cara:getProject( t.ProjectListCB:getCurrentText() )
		if Proj then
			SpecName = t.SpectrumList3DCB:getCurrentText()
			if SpecName then
				for SpecId,Spec in pairs( Proj:getSpectra() ) do
					if Spec:getName() == SpecName then
						SelectedSpec = Spec
					end -- spectrum name matches selected spectrum name
				end -- all Spectra in Project
			end -- if SpecName selected
		end -- if Proj selected
		if SelectedSpec then
			print("Arrived at Callback SpectrumList3D: changing ppm ranges")
			-- store new spectrum name
			Pick_3D_Peaks_SpectrumName = t.SpectrumList3DCB:getCurrentText()
			dummy,ave_amplitude = get_max_average_highest_lowest_amplitude( SelectedSpec,1000000 )
			t.Threshhold3DLE:setText( string.format( "%i10", ave_amplitude*10 ) )

			Pick_3D_Peaks_Threshhold = 100000
			-- get PPM ranges of selected Spectrum
			StartRange,EndRange = SelectedSpec:getPpmRange( 1 )
			t.StartDim1Range3DLE:setText( string.format( "%3.3f", StartRange ) )
			t.EndDim1Range3DLE:setText( string.format( "%3.3f", EndRange ) )
			
			StartRange,EndRange = SelectedSpec:getPpmRange( 2 )
			t.StartDim2Range3DLE:setText( string.format( "%3.3f", StartRange ) )
			t.EndDim2Range3DLE:setText( string.format( "%3.3f", EndRange ) )
			
			StartRange,EndRange = SelectedSpec:getPpmRange( 3 )
			t.StartDim3Range3DLE:setText( string.format( "%3.3f", StartRange ) )
			t.EndDim3Range3DLE:setText( string.format( "%3.3f", EndRange ) )
			
			Pick_3D_Peaks_StartDim1Range = t.StartDim1Range3DLE:getText() + 0
			Pick_3D_Peaks_EndDim1Range = t.EndDim1Range3DLE:getText() + 0
			Pick_3D_Peaks_StartDim2Range = t.StartDim2Range3DLE:getText() + 0
			Pick_3D_Peaks_EndDim2Range = t.EndDim2Range3DLE:getText() + 0
			Pick_3D_Peaks_StartDim3Range = t.StartDim3Range3DLE:getText() + 0
			Pick_3D_Peaks_EndDim3Range = t.EndDim3Range3DLE:getText() + 0
			
			dimension_1_lower_ppm_limit_1 = Pick_3D_Peaks_StartDim1Range;
			dimension_1_upper_ppm_limit_1 = Pick_3D_Peaks_EndDim1Range;
			dimension_2_lower_ppm_limit_1 = Pick_3D_Peaks_StartDim2Range;
			dimension_2_upper_ppm_limit_1 = Pick_3D_Peaks_EndDim2Range;
			dimension_3_lower_ppm_limit_1 = Pick_3D_Peaks_StartDim3Range;
			dimension_3_upper_ppm_limit_1 = Pick_3D_Peaks_EndDim3Range;
		end
	end -- function self
) -- close Callback SpectrumListCB ======================================================================= END SpectrumList3D Combobox CALLBACK

</code>
<fld name='Creation Date' type='Date'>2006-6-7</fld>
</script>
<script name='RemoveAllSpins'>
<code lang='Lua'>-- a small script to remove all spins from a project.
-- Use cautiously! There is no undo!


t = {}
t.ProjectName = "MyProject"


t.P= cara:getProject( t.ProjectName )
for a,b in pairs( t.P:getSpins() ) do
	--t.P:unassignSpin( b )
	t.P:removeSpin( b )
end
</code>
<fld name='Creation Date' type='Date'>2006-6-7</fld>
</script>
<script name='CopyAliases'>
<code lang='Lua'>-- Script to transfer Alias shifts from one spectrum to another

-- F.Damberger 18.March.2004

-- Ver.2
-- F.Damberger 17.Oct.2005
-- modified:
-- If a spin alias exists in the target spectrum with the same shift as
-- a spin alias in the source spectrum, no alias is created.
-- This change was made because of a bug in CARA which deletes the alias
-- shift in the target spectrum.

--Options:
--         1. You can set t.Filter="YES" to only copy aliases for spins
--            with a specified label t.Label
--         2. You can set t.Overwrite="NO" to only overwrite shifts when
--            no alias exists for the targetspectrum.

-- WARNING: always back-up repository before executing script
-- To undo - use the script RemoveAliases.lua

-- create table for LUA script (all script variables are t.something)

t={}

-- Below are variables for User to modify:
-- ----------------------------------------------------------------
-- 1. The Project you want to modify aliases in:
         t.ProjectName="UP1"
-- 2. ID number of Spectrum to get Alias shifts from:
         t.SourceSpectrumId = "3"
-- 3. ID number of Spectrum to copy Alias shifts to:
         t.TargetSpectrumId = "26"
-- 4. Flag to turn ON/OFF filter for LABELS
         t.Filter="NO"
-- 5. Label of spins whose alias shifts are transferred
--    (optional: set filter = "YES" in step 4)
         t.Label = "N"
-- 6. Flag to overwrite possibly existing aliases
--    (optional: set to YES to force overwrite of existing aliases)
         t.Overwrite="NO"

-- ----------------------------------------------------------------

-- get Project

t.Project = cara:getProject( t.ProjectName )

-- get spectra
t.SourceSpectrum = t.Project:getSpectrum( t.SourceSpectrumId )
t.TargetSpectrum = t.Project:getSpectrum( t.TargetSpectrumId )

local i=0
t.SpinsTable=t.Project:getSpins()
for SpinId,Spin in pairs ( t.SpinsTable ) do
	if Spin:getShift( t.SourceSpectrum ) ~= Spin:getShift() then
		if not ( ( t.Overwrite=="NO" ) and ( Spin:getShift( t.TargetSpectrum )~= Spin:getShift() ) ) then
			if t.Filter=="YES" then
				if Spin:getLabel() == t.Label then
					--the following if is needed due to CARA bug
					if Spin:getShift( t.SourceSpectrum ) ~= Spin:getShift( t.TargetSpectrum ) then 
						t.Project:setShift( Spin, Spin:getShift( t.SourceSpectrum ), t.TargetSpectrum )
						i = i+1
					end
				end
			else
				--the following if is needed due to CARA bug
				if Spin:getShift( t.SourceSpectrum ) ~= Spin:getShift( t.TargetSpectrum ) then
					t.Project:setShift( Spin, Spin:getShift( t.SourceSpectrum ), t.TargetSpectrum )
					i = i+1
				end
			end -- if Filter == "YES"
		end -- if Overwrite
	end -- copy only if alias exists for SourceSpectrum
end -- for all Spins
if t.Filter == "YES" then print("Only copying spins with label "..t.Label..".") end
if t.Overwrite == "YES" then
	print("Overwriting existing aliases shifts in target spectrum.")
else
	print("Existing aliases in target spectrum are not changed.")
end

print("Copied "..i.." aliases")
print("CopyAliases is done")
--free up script variables
t = nil
</code>
<fld name='Author' type='String'></fld>
<fld name='Creation Date' type='Date'>2006-8-1</fld>
</script>
<script name='CopyAllProjectedSpinsToOriginSystem'>
<code lang='Lua'>-----------------------------------------------------------------------------------------
-- script to copy all projected spins (labels with nonzero offset N like X-N,X+N) of Spin System i-N,i+N
-- to the System i and changes the Spin Label to X

-- E.g. This allows the user to transfer the "projected" spins like "C-1" picked in an HNCO
-- from the system they were picked in (i-1) to the system they belong in (i: the successor system)
-- Ofcourse this only works if the predecessor has been linked to the system 

-- this script performs the action for ALL projected spins in the project
-- to perform this action for only selected spins, use CopyProjectedSpinsToOriginSystem.lua

-- There is also a script which will create the origin system if it does not exist yet.
-- CreateOriginSystemFromProjectedSpins.lua
-- E.g. if you assigned the CA-1,CB-1,CG-1 &amp; CD-1 resonances using a (H)C(CCO)NH in the system
-- following a Proline in the sequence, you can use this script to create a spin-system for the proline
-- containing the spins CA,CB,CG,CD which is linked to the successor system.

-- F. Damberger 1.Aug.2006

-- Version 1: 
-- F.Damberger August 1, 2006
-----------------------------------------------------------------------------------------
-- create temporary array for lua script
t={}



-- New interface

--1. Create main menu window

v = gui.createMainWindow()
v:setCaption( "Selection Dialog for CopyAllProjectedSpinsToOriginSystem" )
t.frm = gui.createGrid( v, 2, false )
v:setCentralWidget( t.frm )
v:show()
t.frm:show()

-- Define ProjectList Combobox and its Label
t.ProjectListLabel = gui.createLabel( t.frm, "Select Project" )
t.ProjectListCB = gui.createComboBox( t.frm )


--2. Read ProjectNames into ProjectList combobox

SelectedItemIndex = nil
for Id,Project in pairs( cara:getProjects() ) do
	ItemIndex = t.ProjectListCB:addItem( Project:getName() )
	t.ProjectListCB:setCurrentItem( ItemIndex )
	if CopyProjectedSpinsToOriginalSystem_ProjectName == t.ProjectListCB:getCurrentText() then
		SelectedItemIndex = ItemIndex
	end
end -- for all projects

if SelectedItemIndex then -- set to previous choice if it exists
	t.ProjectListCB:setCurrentItem( SelectedItemIndex )
end

-- Display ProjectList Combobox
t.ProjectListLabel:show()
t.ProjectListCB:show()


-- ================== END OF SELECTION DIALOG =============================


-- ================= Summary of action text =============================


-- ================= create control buttons =============================

t.okbutton = gui.createPushButton(t.frm, "OK" )
t.cancelbutton = gui.createPushButton( t.frm, "Cancel" )

t.okbutton:show()
t.cancelbutton:show()

-- ================= CALLBACKS for menu window ==========================


-- cancel button callback

t.cancelbutton:setCallback( gui.event.Clicked,
	function (self)
		v:close()
	end
) -- end cancelbutton callback

-- OK button Callback
t.okbutton:setCallback( gui.event.Clicked,
	function (self)


-- ================== Set the user preference variables ==================

-- get the project
for ProjId,Proj in pairs( cara:getProjects() ) do
	if Proj:getName() == t.ProjectListCB:getCurrentText() then
		t.P = Proj
	end
end
if t.P == nil then error("No valid project selected Aborting without any action.") end


-- ================== START CREATING SPINS ================================

i=0
for ResId,Res in pairs ( t.P:getSequence() ) do -- go through all residues
	for AtomId,Atom in pairs( Res:getAtoms() ) do
		LowestOffset = 1000 -- keep track of lowest offset, 1000 means no spins with nonzero offset found
		LowestOffsetSpin = nil -- reset the lowest offset spin to nil
		for ResId2,Res2 in pairs( t.P:getSequence() ) do -- look for a projected spin matching the current atoms label
			CurrentOffset = ResId2 - ResId
			Sys2 = Res2:getSystem()
			if Sys2 then -- Res2 is assigned
				for SpinId2,Spin2 in pairs( Sys2:getSpins() ) do
					Label2,Offset2,Dummy=dlg.decompose( Spin2:getlabel() )
					if AtomId == Label2 and CurrentOffset == Offset2 then -- found a projected spin
						if CurrentOffset &lt; LowestOffset then
							LowestOffset = CurrentOffset
							LowestOffsetSpin = Spin2
						end -- found a projected spin with lower offset
						
					end -- if projected spin is found
				end -- for all spins in Res2
			end -- if Res2 is assigned
		end -- for all resid in sequence, search for a projected spin which matches AtomId
		
		Sys = Res:getSystem()
		if Sys then
			for SpinId,Spin in pairs( t.P:getSpins() ) do
				Label,Offset,Something = dlg.decompose( Spin:getLabel() )
				if AtomId == Label then
					if Offset
				end
			end -- for all spins in system
				
		end -- if residue is assigned
	end -- for all atoms in residue
end -- for all residues

for SpinId,Spin in pairs( t.P:getSpins() ) do
--	if Spin:getLabel() == t.Label..t.Offset then           -- SELECT THE SPINS TO BE COPIED
		t.NeighborSysExists = false
		t.Offset = SpinOffset( Spin )
		if t.Offset ~= 0 then -- create origin spin
		
		if t.Offset &lt; 0 then
			Offset
			if Spin:getSystem() and Spin:getSystem():getPred() then
				t.NeighborSysExists = true
				t.NeighborSysSpins = Spin:getSystem():getPred():getSpins()
			end
		elseif t.Offset == "+1" then
			if Spin:getSystem() and Spin:getSystem():getSucc() then
				t.NeighborSysExists = true
				t.NeighborSysSpins = Spin:getSystem():getSucc():getSpins()
			end
		else
			error( "offset must be +1 or -1" )
		end
		if t.NeighborSysExists then	-- CHECK WHETHER newlabel ALREADY EXISTS
			
			t.NewLabelExists = false
			for NeighborSpinId,NeighborSpin in pairs( t.NeighborSysSpins ) do
				if NeighborSpin:getLabel() == t.Label  then
					t.NewLabelExists = true
				end
			end
			if not t.NewLabelExists then
				t.newspin = t.P:createSpin( Spin:getAtomType(), Spin:getShift() )
				i = i + 1
				if t.Offset == "-1" then
					t.P:assignSpin( t.newspin, Spin:getSystem():getPred() )
					print( "created spin "..t.Label.." in System "..Spin:getSystem():getPred():getId().." from spin "..t.Label..t.Offset.." in System "..Spin:getSystem():getId() )
				elseif t.Offset == "+1" then
					t.P:assignSpin( t.newspin, Spin:getSystem():getSucc() )
				else
					error( "offset must be +1 or -1" )
				end
				t.P:setLabel( t.newspin, t.Label )	  -- SELECT THE NEW SPINLABEL (must exist already in the repository)
			end
		end
		end -- if spin has nonzero offset
	--end (select all spins)
end -- for all spins
print("\n-------- copied "..i.." "..t.Label..t.Offset.." to "..t.Label.." of i"..t.Offset.." neighbor. --------")
print( "\nCopyProjectedSpinsToOriginalSystem is finished" )
--free up script variables
-- t = nil
	v:close()
	end
) -- end okbutton callback


</code>
<fld name='Creation Date' type='Date'>2006-8-1</fld>
</script>
<script name='TransferAssignments'>
<code lang='Lua'>-- script to transfer assignments from a source project to a target project

-- spins are created in the target project if they are assigned in the source
-- project and there is a corresponding atom for the corresponding residue
-- in the target project

-- F.Damberger Nov 3 2006.

-- Version 1: Feb.22.2005 F.Damberger



-- ----------------------------------------------------------------------


-- create array for script variables
t = {}



-- ----------------------------------------------------------------------

-- =================== Define Functions =================================


function TableSize( Table )
	local Size = 0
	for IdNum,Entry in pairs( Table ) do
		Size = Size + 1
	end -- for
	return Size
end -- function TableSize


function AtomNameFromResType( Label, ResType )  -- added in ver.7
	-- purpose: return true if label occurs in ResType
	local result = nil
	for AtomName,Atom in pairs( ResType:getAtoms() ) do
		if Label == AtomName then
			result = true
		end
	end -- for all atoms in ResType
	return result
end -- function AtomNameFromResType

function CreateProjectNamesComboBox( SelectedProjectName )
	ProjectNamesComboBox = gui.createComboBox( t.frm )
	SelectedItemIndex = nil
	for Id,Project in pairs( cara:getProjects() ) do
		ItemIndex = ProjectNamesComboBox:addItem( Project:getName() )
		ProjectNamesComboBox:setCurrentItem( ItemIndex )
		if SelectedProjectName == ProjectNamesComboBox:getCurrentText() then
			SelectedItemIndex = ItemIndex
		end
	end -- for all projects
	if SelectedItemIndex then -- set to previous choice if it exists
	ProjectNamesComboBox:setCurrentItem( SelectedItemIndex )
	return ProjectNamesComboBox
end

end -- function LoadProjectNamesToComboBox

--===================END OF FUNCTION DEFINITIONS ========================


-- ================== SOME PARAMETER DEFINITIONS ========================

AssignmentReport_BackboneLabels = { "HN", "H", "N", "C", "CA", "HA", "HA1", "HA2", "HA3" } -- I include both XEASY and IUPAC nomenclature
AssignmentReport_TripleLabels = { "HN", "H", "N", "C", "CA", "CB" } -- I include both XEASY and IUPAC nomenclature

-- Define BackboneLabelsText
BackboneLabelsText = "Backbone Labels : "
for Index,CurrentLabel in pairs( AssignmentReport_BackboneLabels ) do
	BackboneLabelsText = BackboneLabelsText.." "..CurrentLabel
end -- for all Labels in BackboneLabels Table

-- Define TripleLabelsText
TripleLabelsText = "Triple Resonance Labels : "
for Index,CurrentLabel in pairs( AssignmentReport_TripleLabels ) do
	TripleLabelsText = TripleLabelsText.." "..CurrentLabel
end -- for all Labels in TripleLabels Table


-- ============Set up menu window for user preferences===================

--0. Check whether there are any projects available
ProjectsTable = cara:getProjects()

if TableSize( ProjectsTable ) == 0 then error("No projects found in repository") end


--1. Create main menu window

v = gui.createMainWindow()
v:setCaption( "AssignmentReport Preferences" )
t.frm = gui.createGrid( v, 2, false )
v:setCentralWidget( t.frm )
v:show()
t.frm:show()

-- SourceProject Selector
t.SourceProjectListLabel = gui.createLabel( t.frm, "Select Source Project( where assignments come from" )
t.SourceProjectListCB = CreateProjectNamesComboBox( SourceProjectName )

-- TargetProject Selector
t.TargetProjectListLabel = gui.createLabel( t.frm, "Select Target Project( where assignments go to" )
t.TargetProjectListCB = CreateProjectNamesComboBox( TargetProjectName )

-- Display SourceProjectList Combobox
t.SourceProjectListLabel:show()
t.SourceProjectListCB:show()

-- Display TargetProjectList Combobox
t.TargetProjectListLabel:show()
t.TargetProjectListCB:show()



--5. Read AtomTypesToInclude choices into AtomTypesToInclude combobox ---------------

-- Create Label and Combobox for AtomTypesToInclude
t.AtomTypesToIncludeCBLabel = gui.createLabel( t.frm, "Select AtomTypes to include" )
t.AtomTypesToIncludeCB = gui.createComboBox( t.frm )

SelectedItemIndex = nil
-- Add Item "H atoms only" to Combobox
ItemIndex = t.AtomTypesToIncludeCB:addItem( "H atoms only" )
t.AtomTypesToIncludeCB:setCurrentItem( ItemIndex )
if AssignmentReportAtomTypesToInclude == t.AtomTypesToIncludeCB:getCurrentText() then
	SelectedItemIndex = ItemIndex
end

-- Add Item "all atoms" to Combobox
ItemIndex = t.AtomTypesToIncludeCB:addItem( "all atoms" )
t.AtomTypesToIncludeCB:setCurrentItem( ItemIndex )
if AssignmentReportAtomTypesToInclude == t.AtomTypesToIncludeCB:getCurrentText() then
	SelectedItemIndex = ItemIndex
end

if SelectedItemIndex then -- determine if selected previously
	t.AtomTypesToIncludeCB:setCurrentItem( SelectedItemIndex )
end

-- Display Label and Combobox
t.AtomTypesToIncludeCBLabel:show()
t.AtomTypesToIncludeCB:show()

-- Checkboxes follow ------------------------------------------


--6. Checkbox IncludeAssignedSpins

t.TransferOnlyAssignedSpins_ChBxLabel = gui.createLabel( t.frm, "Transfer only assigned atoms" )
t.TransferOnlyAssignedSpins_ChBx = gui.createCheckBox( t.frm )

if TransferOnlyAssignedSpins == "YES" then
	t.TransferOnlyAssignedSpins_ChBx:setChecked()
end

t.TransferOnlyAssignedSpins_ChBxLabel:show()
t.TransferOnlyAssignedSpins_ChBx:show()


--9. OK and Cancel Buttons

t.okbutton = gui.createPushButton(t.frm, "OK" )
t.cancelbutton = gui.createPushButton( t.frm, "Cancel" )

t.okbutton:show()
t.cancelbutton:show()


-- ============Callbacks for menu window ===================

-- Define Callbacks for the buttons


-- cancel button Callback
t.cancelbutton:setCallback( gui.event.Clicked,
	function (self)
		v:close()
	end
) -- end cancel button Callback

-- OK button Callback
t.okbutton:setCallback( gui.event.Clicked,
	function (self)
-- =============== Determine User Preferences ===========================

		t.SourceProject = cara:getProject( t.SourceProjectListCB:getCurrentText() )
		SourceProjectName = t.P:getName()
		
		-- get Checkbox status
		if t.TransferOnlyAssignedSpins_ChBx:isChecked() then
			TransferOnlyAssignedSpins = "YES"
		else
			TransferOnlyAssignedSpins = "NO"
		end

-- ============== Run analysis ===========================================
-- cycle through all residues and report missing assignments

		t.Seq = t.P:getSequence()
		-- create a system assigned to each residue in the target sequence
		

		SourceSpins = t.SourceProject:getSpins()
		
		for SpinId,Spin in pairs( SourceSpins ) do
				if TransferOnlyAssignedSpins == "YES" then -- check if spin should be transferred
					-- check if spin  is assigned in SourceProject
					-- check if spin can be assigned to atom with same label in TargetProject
					-- if checks Ok then
					--   create spin in target project
					--   assign it to system
				else
					-- create spin in target project
					-- assign it to system if it was in a system
				end
		end -- for all spins
--		for ResNum,Res in pairs( t.Seq ) do -- LUA does not output in sequential order using this

--[[
		for Indx = 1,table.getn( SortedIndex ) do
			ResNum = SortedIndex[ Indx ]
			Res = t.Seq[ SortedIndex[ Indx ] ]
			
			t.Assigned = " "
			t.Unassigned = " "
			t.PseudoAtomConflicts = " "
			t.Res = t.P:getResidue( ResNum )
			t.Typ = t.Res:getType()
			t.Name = t.Typ:getShort()
			t.Atoms = t.Typ:getAtoms()
			t.Sys = t.Res:getSystem()
			num_outliers = 0
			CountUnassigned = 0
			NumAssignedForRes = 0
			NumUnassignedForRes = 0
			NumPseudoAtomConflicts = 0
		
			for AtomId,Atom in pairs( t.Atoms ) do			
				SpinAssigned = false
				
				-- Determine whether this Atom should be included in report
				
				t.ReportThisAtom = "false"
				if AssignmentReportAtomTypesToInclude == "H atoms only" then
					if Atom:getAtomType() == "H" then
						if ReportOnlyHatomsAttatchedToCorN == "YES" then
							if CorNatomIsAttatched( Atom ) then
								t.ReportThisAtom = "true"
							end
						else -- report all H atoms
							t.ReportThisAtom = "true"
						end -- if ReportOnlyHatomsAttatchedToCorN
					end -- if AtomType = "H"
				elseif AssignmentReportAtomTypesToInclude == "all atoms" then
					if Atom:getAtomType() ~= "O" and Atom:getAtomType() ~= "S" then
						if Atom:getAtomType() == "H" then
							if ReportOnlyHatomsAttatchedToCorN == "YES" then
								if CorNatomIsAttatched( Atom) then
									t.ReportThisAtom = "true"
								end
							else -- report all H atoms
								t.ReportThisAtom = "true"
							end -- if t.ReportOnlyHatomsAttatchedToCorN2
						else -- atom is not H
							if ReportOnlyHeteroAtomsAttatchedToH == "YES" then
								if HatomIsAttatched( Atom ) then
									t.ReportThisAtom = "true"
								end
							else -- report all HeteroAtoms
								t.ReportThisAtom = "true"
							end --if AttatchedHeteroAtomIsCorN
						end -- if AtomType == "H"
					end -- if AtomType is not O or S
				else -- AssignmentReportAtomTypesToInclude does not match one of the available choices
						t.ReportThisAtom = "false"
				end
				
				-- Determine whether the atom is assigned or not
					
				if t.ReportThisAtom == "true" then
					t.AtomName = Atom:getName()
					local AtomNameForm = string.format( "%5s", t.AtomName )
					if Atom:getGroup() ~= nil then -- get Group and GroupName (PseudoAtoms)
						t.Group = Atom:getGroup()
						t.GroupName = Atom:getGroup():getName()
					else
						t.Group = nil
						t.GroupName = nil
					end
					if t.Sys then
						for SpinId,Spin in pairs( t.Sys:getSpins() ) do
							if ( t.AtomName == Spin:getLabel() or t.GroupName == Spin:getLabel() ) then -- Spin's label matches the AtomName or it's GroupName then it's assigned
								SpinAssigned = true
								--NumAssignedForRes = NumAssignedForRes + 1
								if t.GroupName == Spin:getLabel() then
									IsPseudoAtom = true
									--print("pseudo:"..t.Name..ResNum.." "..Spin:getLabel() )
								else
									IsPseudoAtom = false
								end
								if IncludeOutliers == "YES" then
								-- compare chemical shifts &amp; write into t.Outliers if needed
									t.LibraryAve,t.LibrarySd = t.Res:getValue( Atom:getName() )
									t.LibrarySd = ( AssignmentReport_SDmult / SDmult_Repository ) * t.LibrarySd
									t.Shift = Spin:getShift()
									t.Dev = t.Shift - t.LibraryAve
									-- Keep track of average deviation for sidechain shifts of atom types H,C,N
									if Atom:getAtomType() == "H" then -- track H atom average dev
										t.DevH_number = t.DevH_number + 1
										t.DevH_total = t.DevH_total + t.Dev
										if SideChainAromatic( Res, t.AtomName ) then -- aromatic sidechain
											t.DevHaro_number = t.DevHaro_number + 1
											t.DevHaro_total = t.DevHaro_total + t.Dev
										else
											t.DevHali_number = t.DevHali_number + 1
											t.DevHali_total = t.DevHali_total + t.Dev
										end
									elseif Atom:getAtomType() == "C" then -- track C atom average dev
										t.DevC_number = t.DevC_number + 1
										t.DevC_total = t.DevC_total + t.Dev
										if not SideChainAromatic( Res, t.AtomName ) then -- aliphatic sidechain
											t.DevCali_number = t.DevCali_number + 1
											t.DevCali_total = t.DevCali_total + t.Dev
										else -- is sidechain aromatic
											t.DevCaro_number = t.DevCaro_number + 1
											t.DevCaro_total = t.DevCaro_total + t.Dev
										end
									elseif Atom:getAtomType() == "N" then -- track N atom average dev
										t.DevN_number = t.DevN_number + 1
										t.DevN_total = t.DevN_total + t.Dev
										if not SideChainAromatic( Res, t.AtomName ) then -- aliphatic sidechain
											t.DevNali_number = t.DevNali_number + 1
											t.DevNali_total = t.DevNali_total + t.Dev
										end
									end
									
									-- Check whether shift is unusual
									if t.Dev &gt; t.LibrarySd or t.Dev &lt; -1 * t.LibrarySd then
										-- count total number of outliers
										num_outliers = num_outliers + 1
										if Atom:getAtomType() == "H" then
											H_outliers = H_outliers + 1
											if IsAromaticAtom( Atom, t.Name ) then
												Haro_outliers = Haro_outliers + 1
											else
												Hali_outliers = Hali_outliers + 1
											end
										elseif Atom:getAtomType() =="C" then
											C_outliers = C_outliers + 1
											if IsAromaticAtom( Atom, t.Name ) then
												Caro_outliers = Caro_outliers + 1
											else
												Cali_outliers = Cali_outliers + 1
											end
										elseif Atom:getAtomType() == "N" then
											N_outliers = N_outliers + 1
										end
										if BackboneLabel( t.AtomName, AssignmentReport_BackboneLabels ) then
											BB_outliers = BB_outliers + 1
										else
											SC_outliers = SC_outliers + 1
										end
										-- format the numbers
										t.LibraryAve = string.format( "%7.3f", t.LibraryAve )
										t.LibrarySd = string.format( "%4.3f", t.LibrarySd )
										t.Shift = string.format("%7.3f", t.Shift )
										t.Dev = string.format("%10.3f", t.Dev )
										if num_outliers == 1 then -- write header for outlier report
											if t.OutlierSummary == nil then
												t.OutlierSummary = "\n"
											end --- if first Outlier in the sequence
											t.Outliers = "Unusual Shifts:\n"
											Formatted_SDmult = string.format( "%3.1f", AssignmentReport_SDmult )
											t.Outliers = t.Outliers.." Atom     Shift   Average   Difference   SD*"..Formatted_SDmult.."\n"
											local ResWithOutlier = string.format( "%5s", t.Typ:getLetter()..ResNum )
											t.OutlierSummary = t.OutlierSummary.." "..ResWithOutlier
											NumResWithOutliers = NumResWithOutliers + 1
											CountResWithOutliers = CountResWithOutliers + 1
											if CountResWithOutliers &gt; 9 then -- add a line break every 10 residues
												t.OutlierSummary = t.OutlierSummary.."\n"
												CountResWithOutliers = 0 -- reset counter
											end
										end -- if 1st outlier in the residue
										t.Outliers = t.Outliers..AtomNameForm.."   "..t.Shift.."   "..t.LibraryAve.."   "..t.Dev.."   "..t.LibrarySd.."\n"
										
									end -- if Outlier found
								end -- if outlier report requested
							end -- if spin matches atom, then SpinAssigned
						end -- searched through all spins in system
					end -- if t.Sys
					if SpinAssigned == false then -- missing assignment
						CountUnassigned = CountUnassigned + 1
						t.Unassigned = t.Unassigned.." "..AtomNameForm
						if CountUnassigned &gt; 6 then
							t.Unassigned = t.Unassigned.."\n             "
							CountUnassigned = 0
						end
						if Atom:getAtomType() == "H" then
							NumHmissing = NumHmissing + 1
							if IsAromaticAtom( Atom, t.Name ) then
								NumHAROmissing = NumHAROmissing + 1
							else
								NumHALImissing = NumHALImissing + 1
							end
						end
						if Atom:getAtomType() == "C" then
							NumCmissing = NumCmissing + 1
							if IsAromaticAtom( Atom, t.Name ) then
								NumCAROmissing = NumCAROmissing + 1
							else
								NumCALImissing = NumCALImissing + 1
							end
						end
						if Atom:getAtomType() == "N" then NumNmissing = NumNmissing + 1 end
						if BackboneLabel( t.AtomName, AssignmentReport_BackboneLabels ) then
							NumBBmissing = NumBBmissing + 1
						else
							NumSCmissing = NumSCmissing + 1
						end
						if IsOfClass( Atom, "Triple" ) then NumTRIPLEmissing = NumTRIPLEmissing + 1 end
						if IsAromaticAtom( Atom, t.Name ) then NumAROmissing = NumAROmissing + 1 end
						NumUnassignedForRes = NumUnassignedForRes + 1
	
					else -- found assignment
						t.Assigned = t.Assigned.." "..Atom:getName()
						if Atom:getAtomType() == "H" then
							NumHfound = NumHfound + 1
							if IsAromaticAtom( Atom, t.Name ) then
								NumHAROfound = NumHAROfound + 1
							else
								NumHALIfound = NumHALIfound + 1
							end
						end
						if Atom:getAtomType() == "C" then
							NumCfound = NumCfound + 1
							if IsAromaticAtom( Atom, t.Name ) then
								NumCAROfound = NumCAROfound + 1
							else
								NumCALIfound = NumCALIfound + 1
							end
						end
						if Atom:getAtomType() == "N" then NumNfound = NumNfound + 1 end
						if BackboneLabel( t.AtomName, AssignmentReport_BackboneLabels ) then
							NumBBfound = NumBBfound + 1
						else
							NumSCfound = NumSCfound + 1
						end
						NumAssignedForRes = NumAssignedForRes + 1
						NumAssignedIntTotal = NumAssignedInTotal + 1
]]
		v:close()
	end
) -- end OK button Callback

-- End of script FD.






</code>
<fld name='Creation Date' type='Date'>2006-11-6</fld>
</script>
<script name='CreateOriginSystemsFromProjectedSpins-v3'>
<code lang='Lua'>-- CreateOriginSystemsFromProjectedSpins.lua

-- Script to copy projected spins (offset -1) into origin system.
-- If the origin system does not exist it is created and linked to the successor

-- purpose: To transfer assignments like HA-1 and CA-1 obtained from H(CCCO)NH
--          and (H)C(CCO)NH respectively to the origin system
--          If the predecessor system i-1 is missing, it is created and linked to
--          the successor i.

--          script also reports in mismatches between existing projected and origin
--          spins i-1 and i.

-- NOTE: This script should only be run at the end of a project to transfer
--       remaining projected spins to origin system. After you run this script,
--       All systems with projected spins will have a linked partner!

-- version 1 created by F.Damberger   Oct.11 2006

-- version 2 modified by F.Damberger Nov.16 2006
--          to force final labels in origin system if there are tentative labels
--           e.g. if CA-1 exists in a system and the predecessor system contains spins with
--                label ?CA then these are renamed to ? and the CA-1 spin is copied into the
--                predecessor system with the label CA.
--                In version 1, the script would stop with an error message "Inacceptable spin label"

-- create temporary array for lua script
t={}

-- ==== FIXED PARAMETERS (USER can edit these) =====================================

 -- WARN user if matching spins X and X-1 have difference in shift larger than this
Threshhold_H = 0.03 -- threshhold for H spins
Threshhold_X = 0.4 -- threshhold for heterospins (non-H)

--===== END OF FIXED PARAMETERS =========
-- ============================ DEFINE FUNCTIONS ===================================


function SysContainsProjectedSpins( Sys )
	Result = false
	for SpinIdLocal,SpinLocal in pairs( Sys:getSpins() ) do
		local Label,Offset,State = spec.decomposeLabel( SpinLocal:getLabel() )
		if Offset == -1 then
			Result = true
		end
	end -- for spins in system
	return Result
end -- function SysContainsProjectedSpins

function MakeOriginSpin( Spin, PredSys, Sys ) -- checks if originSpin exists, reports mismatches, creates origin spin if nonexistent
	OriginSpinExists = false
	Result = false --returns true if origin spin is created
	local LabelSpin,OffsetSpin,StateSpin = spec.decomposeLabel( Spin:getLabel() )
	SpinShift = Spin:getShift()
	AtomTypeSpin = Spin:getAtomType()
	
	if AtomTypeSpin == "H" then -- set threshhold for mismatch of shifts to value for H or non-H
		Threshhold = Threshhold_H
	else
		Threshhold = Threshhold_X
	end
	
	for SpinIdPred,SpinPred in pairs( PredSys:getSpins() ) do
			local LabelPred,OffsetPred,StatePred = spec.decomposeLabel( SpinPred:getLabel() )
			if LabelPred == LabelSpin and OffsetPred == 0 and OffsetSpin == -1 then
			-- found Predecessor Spin matching projected Spin 
				if StateSpin &gt; StatePred then -- new spins state takes precedence
					-- set label of PredSpin to ? to make room for new spin
					print("Relabeling spin"..SpinPred:getLabel().." to ? to make room for spin"..Spin:getLabel() )
					t.P:setLabel( SpinPred, "?" )
				elseif StatePred == StateSpin then
				-- this origin spin of PredSys matches projected spin of Sys
					--print("Predecessor Spin"..LabelPred.." matches spin"..LabelSpin )
					OriginSpinExists = true
					MatchingPredSpin = SpinPred
				end -- if StatePred matches StateSpin
			end -- if match found
	end -- for all spins in Pred System
	
	if OriginSpinExists then
		PredShift = MatchingPredSpin:getShift()
		if math.abs( SpinShift - PredShift ) &gt; Threshhold then
			print( "Found mismatched chemical shifts: " )
			print( PredSys:getResidue():getType():getShort().." "..PredSys:getResidue():getId().." "..MatchingPredSpin:getLabel().."   : "..string.format( "%3.2f", PredShift ).." ppm" )
			print(     Sys:getResidue():getType():getShort().." "..Sys:getResidue():getId().." "..Spin:getLabel().." : "..string.format( "%3.2f", Spin:getShift() ).." ppm" )
			NumMismatchedSpins = NumMismatchedSpins + 1
		end -- if mismatch report it
	else -- create matching spin in predecessor system
		Result = true
		OriginSpinLabel = spec.composeLabel( LabelSpin, 0, StateSpin ) -- generate origin spins label (it has same label as Spin but offset is 0)
		OriginSpin = t.P:createSpin( AtomTypeSpin, SpinShift ) -- create origin spin
		t.P:assignSpin( OriginSpin, PredSys ) -- assign origin spin
		t.P:setLabel( OriginSpin, OriginSpinLabel ) -- label origin spin
		print("Created new spin: System="..PredSys:getId().." Label="..OriginSpinLabel )
	end -- if OriginSpinExists
	return Result -- true if OriginSpinCreated
end -- function MakeOriginSpins

-- =============== END OF FUNCTION DEFINITIONS =============



-- New interface

--1. Create main menu window

v = gui.createMainWindow()
v:setCaption( "Selection Dialog for Pick_2D_Peaks" )
t.frm = gui.createGrid( v, 2, false )
v:setCentralWidget( t.frm )
v:show()
t.frm:show()

-- Define ProjectList Combobox and its Label
t.ProjectListLabel = gui.createLabel( t.frm, "Select Project" )
t.ProjectListCB = gui.createComboBox( t.frm )


--2. Read ProjectNames into ProjectList combobox

SelectedItemIndex = nil
for Id,Project in pairs( cara:getProjects() ) do
	ItemIndex = t.ProjectListCB:addItem( Project:getName() )
	t.ProjectListCB:setCurrentItem( ItemIndex )
	if CopyProjectedSpinsToOriginalSystem_ProjectName == t.ProjectListCB:getCurrentText() then
		SelectedItemIndex = ItemIndex
	end
end -- for all projects

if SelectedItemIndex then -- set to previous choice if it exists
	t.ProjectListCB:setCurrentItem( SelectedItemIndex )
end

-- Display ProjectList Combobox
t.ProjectListLabel:show()
t.ProjectListCB:show()

--3. Proline Checkbox

t.ProlinePredecessorsOnly_ChBxLabel = gui.createLabel( t.frm, "Create only new SpinSystems if they are Proline" )
t.ProlinePredecessorsOnly_ChBx = gui.createCheckBox( t.frm )

if ProlinePredecessorsOnly == "YES" or ProlinePredecessorsOnly == nil then
	t.ProlinePredecessorsOnly_ChBx:setChecked()
end

t.ProlinePredecessorsOnly_ChBxLabel:show()
t.ProlinePredecessorsOnly_ChBx:show()

-- ================== END OF SELECTION DIALOG =============================

-- ================= create control buttons =============================

t.okbutton = gui.createPushButton(t.frm, "OK" )
t.cancelbutton = gui.createPushButton( t.frm, "Cancel" )

t.okbutton:show()
t.cancelbutton:show()

-- ================= CALLBACKS for menu window ==========================

-- cancel button callback

t.cancelbutton:setCallback( gui.event.Clicked,
	function (self)
		v:close()
	end
) -- end cancelbutton callback

-- OK button Callback
t.okbutton:setCallback( gui.event.Clicked,
	function (self)
		t.P = cara:getProject( t.ProjectListCB:getCurrentText() )
		CopyProjectedSpinsToOriginalSystem_ProjectName = t.P:getName()
		
		if t.ProlinePredecessorsOnly_ChBx:isChecked() then
			ProlinePredecessorsOnly = "YES"
		else
			ProlinePredecessorsOnly = "NO"
		end


-- ================== Set the user preference variables ==================

-- get the project
for ProjId,Proj in pairs( cara:getProjects() ) do
	if Proj:getName() == t.ProjectListCB:getCurrentText() then
		t.P = Proj
	end
end
if t.P == nil then error("No valid project selected Aborting without any action.") end
-- ================== START CREATING SPINS ================================
NumMismatchedSpins = 0
NumPredSysAdded = 0
NumOriginSpinsCreated = 0
t.Seq = t.P:getSequence()
for ResId,Res in pairs( t.Seq ) do
	--print( "=== Residue = "..Res:getType():getShort().." "..Res:getId().." =====" ) -- report each residue
	t.Sys = Res:getSystem()
	if t.Sys then
		if SysContainsProjectedSpins( t.Sys ) then
			PredRes = Res:getPred()
			if PredRes then
				PredSys = PredRes:getSystem()

				--Determine if this residue should be done
				DoResidue = false
				if ProlinePredecessorsOnly == "YES" then
					if PredRes:getType():getShort() == "PRO" then
						DoResidue = true
					end -- if PredSys is PRO
				else
					DoResidue = true -- do every Res if ProlinePredecessorsOnly option is NOT selected
				end -- if ProlinePredecessorsOnly option is selected

				if DoResidue then
					if PredSys == nil then -- Predecessor System does not exist
						PredSys = t.P:createSystem() -- create new system for predecessor
						print("Created new system "..PredSys:getId().." linked to successor residue "..Res:getType():getShort()..ResId )
						t.P:linkSystems( PredSys, t.Sys ) -- link Predecessor system to t.Sys
						NumPredSysAdded = NumPredSysAdded + 1
					end -- if PredSys exists
					for SpinId,Spin in pairs( t.Sys:getSpins() ) do
						Label,Offset,State = spec.decomposeLabel( Spin:getLabel() )
						if Offset == -1 and State &gt; 0 then -- projected spin and not a draft label (not ?label)
							if MakeOriginSpin( Spin, PredSys, t.Sys ) then -- checks if originSpin exists, reports mismatches, creates origin spin if it is nonexistent
								NumOriginSpinsCreated = NumOriginSpinsCreated + 1
							end -- if MakeOriginSpin
						end -- if projected spin
					
					end -- for all spins in t.Sys
				end -- if DoResidue
				
			end -- if PredRes exists
		end -- if SysContainsProjectedSpins
	end -- if t.Sys exists
end -- for all residues in sequence

-- Summarize results --
print()
print("==== report of new spins and systems ====")
print()
print( "Created "..NumPredSysAdded.." new systems linked to successor." )
print( "Created "..NumOriginSpinsCreated.." new origin spins (e.g. CA-1 -&gt; CA)" )

print()
print("======= mismatch report =======")
print()
print( "Found "..NumMismatchedSpins.." with a shift mismatch &gt; threshhold" )
print( "(e.g. shift(CA) - shift(CA-1) = mismatch " )
print( "Where threshhold for H-spins is "..Threshhold_H )
print( "and threshhold for non H-spins is "..Threshhold_X )
print( "\nCopyProjectedSpinsToOriginalSystem is finished" )
--free up script variables
-- t = nil
	v:close()
	end
) -- end okbutton callback


</code>
<fld name='Creation Date' type='Date'>2010-6-29</fld>
</script>
<script name='WriteAssignments'>
<code lang='Lua'>-- WriteAssignments.lua
-- script to write out chemical shifts in several formats:
-- NMR-STAR 2.1 file for deposition of chemical shifts in the BMRB: www.bmrb.wisc.edu
-- DYANA/CYANA-1.0 format for structure calculations (.prot + .seq files)
-- CYANA-2.0/2.1 format for structure calculation (.prot + .seq files)

-- This script has been successfully used for deposition of data to the BMRB and for structure calculations
-- using both DYANA/CYANA-1.0 and CYANA-2.0 in the Wuthrich Group.
-- Please report any problems to F.Damberger at the CARA website: www.cara.ethz.ch

-- It is advised to run AssignmentReport.lua before this script
-- and to fix any problems identified there before using this script.

-- Explanation of the options:
-- 1. Select Project: project from which the shifts are obtained.
-- 2. Select Spectrum : if you select a spectrum, the alias shifts from this spectrum will be used, otherwise the default shifts.
-- 3. Select Resonance Class: You can write out a subset of all assigned resonances (e.g. only Backbone shifts)
-- 4. Output sent to: Send either to "Terminal" window or to "File" in the starting directory of CARA.
-- 5. filename: prefix of the filename where data is written:
-- 6. All CYS Ox: if checked, the .seq file will have CYS named "CYSS"
-- 7. select output format: BMRB (for submission to BMRB in NMR-STAR 2.1 format)  filename.str
--                          DYANA (for DYANA or CYANA-1.0 structure calculation)  filename.prot, filename.seq
--                          CYANA 2.0/2.1 (for CYANA-2.0 or -2.1 structure calculation) filename.prot, filename.seq
-- 8. Enter error in H1 shifts: Error in H1 shifts appearing in the .str or .prot files
-- 9. Enter error in C13 shifts: Error in C13 shifts appearing in the .str or .prot files
--10. Enter error in N15 shifts: Error in N15 shifts appearing in the .str or .prot files
--11. Enter error in other shifts: Error in shifts of other nuclei appearing in the .str or .prot files
--
-- Some details on the three formats:

-- NMR-STAR 2.1: Pseudoatom assignments (Groups) are split into the separate lines, one for each atom
--               e.g. if you have a degenerate HB in ASN 10: two lines are written with ambiguity code 1:
--        41   10   ASN  HB2   H   2.912 0.020   1    
--        42   10   ASN  HB3   H   2.912 0.020   1    

--               ambiguity codes are set based on rules described at BMRB.
--               If you have stereoassigned a prochiral pair,
--               you must indicate this by preceeding the spins labels with "!": 
--               e.g. for two HB protons of ASN: "!HB2! &amp;"!HB3"
--               e.g. for the two methyl groups of a VAL: "!HG1" &amp; "!HG2".

-- DYANA/CYANA formats: always writes out both a .prot file and a .seq file
--                       pseudoatom (AtomGroups) are written with the starting H replaced by Q
--                       e.g. ALA HB  -&gt; ALA QB
--                            VAL HG1 -&gt; VAL QG1 , VAL HG -&gt; VAL QQG
--                       All CYS are renamed to CYSS if the CheckBox Oxidized is selected
--                       If you have some CYS oxidized and some reduced, you will need to manually edit the .seq file
--
-- DYANA/CYANA1   amide protons are named "HN", GLY alpha protons: "HA1" &amp; "HA2"
--                in the .seq file the charges of the amino acids are indicated: ARG+, GLU- etc.
-- CYANA-2.0/2.1  amide protons are named "H", GLY alpha protons : "HA2" &amp; "HA3"
--                in the .seq file the charges of the amino acids are omitted:   ARG,  GLU etc.

-- Version Log -----------------------------------------------------------------

-- Ver.1 written by F.Damberger 21.Apr. 2005

-- Ver.2 F.Damberger 23.Apr.2005
-- fixed some bugs and added the feature,
--    that it sorts the AtomNames in each Residue by the greek alphabet

-- Ver.3 F.Damberger 09.Jun.2005
-- added escape line in case no project is found

-- Ver.4 F.Damberger 11.Sep.2005
-- added the ability to write out DYANA and CYANA-2.0 formats

-- Ver.5 F.Damberger 16.Oct.2005
-- 1. CYANA &amp; DYANA output do not renumber the atoms anymore
-- 2. added checkbox to oxidize all CYS -&gt; CYSS (for CYANA/DYANA)
--    if some cysteines are oxidized (CYSS) and some are reduced (CYS), user must still edit *.seq file
-- 3. renamed format "CYANA 2.0" to "CYANA 2.0/2.1" since apparently 2.0 and 2.1 use the same nomenclature.
-- 4. fixed formatting so that all Residue numbers are aligned in column

-- Ver.6 F.Damberger 16.Oct.2006
-- added the possibility to select a spectrum and use the alias shifts from that spectrum
--       if no spectrum is selected, then the default shifts are written out

-- Ver.7 F.Damberger 4.Apr.2007
-- default name is now derived from the project name
-- added the project name and name of spectrum used for the aliases to the header of XEASY protonlist
-- added version variable at top of script

-- Ver.8 F.Damberger 18.Oct.2007
-- BMRB format writes out separate lines for each atom belonging to a pseudoatom if a spin has a label matching the pseudoatoms name (identical shifts)

-- Ver. 9 F.Damberger 9.Nov.2007
-- Added the capability to write out classes of resonances (backbone only, triple resonance etc..)

-- NOTES:

-- =========== Version Definition ==========

VersionOfWriteAssignments = "version 9"
Date = "9. Nov. 2007 FD"

-- =========== Function Definitions =====================

function TableSize( table )
	Size = 0
	for Indx,Item in pairs( table ) do
		Size = Size + 1
	end
	return Size
end

-- function IsRingSymmetryAtom
function IsRingSymmetryAtom( AtomName )
	RingSymmNames = { "HE1", "HE2", "HD1", "HD2" }
	for Id,RingSymmName in pairs( RingSymmNames ) do
		if AtomName == RingSymmName then
			return true
		end
	end
	return false
end

-- function IsAtomWithRingSymmetryPartner
function IsAtomWithRingSymmetryPartner( ResName, AtomName )
	AromaticResName = { "PHE", "TYR" }
	for Id,AroResName in pairs( AromaticResName ) do
		if ResName == AroResName then
			if IsRingSymmetryAtom(AtomName) then
				return true
			end
		end
	end
	return false
end

-- function RingSymmetryPartnerIsAssignedToDifferentShift
function RingSymmetryPartnerIsAssignedToDifferentShift( Res, Atom, Spin )
	SpinSys = Spin:getSystem()
	-- find the partner spin in the group
	PartnerLabel = GetGroupPartnerLabel( Atom )
	if SpinSys then
		for Id,SpinInSys in pairs( SpinSys:getSpins() ) do
			if SpinInSys:getLabel() == PartnerLabel and SpinInSys:getShift() ~= Spin:getShift() then
				return true -- partner assigned with different shift
			end -- if partner assigned, shift different
		end -- for all spins in system
	else
		print( "Warning: could not find spin system for"..Spin:getId() )
		return false
	end -- if SpinSystem exists
end -- function

-- function GetGroupPartnerLabel
function GetGroupPartnerLabel( Atom )
	GroupAtoms = Atom:getGroup():getAtoms()
	for Id,GroupAtom in pairs( GroupAtoms ) do
		if GroupAtom:getName() ~= Atom:getName() then
			return GroupAtom:getName()
		end -- find Label different from atoms label, that's the partner
	end  -- for all labels in group
end

-- function AtomIsInMethyleneGroup
function AtomIsInMethyleneGroup( Res, Atom )
	if Atom:getAtomType() ~= "H" then return false end -- atom must be H
	Type = Res:getType()
	Neighbours = Atom:getNeighbours()
	j = 0
	for NeighbourLabel,NeighbourAtom in pairs( Neighbours ) do
		j = j + 1
		if j &gt; 1 then
			print("Warning: H Atom "..Atom:getName().." of ResidueType "..Type:getShort().." is bonded to more than one other atom!")
			return false
		end
		OnlyNeighbourLabel = NeighbourLabel
		OnlyNeighbourAtom = NeighbourAtom
	end
	if OnlyNeighbourAtom:getAtomType() ~= "C" then return false end -- attached atom must be C
	-- check if only 1 H and 1 C are attatched to C
	NumH = 0
	for NeighbourToCLabel,NeighbourToCAtom in pairs( OnlyNeighbourAtom:getNeighbours() ) do
		if NeighbourToCAtom:getAtomType() == "H" then
			NumH = NumH + 1
		end
	end -- add up number of H attatched to C
	if NumH ~= 2 then
		return false -- if not exactly one H and one C attatched to C, it's not a prochiral methyl group	
	else -- Atom is H, it is attatched to C, the C is attatched to two H atoms, ergo Atom H is in a CH2 group
		return true
	end
end

function AtomIsProchiralMethyl( Res, Atom )
	if Atom:getAtomType() ~= "H" then return false end -- atom must be H
	if Atom:getMagnitude() ~= 3 then return false end -- atom must be a methyl group (i.e. three equivalent protons)
	Type = Res:getType()
	Neighbours = Atom:getNeighbours()
	j = 0
	for NeighbourLabel,NeighbourAtom in pairs( Neighbours ) do
		j = j + 1
		if j &gt; 1 then
			print("Warning: H Atom (=3 equivalent protons) "..Atom:getName().." of ResidueType "..Type:getShort().." is bonded to more than one other atom!")
			return false
		end
		OnlyNeighbourLabel = NeighbourLabel
		OnlyNeighbourAtom = NeighbourAtom
	end
	
	NumH = 0
	NumC = 0
	for NeighbourToCLabel,NeighbourToCAtom in pairs( OnlyNeighbourAtom:getNeighbours() ) do
		if NeighbourToCAtom:getAtomType() == "H" then
			NumH = NumH + 1
		elseif NeighbourToCAtom:getAtomType() == "C" then
			NumC = NumC + 1
			PotentialProchiralC = NeighbourToCAtom
		end
	end -- add up number of H &amp; C attatched to C
	if NumH ~= 1 or NumC ~= 1 then
		return false -- if not exactly one H and one C attatched to C, it's not a prochiral methyl group
	end
	NeighboursToPotentialProchiralMethyl = PotentialProchiralC:getNeighbours()
	NumMethyls = 0
	for NeighbourLabel,NeighbourAtom in pairs( NeighboursToPotentialProchiralMethyl ) do
		if IsMethylCarbon( NeighbourAtom ) then NumMethyls = NumMethyls + 1 end
	end
	
	if NumMethyls == 2 then
		return true
	else
		return false
	end
end

function IsMethylCarbon( Atom )
	NeighbourAtoms = Atom:getNeighbours()
	local NumHmethyl = 0
	local NumCfound = 0
	for NeighbourLabel,NeighbourAtom in pairs( NeighbourAtoms ) do
		if NeighbourAtom:getAtomType() == "H" and NeighbourAtom:getMagnitude() == 3 then
			NumHmethyl = NumHmethyl + 1
		elseif NeighbourAtom:getAtomType() == "C" then
			NumCfound = NumCfound + 1
		end
	end -- for all Atoms attatched to "Atom"
	
	if NumHmethyl == 1 and NumCfound == 1 then
		return true
	else
		return false
	end
end

function ProchiralMethylsHaveDifferentShifts( Res, Atom, Spin )
	GroupAtoms = Atom:getGroup():getAtoms()
	for Label,AtomInGroup in pairs( GroupAtoms ) do
		if Atom:getName() ~= AtomInGroup:getName() then
			OtherAtomInGroup = AtomInGroup
		end
	end
	for Id,SpinInSys in pairs( Spin:getSystem():getSpins() ) do
		if OtherAtomInGroup:getName() == SpinInSys:getLabel() then -- other atom is assigned
			if SpinInSys:getShift() ~= Spin:getShift() then
				return true
			end
		end -- if other atom in same group
	end -- for all spins in system (search for spin which is assigned to other atom in group
	return false
end

-- function MethyleneGroupAtomsHaveDifferentShifts
function MethyleneGroupAtomsHaveDifferentShifts( Res, Atom, Spin )
	GroupAtoms = Atom:getGroup():getAtoms()
	for Label,AtomInGroup in pairs( GroupAtoms ) do
		if Atom:getName() ~= AtomInGroup:getName() then
			OtherAtomInGroup = AtomInGroup
		end
	end
	for Id,SpinInSys in pairs( Spin:getSystem():getSpins() ) do
		if OtherAtomInGroup:getName() == SpinInSys:getLabel() then -- other atom is assigned
			if SpinInSys:getShift() ~= Spin:getShift() then
				return true
			end
		end -- if other atom in same group
	end -- for all spins in system (search for spin which is assigned to other atom in group
	return false
end

-- function GetAmbiCode
function GetAmbiCode( Res, Atom, Spin )
	Label,Offset,State = spec.decomposeLabel( Spin:getLabel() )
	if State == 2 then
		return 1 -- final assignment made, no ambiguity in this shift
	elseif IsAtomWithRingSymmetryPartner( Res:getType():getShort(), Atom:getName() ) then
		if RingSymmetryPartnerIsAssignedToDifferentShift( Res, Atom, Spin ) then
			return 3 -- if symmetrypartner is assigned and has different shift ambiguity = 3
		else
			return 1 -- if symmetrypartner is not assigned or has same shift ambiguity = 1
		end
	elseif AtomIsInMethyleneGroup( Res, Atom ) and MethyleneGroupAtomsHaveDifferentShifts( Res, Atom, Spin ) then
		return 2
	elseif AtomIsProchiralMethyl( Res, Atom )and ProchiralMethylsHaveDifferentShifts( Res, Atom, Spin ) then
		return 2
	else
		return 1
	end
end


-- ====== The following functions convert AtomLabels from Greek to Roman ====
--  This allows sorting by Greek alphabet in the AtomName order for each residue
-- e.g. HA,HB2,HB3,HG2,HG3,HD2,HD3

function DefineGreekAndRomanAlphabet()
	GreekAlphabet = "ABGDEZH"
	RomanAlphabet = "ABCDEFG"
	GreekTable = {}
	RomanTable = {}
	i = 0
	for Letter in string.gfind( GreekAlphabet, "%a") do
		i = i + 1
		GreekTable[ i ] = Letter
	end
	i = 0
	for Letter in string.gfind( RomanAlphabet, "%a" ) do
		i = i + 1
		RomanTable[ i ] = Letter
	end
end

function GreekToRoman( Char )
	for i,GreekLetter in pairs( GreekTable ) do
		if GreekLetter == Char then
			return RomanTable[ i ]
		end
	end -- for all greek letters
	print("Warning: Function GreekToRoman: Did not find "..Char.."in the GreekTable." )
	return nil
end -- function GreekToRoman

function RomanToGreek( Char )
	for i,RomanLetter in pairs( RomanTable ) do
		if RomanLetter == Char then
			return GreekTable[ i ]
		end
	end -- for all Roman letters
	print( "Warning: Function RomanToGreek: Did not find "..Char.."in the RomanTable." )
	return nil
end -- function RomanToGreek

function AtomNameGreekToRoman( AtomName )
	if string.len( AtomName ) == 1 then
		return AtomName
	else
		StartChar,EndChar,Char1,Char2,RestString = string.find( AtomName, "(%a)(%a*)(%w*)" )
		Char2 = GreekToRoman( Char2 )
		return Char1..Char2..RestString
	end
end


function AtomNameRomanToGreek( AtomName )
	if string.len( AtomName ) == 1 then
		return AtomName
	else
		StartChar,EndChar,Char1,Char2,RestString = string.find( AtomName, "(%a)(%a)(%w*)" )
		Char2 = RomanToGreek( Char2 )
		return Char1..Char2..RestString
	end
end

function ItemsInTable( Table )
	i = 0
	for a,b in pairs( Table ) do
		i = i+1
	end
	return i
end -- function ItemsInTable

function ConvertRestoDyanaFormat( ResName ) -- note: I always assume the Res in Dyana lib with the maximum number of protons (e.g. GLU has HE2 where as GLU- does not)
	if ResName == "ARG" then ResName = "ARG+"
		elseif ResName == "HIS" then ResName = "HIS+"
		elseif ResName == "LYS" then ResName = "LYS+"
		else ResName = ResName.." " -- include extra space for "+" in "LYS+" etc.
	end
	return ResName
end -- function ConvertRestoDyanaFormat

function ConvertAtomNameToDyanaFormat( AtomName, Res )
	-- Not proud of this, FFD
	-- one could do this a simpler way by looking whether the AtomName corresponds to a GroupName in the ResidueType 
	-- and in that case replace the starting H by Q
	--   exceptions: VAL HG -&gt; QQG (use an if-statement)
	--               LEU HD -&gt; QQD (use an if-statement)
	--               all methyl groups H -&gt; Q (this could be done using a function that checks if the H is attatched to a C with three attatched Hatoms)
	if AtomName == "H" then
		AtomName = "HN"
	end -- rename all amides   The only difference compared to Cyana format

	if ResName ~= "THR" and  ResName ~= "ILE" and ResName ~= "VAL" then -- if NOT Beta-branched
		if AtomName == "HB" then AtomName = "QB" end
	end
	
	if ResName == "THR" then
		if AtomName == "HG2" then AtomName = "QG2" end
	end

	if ResName == "GLU" or ResName == "GLN" or ResName == "MET" or ResName == "ARG" or ResName == "LYS" or ResName == "PRO" then -- contains gamma methylene
		if AtomName == "HG" then AtomName = "QG" end
	end
	
	if ResName == "ARG" or ResName == "LYS" or ResName == "PRO" then -- contains delta and epsilon methylene
		if AtomName == "HD" then AtomName = "QD" end
	end
	
	if ResName == "LYS" or ResName == "MET" then -- contains epsilon methylene or methyl
		if AtomName == "HE" then AtomName = "QE" end
	end
	
	if ResName == "LYS" then
		if AtomName == "HZ" then AtomName = "QZ" end
	end
	
	if ResName == "GLY" then
		if AtomName == "HA3" then AtomName = "HA1" end
		if AtomName == "HA" then AtomName = "QA" end
	end

	if ResName == "ILE" then
		if AtomName == "HG1" then AtomName = "QG1" end
		if AtomName == "HG2" then AtomName = "QG2" end
		if AtomName == "HD1" then AtomName = "QD1" end
	end
	
	if ResName == "VAL" then
		if AtomName == "HG1" then AtomName = "QG1" end
		if AtomName == "HG2" then AtomName = "QG2" end
		if AtomName == "HG" then AtomName = "QQG" end
	end
	
	if ResName == "LEU" then
		if AtomName == "HD1" then AtomName = "QD1" end
		if AtomName == "HD2" then AtomName = "QD2" end
		if AtomName == "HD" then AtomName = "QQD" end
	end
	
	-- aromatic sidechains
	if ResName == "PHE" or ResName == "TYR" then
		if AtomName == "HD" then AtomName = "QD" end
		if AtomName == "HE" then AtomName = "QE" end
		if AtomName == "CD" then AtomName = "CD1" end -- added this because dyana.lib does not include pseudoatoms for CD
		if AtomName == "CE" then AtomName = "CE1" end -- added this because dyana.lib does not include pseudoatoms for CE
	end
	
	-- NH2 groups
	if ResName == "ASN" then
		if AtomName == "HD2" then AtomName = "QD2" end
	end
	
	if ResName == "GLN" then
		if AtomNam == "HE2" then AtomName = "QE2" end
	end
	
	if ResName == "ARG" then
		if AtomName == "HH1" then AtomName = "QH1" end
		if AtomName == "HH2" then AtomName = "QH2" end
	end

	return AtomName
end -- function ConvertAtomNameToDyanaFormat


function ConvertAtomNameToCyana2Format( AtomName, Res )
	-- Not proud of this, FFD
	-- one could do this a simpler way by looking whether the AtomName corresponds to a GroupName in the ResidueType 
	-- and in that case replace the starting H by Q
	--   exceptions: VAL HG -&gt; QQG (use an if-statement)
	--               LEU HD -&gt; QQD (use an if-statement)
	--               all methyl groups H -&gt; Q (this could be done using a function that checks if the H is attatched to a C with three attatched Hatoms)

	if ResName ~= "THR" and  ResName ~= "ILE" and ResName ~= "VAL" then -- if NOT Beta-branched
		if AtomName == "HB" then AtomName = "QB" end
	end
	
	if ResName == "THR" then
		if AtomName == "HG2" then AtomName = "QG2" end
	end

	if ResName == "GLU" or ResName == "GLN" or ResName == "MET" or ResName == "ARG" or ResName == "LYS" or ResName == "PRO" then -- contains gamma methylene
		if AtomName == "HG" then AtomName = "QG" end
	end
	
	if ResName == "ARG" or ResName == "LYS" or ResName == "PRO" then -- contains delta methylene
		if AtomName == "HD" then AtomName = "QD" end
	end
	
	if ResName == "LYS" or ResName == "MET" then -- contains epsilon methylene or methyl
		if AtomName == "HE" then AtomName = "QE" end
	end
	
	if ResName == "LYS" then
		if AtomName == "HZ" then AtomName = "QZ" end
	end
	
	if ResName == "GLY" then
		if AtomName == "HA" then AtomName = "QA" end
	end

	if ResName == "ILE" then
		if AtomName == "HG1" then AtomName = "QG1" end
		if AtomName == "HG2" then AtomName = "QG2" end
		if AtomName == "HD1" then AtomName = "QD1" end
	end
	
	if ResName == "VAL" then
		if AtomName == "HG1" then AtomName = "QG1" end
		if AtomName == "HG2" then AtomName = "QG2" end
		if AtomName == "HG" then AtomName = "QQG" end
	end
	
	if ResName == "LEU" then
		if AtomName == "HD1" then AtomName = "QD1" end
		if AtomName == "HD2" then AtomName = "QD2" end
		if AtomName == "HD" then AtomName = "QQD" end
	end
	
	-- aromatic sidechains
	if ResName == "PHE" or ResName == "TYR" then
		if AtomName == "HD" then AtomName = "QD" end
		if AtomName == "HE" then AtomName = "QE" end
		if AtomName == "CD" then AtomName = "CD1" end -- added this because cyana.lib does not include pseudoatoms for CD
		if AtomName == "CE" then AtomName = "CE1" end -- added this because cyana.lib does not include pseudoatoms for CE
	end
	
	-- NH2 groups
	if ResName == "ASN" then
		if AtomName == "HD2" then AtomName = "QD2" end
	end
	
	if ResName == "GLN" then
		if AtomNam == "HE2" then AtomName = "QE2" end
	end
	
	if ResName == "ARG" then
		if AtomName == "HH1" then AtomName = "QH1" end
		if AtomName == "HH2" then AtomName = "QH2" end
	end

	return AtomName
end -- function ConvertAtomNameToCyana-2Format

function SortedSequenceIndex( Sequence )
	i = 1
	Index = {}
	for a,b in pairs( Sequence ) do
		Index[i] = a
		i = i + 1
	end
	table.sort( Index )
	return Index
end

function InList( Element, List )
	result = false
	if List then
		for Id,Value in pairs( List ) do
			if Value == Element then
				result = true
			end
		end -- for all values in List
	else
		result = false
	end
	return result
end -- function InList

function IncludedResonance( Atom, SelectedResonances )
	if SelectedResonances == "All" then
		return true
	elseif SelectedResonances == "Protons only" and Atom:getAtomType() == "H" then
		return true
	elseif SelectedResonances == "Backbone: HN,N,CA,HA" and IsInTable( Backbone, Atom:getName() ) then
		return true
	elseif SelectedResonances == "Triple Resonance: HN,N,CA,CB,CO" and IsInTable( Triple, Atom:getName() ) then
		return true
	elseif SelectedResonances == "All Sidechain atoms" and not IsInTable( Backbone, Atom:getName() ) then
		return true
	elseif SelectedResonances == "Sidechain Protons" and Atom:getAtomType() == "H" and not IsInTable( Backbone, Atom:getName() ) then
		return true
	else
		return false
	end
end

function IsInTable( Table, Item )
	Result = false
	for Id,TableItem in pairs( Table ) do
		if TableItem == Item then Result = true end
	end
	return Result
end
-- ----------- END of FUNCTION Definitions --------------

-- ============== Start of Main code ====================

-- ESCAPE in case no project exists
if ItemsInTable( cara:getProjects() ) == 0 then error( "No projects found in Repository" ) end

-- Set Debug flag
Debug = false

-- ============Set up menu window for user preferences===================
-- define tables
DefineGreekAndRomanAlphabet() -- creates the tables GreekTable and RomanTable

Backbone = { "H", "N", "C", "CA", "HA", "HA2", "HA3" }
Triple = { "H", "N", "CA", "CB", "C" }

t = {} -- creates a temporary array for script variables

--1. Create main menu window

v = gui.createMainWindow()
v:setCaption( "WriteAssignments settings" )
t.frm = gui.createGrid( v, 2, false )
v:setCentralWidget( t.frm )
v:show()
t.frm:show()

-- Labels for first two columns
t.ProjectListLabel = gui.createLabel( t.frm, "Select Project" )
t.ProjectListCB = gui.createComboBox( t.frm )


--2. Read ProjectNames into ProjectList combobox

SelectedItemIndex = nil
for Id,Project in pairs( cara:getProjects() ) do
	ItemIndex = t.ProjectListCB:addItem( Project:getName() )
	t.ProjectListCB:setCurrentItem( ItemIndex )
	if AssignmentReportProjectName == t.ProjectListCB:getCurrentText() then
		SelectedItemIndex = ItemIndex
	end
end -- for all projects

if SelectedItemIndex then -- set to previous choice if it exists
	t.ProjectListCB:setCurrentItem( SelectedItemIndex )
end

-- Display ProjectList Combobox
t.ProjectListLabel:show()
t.ProjectListCB:show()

--3. Read SpectrumNames into SpectrumList combobox

-- Labels for next two columns
t.SpectrumListLabel = gui.createLabel( t.frm, "Select Spectrum if you want to write out alias shifts" )
t.SpectrumListCB = gui.createComboBox( t.frm )

SelectedItemIndex = nil

-- get the selected project
t.P = cara:getProject( t.ProjectListCB:getCurrentText() )

if t.P then -- get the list of spectra and set the selected spectrum
	ItemIndex = t.SpectrumListCB:addItem( "default shifts (not aliases)" )
	DefaultItemIndex = ItemIndex
	for Id,Spectrum in pairs( t.P:getSpectra() ) do
		ItemIndex = t.SpectrumListCB:addItem( Id..":"..Spectrum:getName() )
		t.SpectrumListCB:setCurrentItem( ItemIndex )
		if WriteAssignmentsInFormatXSpectrumName == t.SpectrumListCB:getCurrentText() then
			SelectedItemIndex = ItemIndex
		end
	end -- for all spectra
	
	if SelectedItemIndex then -- set to the previous choice if it exists
		t.SpectrumListCB:setCurrentItem( SelectedItemIndex )
	else
		t.SpectrumListCB:setCurrentItem( DefaultItemIndex )
	end
else -- project not selected yet
	-- do nothing
end -- if t.P
	
-- Display SpectrumList Combobox
t.SpectrumListLabel:show()
t.SpectrumListCB:show()


--3b. Determine which resonances to write out

-- Labels for first two columns
t.ResonancesLabel = gui.createLabel( t.frm, "Select resonance class to write out" )
t.ResonancesCB = gui.createComboBox( t.frm )

SelectedItemIndex = nil
ResonanceClasses = { "Backbone: HN,N,CA,HA", "Triple Resonance: HN,N,CA,CB,CO", "Protons only", "All", "All Sidechain atoms", "Sidechain Protons" }
for Id,Resonances in pairs( ResonanceClasses ) do
	ItemIndex = t.ResonancesCB:addItem( Resonances )
	t.ResonancesCB:setCurrentItem( ItemIndex )
	if WriteAssignments_Resonances == t.ResonancesCB:getCurrentText() then
		SelectedItemIndex = ItemIndex
	end
end -- for all ResonanceClasses

if SelectedItemIndex then -- set to previous choice if it exists
	t.ResonancesCB:setCurrentItem( SelectedItemIndex )
end

-- Display ResonanceClasses Combobox
t.ResonancesLabel:show()
t.ResonancesCB:show()



--4. Determine Output report location ------------------------------------

SelectedItemIndex = nil
t.OutputMethodCBLabel = gui.createLabel( t.frm, "Output sent to" )
t.OutputMethodCB = gui.createComboBox( t.frm )

-- Add Item "File" to ComboBox
ItemIndex = t.OutputMethodCB:addItem( "file" )
t.OutputMethodCB:setCurrentItem( ItemIndex )
if AssignmentReportOutputMethod == t.OutputMethodCB:getCurrentText() then
	SelectedItemIndex = ItemIndex
end

-- Add Item "terminal window" to ComboBox
ItemIndex = t.OutputMethodCB:addItem( "terminal window" )
t.OutputMethodCB:setCurrentItem( ItemIndex )
if AssignmentReportOutputMethod == t.OutputMethodCB:getCurrentText() then
	SelectedItemIndex = ItemIndex
end

-- Determine if an output method was selected already
if SelectedItemIndex then
	t.OutputMethodCB:setCurrentItem( SelectedItemIndex )
end

-- Display Label and Combobox for Output Method 
t.OutputMethodCBLabel:show()
t.OutputMethodCB:show()

--5. Determine Output file names ------------------------------------------

-- Create Label and Combobox for Seq Filename
t.FilenameLELabel = gui.createLabel( t.frm, "filename: *.seq *.prot *.str " )
t.FilenameLE = gui.createLineEdit( t.frm )

if Filename then -- determine if Filename already exists
	t.FilenameLE:setText( Filename )
else
	t.FilenameLE:setText( t.P:getName() ) -- default name
end

-- Display Label and LineEdit window
t.FilenameLELabel:show()
t.FilenameLE:show()

--6. Cysteines Oxidized or Reduced (CYSS or CYS)

-- Create Checkbox for Oxidized CYS
t.CysRedoxLabel = gui.createLabel( t.frm, "All Cys are oxidized" )
t.CysRedoxCheckBox = gui.createCheckBox( t.frm )

if CysRedox then -- determine if Cys Redox is already defined
	if CysRedox == "OX" then
		t.CysRedoxCheckBox:setChecked()
	else
		t.CysRedoxCheckBox:setChecked( false )
	end
end
-- Display Label and Checkbox
t.CysRedoxLabel:show()
t.CysRedoxCheckBox:show()


--7. Read Format choices into FormatType combobox ---------------

-- Create Label and Combobox for FormatType
t.FormatTypeCBLabel = gui.createLabel( t.frm, "select output format" )
t.FormatTypeCB = gui.createComboBox( t.frm )

SelectedItemIndex = nil
-- Add Item "DYANA" to Combobox
ItemIndex = t.FormatTypeCB:addItem( "DYANA" )
t.FormatTypeCB:setCurrentItem( ItemIndex )
if FormatType == t.FormatTypeCB:getCurrentText() then
	SelectedItemIndex = ItemIndex
end

-- Add Item "CYANA 2.0/2.1" to Combobox
ItemIndex = t.FormatTypeCB:addItem( "CYANA 2.0/2.1" )
t.FormatTypeCB:setCurrentItem( ItemIndex )
if FormatType == t.FormatTypeCB:getCurrentText() then
	SelectedItemIndex = ItemIndex
end

-- Add Item "BMRB" to Combobox
ItemIndex = t.FormatTypeCB:addItem( "BMRB" )
t.FormatTypeCB:setCurrentItem( ItemIndex )
if FormatType == t.FormatTypeCB:getCurrentText() then
	SelectedItemIndex = ItemIndex
end

if SelectedItemIndex then -- set to previous choice if it exists
	t.FormatTypeCB:setCurrentItem( SelectedItemIndex )
end

-- Display Label and Combobox
t.FormatTypeCBLabel:show()
t.FormatTypeCB:show()

--8. Add LineEdit field for H, C, N and other error (error in 1H,13C, 15N shifts)

t.Herror_LELabel = gui.createLabel( t.frm, "Enter Error in 1H shifts" )
t.Herror_LE = gui.createLineEdit( t.frm )

if AssignmentReport_Herror then
	t.Herror_LE:setText( AssignmentReport_Herror )
else
	AssignmentReport_Herror = 0.02
	t.Herror_LE:setText( AssignmentReport_Herror )
end -- if 1H error set previously

t.Herror_LELabel:show()
t.Herror_LE:show()

t.Cerror_LELabel = gui.createLabel( t.frm, "Enter Error in 13C shifts" )
t.Cerror_LE = gui.createLineEdit( t.frm )

if AssignmentReport_Cerror then
	t.Cerror_LE:setText( AssignmentReport_Cerror )
else
	AssignmentReport_Cerror = 0.3
	t.Cerror_LE:setText( AssignmentReport_Cerror )
end -- if 13C error set previously

t.Cerror_LELabel:show()
t.Cerror_LE:show()

t.Nerror_LELabel = gui.createLabel( t.frm, "Enter Error in 15N shifts" )
t.Nerror_LE = gui.createLineEdit( t.frm )

if AssignmentReport_Nerror then
	t.Nerror_LE:setText( AssignmentReport_Nerror )
else
	AssignmentReport_Nerror = 0.3
	t.Nerror_LE:setText( AssignmentReport_Nerror )
end -- if 15N error set previously

t.Nerror_LELabel:show()
t.Nerror_LE:show()

t.OtherError_LELabel = gui.createLabel( t.frm, "Enter Error in other nuclei shifts" )
t.OtherError_LE = gui.createLineEdit( t.frm )

if AssignmentReport_OtherError then
	t.OtherError_LE:setText( AssignmentReport_OtherError )
else
	AssignmentReport_OtherError = 0.3
	t.OtherError_LE:setText( AssignmentReport_OtherError )
end -- if Other nucleus error set previously

t.OtherError_LELabel:show()
t.OtherError_LE:show()


--9. OK and Cancel Buttons ----------------------------------------

t.okbutton = gui.createPushButton(t.frm, "OK" )
t.cancelbutton = gui.createPushButton( t.frm, "Cancel" )

t.okbutton:show()
t.cancelbutton:show()

-- ============Callbacks for menu window ===================

-- Define Callbacks for the buttons

-- Project Combobox Callback -- update SpectrumListCombobox to show spectra of currently selected project
t.ProjectListCB:setCallback( gui.event.Activated,
	function (self)
		t.P = cara:getProject( t.ProjectListCB:getCurrentText() )

		t.SpectrumListCB:clear() -- clear combobox for spectrumnames of newly selected project
		if t.P then -- get the list of spectra and set the selected spectrum
			ItemIndex = t.SpectrumListCB:addItem( "default shifts (not aliases)" )
			DefaultItemIndex = ItemIndex
			for Id,Spectrum in pairs( t.P:getSpectra() ) do
				ItemIndex = t.SpectrumListCB:addItem( Id..":"..Spectrum:getName() )
				t.SpectrumListCB:setCurrentItem( ItemIndex )
			end -- for all spectra
			
			--set to the default (no aliases)
			t.SpectrumListCB:setCurrentItem( DefaultItemIndex )
		else -- project not selected yet
			-- do nothing
		end
		
	end
) -- end project Combobox Callback

-- cancel button Callback
t.cancelbutton:setCallback( gui.event.Clicked,
	function (self)
		v:close()
	end
) -- end cancel button Callback

-- OK button Callback
t.okbutton:setCallback( gui.event.Clicked,
	function (self)
-- =============== Determine User Preferences ===========================

		t.P = cara:getProject( t.ProjectListCB:getCurrentText() )
--		if WriteAssignmentsInFormatXSpectrumName == t.SpectrumListCB:getCurrentText() then
		WriteAssignmentsInFormatXSpectrumName = t.SpectrumListCB:getCurrentText()
		if Debug then print( "WriteAssignmentsInFormatXSpectrumName = "..WriteAssignmentsInFormatXSpectrumName) end

		-- Get the selected spectrum if it exists
		SelectedSpectrum = nil -- default is none, use the default shift (not alias shift)
		for Id,Spectrum in pairs( t.P:getSpectra() ) do
			if WriteAssignmentsInFormatXSpectrumName == Id..":"..Spectrum:getName() then
				SelectedSpectrum = Spectrum
			end
		end -- for all spectra

		WriteAssignments_Resonances = t.ResonancesCB:getCurrentText()

		-- Get the user preferences
		AssignmentReportProjectName = t.P:getName()
		AssignmentReportOutputMethod = t.OutputMethodCB:getCurrentText()
		Filename = t.FilenameLE:getText()
		FormatType = t.FormatTypeCB:getCurrentText()
		if t.CysRedoxCheckBox:isChecked() then
			CysRedox = "OX"
		else
			CysRedox = "RED"
		end
		
		if FormatType == "BMRB" then
			-- Generate header to BMRB deposit
			Header = "   loop_\n      _Atom_shift_assign_ID\n      _Residue_seq_code\n      _Residue_label\n      _Atom_name\n      _Atom_type\n      _Chem_shift_value\n      _Chem_shift_value_error\n      _Chem_shift_ambiguity_code\n"
			Footer = "stop_"
		else
			Header = "# proton list generated using \n# WriteAssignments.lua "..VersionOfWriteAssignments.." by CARA\n"
			Header = Header.."# Shifts are derived from project: "..t.P:getName().."\n"
			Header = Header.."# using aliases of spectrum: "..WriteAssignmentsInFormatXSpectrumName.."\n"
			Footer = "" -- no footer in protonlist
		end
		
		t.Seq = t.P:getSequence()
		SortedIndex = SortedSequenceIndex( t.Seq )

		if FormatType ~= "BMRB" then
			-- create table for seq file output
			--t.Seq = t.P:getSequence()
			t.SeqLines = {}
			NumSeqLines = 0
--			for ResId,Res in pairs( t.Seq ) do
			for Indx=1,table.getn( SortedIndex ) do
				ResId = SortedIndex[ Indx ]
				Res = t.Seq[ SortedIndex[ Indx ] ]

				if FormatType == "DYANA" then -- DYANA
					ResName = ConvertRestoDyanaFormat( Res:getType():getShort() )
				else -- CYANA 2.0/2.1
					ResName = Res:getType():getShort().." "
				end
				
				-- write seq line to seq table
				if  ResName == "CYS " and CysRedox == "OX" then
					ResName = "CYSS"
					SeqLine = ResName.."  "..ResId
					
				else
					SeqLine = ResName.."  "..ResId
				end
				
				NumSeqLines = NumSeqLines + 1
				t.SeqLines[ NumSeqLines ] = SeqLine
			end -- for each Res in t.Seq
		end -- FormatType is not BMRB (create t.SeqLine)
		
		-- create table for prot file output
		t.Lines = {}
		LineCount = 1
		ShiftId = 0
		t.Lines[ LineCount ] = Header
		-- Algorithm to write assignments to output table
--		for ResId,Res in pairs( t.Seq ) do -- needed to replace this line with line below so that order of sequence is correct
		for Indx = 1,TableSize( SortedIndex ) do
			ResId = SortedIndex[ Indx ]
			Res = t.Seq[ SortedIndex[ Indx ] ]
			if Debug and ResId==2 then print("----RES LOOP: Res="..Res:getType():getShort()..ResId.."-----") end
			if t.P:getResidue( ResId ) and t.P:getResidue( ResId ):getSystem() then -- residue is assigned
				-- create table to store index of atom name entries for the residue (will be sorted)
				AtomNameIndex = {}
				-- create table to store lines for residue indexed by number k
				t.LinesForRes = {}
				t.SpinIdForLine = {}
				t.AtomsInRes = Res:getType():getAtoms()
				t.SpinsInRes = Res:getSystem():getSpins()
				AtomInResCount = 0
				AssignedAtomsList = {}
				N = 0
				for AtomId,Atom in pairs( t.AtomsInRes ) do -- for each atom in residue
					IsAssigned = false
					
					if IncludedResonance( Atom, WriteAssignments_Resonances ) then -- consider only resonances selected by user
					
						if Debug and ResId==2 then print("ForAtoms LOOP: AtomId="..AtomId.." AtomName="..Atom:getName() ) end
						for SpinId,Spin in pairs( t.SpinsInRes ) do
							if Atom:getAtomType() == Spin:getAtomType() then
								if Debug and ResId==2 then print("Atoms LOOP TEST: AtomType="..Spin:getAtomType().."  AtomName="..Atom:getName().." SpinLabel="..Spin:getLabel()) end
								if Atom:getName() == Spin:getLabel() then
									IsAssigned = true
									AssignedSpin = Spin
								-- This was added in ver.8 so that BMRB format includes one line for each Atom belonging to an assigned pseudoatom (duplication)
								elseif FormatType == "BMRB" and Atom:getGroup() ~= nil then
									if Atom:getGroup():getName() == Spin:getLabel() then -- Atoms Group Name matches Spins Label, pseudoatom is assigned
										IsAssigned = true
										AssignedSpin = Spin
										if Debug and ResId==2 then print("Found a match to pseudoatom assignment".." "..Spin:getLabel()) end
									end
								end
							end -- if Atoms Label or Group Label matches Spins Label
						end -- loop through all spins to search for match to atom name
						if Debug and ResidId==2 and IsAssigned then print("IsAssigned is true! The Spin has label: "..Spin:getLabel()) end
						if IsAssigned ~= true and Atom:getGroup() and FormatType ~= "BMRB" then -- no match found, now check for matches to Group pseudoatoms, this is unnecessary for BMRB format since each Atom is treated separtely anyway (see elseif in the above if statement)
							for SpinId,Spin in pairs( t.SpinsInRes ) do
							-- check only for pseudoatom matches
								if Atom:getGroup():getName() == Spin:getLabel() then
									if Debug and ResId==2 then print("Checking groups: GroupName = "..Atom:getGroup():getName().." SpinLabel = "..Spin:getLabel() ) end
									if not InList( Atom:getName(), AssignedAtomsList ) then
										IsAssigned = true
										AssignedSpin = Spin
										
										N = N + 1
										AssignedAtomsList[ N ] = Atom:getName() -- AssignedAtomsList
										-- add group partner to AssignedAtomsList (to avoid duplication)
										N = N + 1
										AssignedAtomsList[ N ] = GetGroupPartnerLabel( Atom )
									end -- if the Atom is not in AssignedAtomList , this avoids duplication for pseudoatoms
										
								end -- if group Name matches spin label	
							end
						end
						if IsAssigned then
							AtomInResCount = AtomInResCount + 1
							-- format the results for the next line in the table
							ShiftIdForm = string.format( "%5s",ShiftId )
							ResidNum = string.format( "%5s", ResId )
							ResName = string.format( "%6s", Res:getType():getShort() )
							AtomName = "  "..string.format( "%-4s", AssignedSpin:getLabel() )
							AtomType = string.format( "%3s", Atom:getAtomType() )
							AssignedSpinsShift = AssignedSpin:getShift( SelectedSpectrum )
							
						
							if FormatType == "BMRB" then -- --------------- BMRB format ---- BMRB format ---- BMRB format
								AtomNameIndex[ AtomInResCount ] = AtomNameGreekToRoman( Atom:getName() ) -- so I can later sort alphabetically, this differs from DYANA/CYANA formats (Here I index by the Atoms name)
								-- Do formatting
								-- For BMRB I use the Atoms Name not the spins Label (because I list both atoms in the Pseudoatom Group in BMRB format)
								AtomName = "  "..string.format( "%-4s", Atom:getName() ) -- overwrite the value set for CYANA/DYANA format
		
								if Atom:getAtomType() == "H" then
									Shift = string.format( "%8.3f", AssignedSpinsShift )
									ShiftErr = string.format( "%6.3f", AssignmentReport_Herror ).." "
								elseif Atom:getAtomType() == "C" then
									Shift = string.format( "%8.3f", AssignedSpinsShift ).." "
									ShiftErr = string.format( "%-5.1f", AssignmentReport_Cerror ).." "
								elseif Atom:getAtomType() == "N" then
									Shift = string.format( "%8.3f", AssignedSpinsShift ).." "
									ShiftErr = string.format( "%-5.1f", AssignmentReport_Nerror ).." "
								else
									Shift = string.format( "%8.3f", AssignedSpinsShift ).." "
									ShiftErr = string.format( "%-5.1f", AssignmentReport_OtherError ).." "
								end
		
	
								-- BMRB format output
								AmbiCode = GetAmbiCode( Res, Atom, AssignedSpin )
								AmbiCode = string.format( "%3s", AmbiCode ).."  "
								--t.LinesForRes[ AtomNameGreekToRoman( AssignedSpin:getLabel() ) ] = ResidNum..ResName..AtomName..AtomType..Shift..ShiftErr..AmbiCode
								t.LinesForRes[ AtomNameGreekToRoman( Atom:getName() ) ] = ResidNum..ResName..AtomName..AtomType..Shift..ShiftErr..AmbiCode
								if Debug and ResId==2 then print( ResidNum..ResName..AtomName..AtomType..Shift..ShiftErr..AmbiCode) end
							elseif FormatType == "DYANA" then -- ------------------DYANA format ---- DYANA format ---- DYANA format -----------
								AtomNameIndex[ AtomInResCount ] = AtomNameGreekToRoman( AssignedSpin:getLabel() ) -- so I can later sort alphabetically, Here I index by the spins label (no duplication)
								-- Get Info
								ResName = Res:getType():getShort()
								AtomName = AssignedSpin:getLabel()
								--print("DYANA format: AtomName="..AtomName.." ResName="..ResName)
								AtomName = ConvertAtomNameToDyanaFormat( AtomName, ResName )
								-- print("Converted: "..AtomName)
								AtomName = "  "..string.format( "%-4s", AtomName )
								Shift = string.format( "%7.3f", AssignedSpinsShift )
								ShiftErr = string.format( "%6.3f", AssignmentReport_Herror )
								if Atom:getAtomType() == "H" then
									Shift = string.format( "%8.3f", AssignedSpinsShift )
									ShiftErr = string.format( "%6.3f", AssignmentReport_Herror ).." "
								elseif Atom:getAtomType() == "C" then
									Shift = string.format( "%8.3f", AssignedSpinsShift ).." "
									ShiftErr = string.format( "%5.3f", AssignmentReport_Cerror ).." "
								elseif Atom:getAtomType() == "N" then
									Shift = string.format( "%8.3f", AssignedSpinsShift ).." "
									ShiftErr = string.format( "%5.3f", AssignmentReport_Nerror ).." "
								else
									Shift = string.format( "%8.3f", AssignedSpinsShift ).." "
									ShiftErr = string.format( "%5.3f", AssignmentReport_OtherError ).." "
								end						
									
								t.LinesForRes[ AtomNameGreekToRoman( AssignedSpin:getLabel() ) ] = Shift..ShiftErr..AtomName..ResidNum
								t.SpinIdForLine[ AtomNameGreekToRoman( AssignedSpin:getLabel() ) ] = AssignedSpin:getId()
	
							elseif FormatType == "CYANA 2.0/2.1" then -- ------------------CYANA format ---- CYANA format ---- CYANA format -----------
								AtomNameIndex[ AtomInResCount ] = AtomNameGreekToRoman( AssignedSpin:getLabel() ) -- so I can later sort alphabetically, Here I index by the spins label (no duplication)
								-- Get Info
								ResName = Res:getType():getShort()
								AtomName = AssignedSpin:getLabel()
								AtomName = ConvertAtomNameToCyana2Format( AtomName, ResName )
								AtomName = "  "..string.format( "%-4s", AtomName )
								
								Shift = string.format( "%8.3f", AssignedSpinsShift )
								ShiftErr = string.format( "%6.3f", AssignmentReport_Herror )
	
								if Atom:getAtomType() == "H" then
									Shift = string.format( "%8.3f", AssignedSpinsShift )
									ShiftErr = string.format( "%6.3f", AssignmentReport_Herror ).." "
								elseif Atom:getAtomType() == "C" then
									Shift = string.format( "%8.3f", AssignedSpinsShift ).." "
									ShiftErr = string.format( "%5.3f", AssignmentReport_Cerror ).." "
								elseif Atom:getAtomType() == "N" then
									Shift = string.format( "%8.3f", AssignedSpinsShift ).." "
									ShiftErr = string.format( "%5.3f", AssignmentReport_Nerror ).." "
								else
									Shift = string.format( "%8.3f", AAssignedSpinsShift ).." "
									ShiftErr = string.format( "%5.3f", AssignmentReport_OtherError ).." "
								end						
		
								t.LinesForRes[ AtomNameGreekToRoman( AssignedSpin:getLabel() ) ] = Shift..ShiftErr..AtomName..ResidNum
								t.SpinIdForLine[ AtomNameGreekToRoman( AssignedSpin:getLabel() ) ] = AssignedSpin:getId()
							end -- if  FormatType
						end -- if IsAssigned
						-- TEST TEST TEST
						if Debug and ResId==2 then
							print("Residue: "..Res:getType():getShort()..Res:getId() )
							print("--- AssignedAtomsList contents ---")
							print("Size of list: "..N)
							for a,b in pairs( AssignedAtomsList ) do
								print(a,b)
							end
						end -- Debug output
						
					end -- if IncludedResonance
					
				end -- for each atom in residue
				-- Sort the lines from this residue by AtomName
				table.sort( AtomNameIndex )
				-- copy lines from residue into the main table
				
					for m = 1,TableSize( AtomNameIndex ) do
						AtomNameLocal = AtomNameIndex[ m ]
						LineCount = LineCount + 1
						ShiftId = ShiftId + 1
						ShiftIdForm = string.format( "%10s",ShiftId )
						if FormatType == "CYANA 2.0/2.1" or FormatType =="DYANA" then -- order by original spin ID
							ShiftId = t.SpinIdForLine[ AtomNameLocal ]
							ShiftIdForm = string.format( "%10s",ShiftId )
							t.Lines[ LineCount ] = ShiftIdForm..t.LinesForRes[ AtomNameLocal ]
						else
							t.Lines[ LineCount ] = ShiftIdForm..t.LinesForRes[ AtomNameLocal ]
						end
					end -- for all lines in residue

				end -- if the residue is assigned
		end -- for each residue in sequence
		
		if FormatType == "BMRB" then -- add Footer to BMRB output
			LineCount = LineCount + 1
			t.Lines[ LineCount ] = Footer
		end
		--NumLines = TableSize( t.Lines )
		if AssignmentReportOutputMethod == "terminal window" then
			for i = 1,LineCount do
				print( t.Lines[i].."  " )
			end
			print("WriteAssignments printed "..LineCount.." lines to terminal window")
		else -- open file to write
			if FormatType == "BMRB" then
				outfile = io.output( Filename..".str" )
				for i=1,LineCount do
					outfile:write( t.Lines[ i ].."\n" )
				end
				outfile:close()
			elseif FormatType == "DYANA" or FormatType == "CYANA 2.0/2.1" then
				-- Write out seq file
				outfile = io.output( Filename..".seq" )
				for i=1,TableSize( t.SeqLines ) do
					outfile:write( t.SeqLines[ i ].."\n" )
				end
				outfile:close()
				-- Write out prot file
				outfile = io.output( Filename..".prot" )
				for i=1,LineCount do
					outfile:write( t.Lines[ i ].."\n" )
				end
				outfile:close()
			else
				print("unsupported format not done yet")
			end
			print("WriteAssignments wrote out "..LineCount.." lines to assignments files")
		end -- if BmrBDepositOutputMethod
		print("WriteAssignments version "..VersionOfWriteAssignments.." "..Date.." is finished.")
		v:close()
	end -- function self
) -- end OK button Callback

-- End of script FD.

</code>
<fld name='Author' type='String'>Fred Damberger</fld>
<fld name='Creation Date' type='Date'>2007-11-2</fld>
<fld name='Description' type='Memo'>Write out assignments for database deposition or for structure calculation. The script converts the internal format of the assignments into different external formats. BMRB nmr-star 2.1, DYANA and CYANA1.0.</fld>
<fld name='Version' type='Short'>9</fld>
</script>
<script name='ShiftSpinsInCatagory'>
<code lang='Lua'>-- ShiftsSpinsInCatagory.lua
-- script to shift spins of certain class (e.g. all aromatic 1H) by fixed amount

-- Spins assigned to atoms of one AtomType (H, C or N) are shifted by a fixed amount
-- if they fall into the selected catagory (aliphatic, aromatic, amide, amine, backbone, triple...)

-- The intersection of the sets defined by AtomType and Catagory are identified and shifted
-- Aliases are NOT ignored
-- Unassigned spins and tentatively assigned spins are ignored
-- spins with offset labels like C-1 and CA-1 are ignored

-- The script is intended to help fix problems with referencing between spectra
-- Undo is easy: just repeat the script with a shift of the opposite numerical sign.

-- Definitions of Catagories:
-- The script determines which C atoms are aromatic or aliphatic by counting
-- the number of bonding partners (Caro =3, Cali = 4)
--   Note that a methyl proton counts as 3 bonding partners (using the Magnitude attribute of  atoms)
-- H and N atoms are considered aromatic or aliphatic if attached to a Caro or Cali respectively
-- Amide N are attached to aliphatic C
-- Amine N are attatched to 2 H and one O
--amide H are attatched to an amide N
-- amine H are attatched to an amine N
-- Backbone spins have labels: H, HN, HA, CA, C, N
-- Triple spins have labels: H, HN, N, C, CA, CB
-- I ignore spins with offsets like CA-1, C-1 etc.
-- although with some additional effort these could be included
-- FD



-- F.Damberger Nov 27 2006.

-- Version 1: Nov. 27 2006 F.Damberger

-- Version 2: May. 15 2007 F.Damberger
	-- added the shifting of spins alias positions
	
-- Version 3: May. 16 2007 F.Damberger
    -- added catagory "carbonyl" for 13C
	
-- Important: modify ResidueType "BB" by adding a new Atom "X" with AtomType = "B" and bond it to CB
--            Otherwise the script will fail to recognize "CB" atom of "BB" ResidueType as a "Aliphatic",
--            instead classing it as "Aromatic" based on a valuence =3

-- Still missing, the shifting of spins with offset labels like CA-1
--                shifting of peaklists
-- ----------------------------------------------------------------------


-- create array for script variables
t = {}



-- ----------------------------------------------------------------------

-- =================== Define Functions =================================


function TableSize( Table )
	local Size = 0
	for IdNum,Entry in pairs( Table ) do
		Size = Size + 1
	end -- for
	return Size
end -- function TableSize


function AtomNameFromResType( Label, ResType )  -- added in ver.7
	-- purpose: return true if label occurs in ResType
	local result = nil
	for AtomName,Atom in pairs( ResType:getAtoms() ) do
		if Label == AtomName then
			result = true
		end
	end -- for all atoms in ResType
	return result
end -- function AtomNameFromResType

function CreateComboBoxFromTable( SelectedTableElement, Table )
	TableComboBox = nil
	TableComboBox = gui.createComboBox( t.frm )
	SelectedItemIndex = nil
	for Id,TableElement in pairs( Table ) do
		ItemIndex = TableComboBox:addItem( TableElement )
		TableComboBox:setCurrentItem( ItemIndex )
		if SelectedTableElement == TableComboBox:getCurrentText() then
			SelectedItemIndex = ItemIndex
		end -- if match found to existing selection
	end -- for all table elements
	if SelectedItemIndex then TableComboBox:setCurrentItem( SelectedItemIndex ) end
	return TableComboBox
end --function

function CreateLineEditWindow( Value )
	LineEditWindow = nil
	LineEditWindow = gui.createLineEdit( t.frm )
	if Value ~= nil then LineEditWindow:setText( Value )
	else LineEditWindow:setText( 0.0 )
	end
	return LineEditWindow
end -- function CreateLineEdit


function CreateTableOfProjectNames()
	Table = {}
	i = 0
	for Name,Project in pairs( cara:getProjects() ) do
		i = i + 1
		Table[ i ] = Name
	end -- for all projects
	return Table
end --function CreateTableOfProjectNames

function TypeOfCarbon(Atom ) -- returns true if the carbon has three attatched atoms and is none is O
-- note that Magnitudes for methyls must be defined as "3* otherwise this will count them as having 2 neighbors
	BondedAtoms = Atom:getNeighbours()
	Result = false
	OxygenBonded = false
	Valence = 0
	for BondedAtomName,BondedAtom in pairs( BondedAtoms ) do
		if BondedAtom:getAtomType() == "O" then OxygenBonded = true end
		Valence = Valence + BondedAtom:getMagnitude() -- count methyl protons as three bonds
	end -- for all bonded atoms
	if OxygenBonded == true then AtomType = "Carbonyl"
	elseif Valence == 3 then AtomType = "Aromatic"
	elseif Valence == 4 then AtomType = "Aliphatic"
	else AtomType = "other"
	end

	return AtomType
end -- function IsAromaticCarbon

function Nattached( Atom )
	BondedAtoms = Atom:getNeighbours()
	print("Nattached num bonded: "..TableSize(BondedAtoms)) --TEST
	NitrogenBonded = false
	for BondedAtomName,BondedAtom in pairs( BondedAtoms ) do
		if BondedAtom:getAtomType() == "N" then NitrogenBonded = true end
	end
	return NitrogenBonded
end -- function Nattached

function TypeOfNitrogen( Atom ) -- returns amine if two protons and one carbonyl are attatched
--  returns amide if one proton and one aliphatic carbon are attatched
-- returns aromatic if an aromatic C is attatched
	NatomType = nil
	BondedAtoms = Atom:getNeighbours()
	OxygenBonded = false
	CarbonylBonded = false
	AliphaticCarbonBonded = false
	AromaticCarbonBonded = false
	NumHatoms = 0 -- number of bonded H atoms
	for BondedAtomName,BondedAtom in pairs( BondedAtoms ) do
		if BondedAtom:getAtomType() == "O" then OxygenBonded = true end
		if BondedAtom:getAtomType() == "H" then NumHatoms = NumHatoms + 1 end
		if BondedAtom:getAtomType() == "C" then
			CarbonType = TypeOfCarbon( BondedAtom )
			if CarbonType == "Aromatic" then AromaticCarbonBonded = true end
			if CarbonType == "Aliphatic" then AliphaticCarbonBonded = true end
			if CarbonType == "Carbonyl" then CarbonylBonded = true end
		end -- if carbon
	end -- for all bonded atoms
	print("NumHatoms:"..NumHatoms)--TEST
	if AromaticCarbonBonded then NatomType = "Aromatic" -- CaroN
	elseif CarbonylBonded and NumHatoms == 2 then NatomType = "Amine" -- CONH2
	elseif AliphaticCarbonBonded and NumHatoms == 1 then NatomType = "Amide" -- CANH
	else NatomType = "other"
	end
	return NatomType
end -- function IsAromaticCarbon

function TypeOfHydrogen( Atom )
	BondedAtoms = Atom:getNeighbours()
	for BondedAtomName,BondedAtom in pairs( BondedAtoms ) do
		if BondedAtom:getAtomType() == "N" then HatomType = TypeOfNitrogen( BondedAtom ) end
		if BondedAtom:getAtomType() == "C" then HatomType = TypeOfCarbon( BondedAtom ) end
	end -- for all bonded atoms
	return HatomType
end -- function IsAttatchedToN

function CreateLabelText( StartString, Table )
	LabelText = StartString
	for Index,CurrentLabel in pairs( Table ) do
		LabelText = LabelText.." "..CurrentLabel
	end -- for all Table elements
	return LabelText
end -- function CreateLabelsText

function NotFloatingPoint( Value ) -- returns true if value is NOT floating point format e.g. 5.31
	return false
end

function NameOfSpin( Spin )
	Sys = Spin:getSystem()
	if Sys then -- Spin belongs to system
		Res = Sys:getResidue()
		if Res then -- Spin belongs to residue
			Typ = Res:getType()
			Name = Typ:getShort().." "..Res:getId().." "..Spin:getLabel()
		else -- spin is in unassigned system
			Name = "SystemId: "..Sys:getId().." SpinId "..Spin:getId()
		end
	else -- spin is orphaned
		Name = "orphaned spin SpinId: "..Spin:getId()
	end
	return Name
end -- function NameOfSpin

function MatchesTableMember( Label, Table )
	result = false
	for MemberId,Member in pairs( Table ) do
		if Label == Member then result = true end
	end -- for all members
	return result
end


function AtomIsSelected( Atom )
	result = false
	if SelectedAtomType == Atom:getAtomType() then
		if SelectedAtomCatagory == "All" then
			result = true
		else -- get CatagoryOfAtom
			if SelectedAtomType == "H" then
				CatagoryOfAtom = TypeOfHydrogen( Atom )
			elseif SelectedAtomType == "C" then
				CatagoryOfAtom = TypeOfCarbon( Atom )
			elseif SelectedAtomType == "N" then
				CatagoryOfAtom = TypeOfNitrogen( Atom )
				--print("CatagoryOfAtom:"..CatagoryOfAtom)--TEST
				--print("TypeOfNitrogenAtom:"..TypeOfNitrogen(Atom))--TEST
			end
			-- check if Atom Matches selected catagory
			if SelectedAtomCatagory == "Aromatic" then
				if CatagoryOfAtom == "Aromatic" then
					result = true
				end
			elseif SelectedAtomCatagory == "Aliphatic" then
				if CatagoryOfAtom == "Aliphatic" then
					result = true
				end
			elseif SelectedAtomCatagory == "Carbonyl" then
				if CatagoryOfAtom == "Carbonyl" then
					result = true
				end
			elseif SelectedAtomCatagory == "All N-bonded" then
				if Nattached( Atom ) then
					result = true
				end
			elseif SelectedAtomCatagory == "Amine" then
				if CatagoryOfAtom == "Amine" then
					result = true
				end
			elseif SelectedAtomCatagory == "Amide" then
				if CatagoryOfAtom == "Amide" then
					result = true
				end
			elseif SelectedAtomCatagory == "Backbone" then
				if MatchesTableMember( Atom:getName(), BackboneLabels ) then
					result = true
				end
			elseif SelectedAtomCatagory == "Triple" then
				if MatchesTableMember( Atom:getName(), TripleLabels ) then
					result = true
				end
			else result = false -- no catagory selected
			end -- if SelectedAtomCatagory = one of the above
			
		end -- if SelectedAtomCatagory = all
	end -- if SelectedAtomType matches
	return result
end -- function AtomIsSelected

-- This is not used, I rewrote to deal with pseudoatoms using the function below
function FindSpinOfAtom( Atom, Spins )
	MatchedSpin = nil
	for SpinId,Spin in pairs( Spins ) do
		if Atom:getAtomType() == Spin:getAtomType() and Atom:getName() == Spin:getLabel() then
			MatchedSpin = Spin
		end
	end -- for all Spins in System
	return MatchedSpin
end -- function FindSpinOfAtom

function FindAtomOfSpin( Spin, Atoms )
	MatchedAtom = nil
	for AtomName,Atom in pairs( Atoms ) do
		if Atom:getAtomType() == Spin:getAtomType() and AtomName == Spin:getLabel() then
			MatchedAtom = Atom
		elseif Atom:getAtomType() == Spin:getAtomType() and Atom:getGroup() then
			if Atom:getGroup():getName() == Spin:getLabel() then -- also match pseudoatom names
				MatchedAtom = Atom
			end -- if group exists
		else
			-- do nothing
		end
	end -- for all atoms in residue
	return MatchedAtom
end -- function FindAtomOfSpin

--[[
function ShiftSpin( Spin, ShiftChange )
	OldShift = Spin:getShift()
	NewShift = OldShift + ShiftChange
	OldShiftForm = string.format( "%5.3f", OldShift )
	NewShiftForm = string.format( "%5.3f", NewShift )
	print( "shifting spin: "..NameOfSpin( Spin ).." from "..OldShiftForm.." to "..NewShiftForm )
	t.Project:setShift( Spin, NewShift )
end -- function ShiftSpin
]]

function ShiftSpin( Spin, ShiftChange )
	delta = tonumber( ShiftChange )
	--Project:setShift( Spin, Spin:getShift() + delta )
	--if ShiftAliases then
		Shifts = Spin:getShifts()
		for SpecId,Shift in pairs( Shifts ) do -- check all spectra for alias
			Spectrum = Project:getSpectrum( SpecId )
			Project:setShift( Spin, Spin:getShift( Spectrum ) + delta, Spectrum ) -- then shift it
		end -- for all Shift aliases
	--end --- if ShiftAliases
end -- function ShiftSpin

--===================END OF FUNCTION DEFINITIONS ========================


-- ================== SOME PARAMETER DEFINITIONS ========================

BackboneLabels = { "HN", "H", "N", "C", "CA", "HA", "HA1", "HA2", "HA3" } -- I include both XEASY and IUPAC nomenclature
TripleLabels = { "HN", "H", "N", "C", "CA", "CB" } -- I include both XEASY and IUPAC nomenclature
AtomChoices = { "All", "Aromatic", "Aliphatic", "Carbonyl", "All N-bonded", "Amide", "Amine", "Backbone", "Triple" }
AtomTypes = { "H", "C", "N" }



-- Define BackboneLabelsText
BackboneLabelsText = CreateLabelText( "Backbone Labels : ", BackboneLabels )
-- Define TripleLabelsText
TripleLabelsText = CreateLabelText( "Triple Resonance Labels : ", TripleLabels )

-- ============Set up menu window for user preferences===================

--0. Check whether there are any projects available
ProjectsTable = cara:getProjects()

if TableSize( ProjectsTable ) == 0 then error("No projects found in repository") end

--1. Create main menu window

v = gui.createMainWindow()
v:setCaption( "Shifts Spins Dialog" ) -- of main window
t.frm = gui.createGrid( v, 2, false ) -- create 2 column grid for the frame
v:setCentralWidget( t.frm ) -- make frame the central widget
v:show()
t.frm:show()

ProjectNamesTable = CreateTableOfProjectNames()

-- Project Selector
t.ProjectListLabel = gui.createLabel( t.frm, "Select Project" )
t.ProjectListCB = CreateComboBoxFromTable( ProjectName, ProjectNamesTable )

-- Create Table Selector
t.AtomTypeLabel = gui.createLabel( t.frm, "Select AtomType of Spins to change shift")
t.AtomTypeCB = CreateComboBoxFromTable( SelectedAtomType, AtomTypes )

-- Create Table Selector
t.AtomCatagoryLabel = gui.createLabel( t.frm, "Select Catagory of Spins to change shift")
t.AtomCatagoryCB = CreateComboBoxFromTable( SelectedAtomCatagory, AtomChoices )

-- Create Floating point field
t.ShiftLELabel = gui.createLabel( t.frm, "Enter the magnitude of the shift change to apply")
t.ShiftLE = CreateLineEditWindow( ShiftChange )

-- Display SourceProjectList Combobox
t.ProjectListLabel:show()
t.ProjectListCB:show()

-- Display AtomType Table ComboBox
t.AtomTypeLabel:show()
t.AtomTypeCB:show()

-- Display AtomCatagory Table ComboBox
t.AtomCatagoryLabel:show()
t.AtomCatagoryCB:show()

-- Display ShiftSize LineEditWindow
t.ShiftLELabel:show()
t.ShiftLE:show()



--9. OK and Cancel Buttons

t.okbutton = gui.createPushButton(t.frm, "OK" )
t.cancelbutton = gui.createPushButton( t.frm, "Cancel" )

t.okbutton:show()
t.cancelbutton:show()


-- ============Callbacks for menu window ===================

-- Define Callbacks for the buttons


-- cancel button Callback
t.cancelbutton:setCallback( gui.event.Clicked,
	function (self)
		v:close()
	end
) -- end cancel button Callback

-- OK button Callback
t.okbutton:setCallback( gui.event.Clicked,
	function (self)
-- =============== Determine User Preferences ===========================

		t.Project = cara:getProject( t.ProjectListCB:getCurrentText() )
		ProjectName = t.Project:getName()
				
		Project = cara:getProject( ProjectName )
		SelectedAtomType = t.AtomTypeCB:getCurrentText()
		print("Selected Atom Name : "..SelectedAtomType )
		
		SelectedAtomCatagory = t.AtomCatagoryCB:getCurrentText()
		print("Selected Atom Catagory : "..SelectedAtomCatagory)
		
		ShiftChange = t.ShiftLE:getText()
		if NotFloatingPoint( ShiftSize ) then error("Warning: You must enter a floating point value for the shift like 1.05") end
		

-- Run analysis
	NumShifted = 0
	
-- New version of analysis which shifts all spins that are in a spin-system, orphaned spins are ignored
	
	Systems = t.Project:getSystems()
	
	for SysId,Sys in pairs( Systems ) do
		--print("System "..SysId)--TEST
		SysType = Sys:getSystemType()
		-- get the ResidueType either from SystemType or from the assigned Residue
		if SysType then
			ResTypeName = SysType:getName()
			ResTyp = cara:getResidueType( ResTypeName )
		end
		Res = Sys:getResidue()
		if Res then ResTyp = Res:getType() end
		if not ResTyp then ResTyp = cara:getResidueType( "BB" ) end -- default is generic BBresidue ( don't know how to access which residue is the generic)

		--print("Residue Type: "..ResTyp:getName() )--TEST
		--Scan the spins, determine whether to shift them, and shift the selected ones
		Spins = Sys:getSpins()
		Atoms = ResTyp:getAtoms()
		for SpinId,Spin in pairs (Spins) do
			AssignedAtom = FindAtomOfSpin( Spin, Atoms )
			--print("Spin : "..SpinId)--TEST
			if AssignedAtom then -- spin is assigned to the atom of a ResidueType
				--print("AssignedAtom "..AssignedAtom:getName() )--TEST
				if AtomIsSelected( AssignedAtom ) then -- Atom is selected by user
					print("Shifting: "..ResTyp:getName().." "..AssignedAtom:getName() )--TEST
					ShiftSpin( Spin, ShiftChange )
					NumShifted = NumShifted + 1
				end
			end -- if spin is assigned to atom or pseudoatom
		end -- for all spins in system
	end -- for all systems
	
-- old version of analysis -- only shifts spins belonging to assigned spin-systems
--[[
	t.Seq = t.Project:getSequence()
	for ResId,Res in pairs( t.Seq ) do
		ResTyp = Res:getType()
		print( "checking residue "..ResTyp:getShort()..ResId )
		Sys = Res:getSystem()
		if Sys then -- Residue is assigned
			Spins = Sys:getSpins()
			Atoms = ResTyp:getAtoms()
			for SpinId,Spin in pairs (Spins) do
				AssignedAtom = FindAtomOfSpin( Spin, Atoms )
				if AssignedAtom then -- change spins shift
					if AtomIsSelected( AssignedAtom ) then -- Atom is selected by user
						ShiftSpin( Spin, ShiftChange )
						NumShifted = NumShifted + 1
					end
				end -- if spin is assigned to atom or pseudoatom
			end -- for all spins in system
		end
	end -- for all Residues
]]
	print( "---------------------------------------------------------")
	print( " shifted "..NumShifted.." "..SelectedAtomType.." spins by "..ShiftChange )
		v:close()
	end
) -- end OK button Callback

-- End of script FD.
</code>
<fld name='Creation Date' type='Date'>2007-5-16</fld>
</script>
<script name='RecalibrateSpectra'>
<code lang='Lua'>-- script to calibrate all spectra dimensions matching the input AtomType and expected chemical shift range

-- e.g. Use it to calibrate all your aromatic 13C dimensions at once:
--   Selecte "C" and enter ppm range "90-140" which should cover all aromatic 13C SpectrumTypes

-- Important: the script uses the EXPECTED chemical shift range for the class of experiments (SpectrumType)
-- I.e. it checks whether your ppm range spans the range "mean-dev" to mean+dev"
-- from the Step of the ExperimentProcedure for each dimension with matching the AtomType.



-- F.Damberger May 15 2007

-- Version 1: May 15 2007 F.Damberger


-- IMPORTANT: The standard template Start1.3.cara has the hsqc13Caro Experiment Procedure defined without any filtering of 13C shifts.
-- This must be changed (it is an error anyway)
-- Step 1 should have mean=125 and dev=25

-- ----------------------------------------------------------------------


-- create array for script variables
t = {}



-- ----------------------------------------------------------------------

-- =================== Define Functions =================================


function TableSize( Table )
	local Size = 0
	for IdNum,Entry in pairs( Table ) do
		Size = Size + 1
	end -- for
	return Size
end -- function TableSize


function AtomNameFromResType( Label, ResType )  -- added in ver.7
	-- purpose: return true if label occurs in ResType
	local result = nil
	for AtomName,Atom in pairs( ResType:getAtoms() ) do
		if Label == AtomName then
			result = true
		end
	end -- for all atoms in ResType
	return result
end -- function AtomNameFromResType

function CreateProjectNamesComboBox( SelectedProjectName )
	ProjectNamesComboBox = gui.createComboBox( t.frm )
	SelectedItemIndex = nil
	for Id,Project in pairs( cara:getProjects() ) do
		ItemIndex = ProjectNamesComboBox:addItem( Project:getName() )
		ProjectNamesComboBox:setCurrentItem( ItemIndex )
		if SelectedProjectName == ProjectNamesComboBox:getCurrentText() then
			SelectedItemIndex = ItemIndex
		end
	end -- for all projects
	if SelectedItemIndex then -- set to previous choice if it exists
		ProjectNamesComboBox:setCurrentItem( SelectedItemIndex )
	end
	return ProjectNamesComboBox
end -- function LoadProjectNamesToComboBox

function CreateSpectraNamesComboBox( Spectra, SelectedSpectrumName )
	SpectraNamesComboBox = gui.createComboBox( t.frm )
	for SpectrumId,Spectrum in pairs( Spectra ) do
		ItemIndex = SpectraNamesComboBox:addItem( Spectrum:getName() )
		SpectraNamesComboBox:setCurrentItem( ItemIndex )
		if SelectedSpectrumName == SpectraNamesComboBox:getCurrentText() then
			SelectedItemIndex = ItemIndex
		end 
	end -- for all Spectra
	if SelectedItemIndex then -- set to previous choice if it exists
		SpectraNamesComboBox:setCurrentItem( SelectedItemIndex )
	end
	return SpectraNamesComboBox
end -- function CreateComboboxFromTable


function GetSpectrum( Project, SpectrumName )
	for Id,Spec in pairs( Project:getSpectra() ) do
		if SpectrumName == Spec:getName() then return Spec end
	end -- for all Spectra
end -- function GetSpectrum

function CreateComboBoxFromTable( SelectedTableElement, Table )
	TableComboBox = nil
	TableComboBox = gui.createComboBox( t.frm )
	SelectedItemIndex = nil
	for Id,TableElement in pairs( Table ) do
		ItemIndex = TableComboBox:addItem( TableElement )
		TableComboBox:setCurrentItem( ItemIndex )
		if SelectedTableElement == TableComboBox:getCurrentText() then
			SelectedItemIndex = ItemIndex
		end -- if match found to existing selection
	end -- for all table elements
	if SelectedItemIndex then TableComboBox:setCurrentItem( SelectedItemIndex ) end
	return TableComboBox
end --function

function CreateLineEditWindow( Value )
	LineEditWindow = nil
	LineEditWindow = gui.createLineEdit( t.frm )
	if Value ~= nil then LineEditWindow:setText( Value )
	else LineEditWindow:setText( 0.0 )
	end
	return LineEditWindow
end -- function CreateLineEdit

function ShiftRange( Spec, Dim ) -- determines the range of chemical shift excited by a spectral dimension
	SpecType = Spec:getType() --    This is NOT the ppm range of the spectrum, it is the ppm range of the step from the SpectrumType!
	RangeStart = nil		--      The idea is that you can select spectra that SHOULD have signals in the range of aromatics for example: 100 140
	print("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;")
	print("Name of spectrum type:  "..SpecType:getName() ) -- TEST
	for StepNum=1,SpecType:getStepCount() do
		--print("Step :"..StepNum)
		Step=SpecType:getStep( StepNum )
		print("StepDim:")
		print(Step["dim"])
		print(Step["mean"])
		print(Step["dev"])
		if Step["dim"]==Dim then
			mean = Step["mean"]
			dev = Step["dev"]
			if mean == nil or dev == nil then
				RangeStart = nil			--return nil if range is infinite
				RangeEnd = nil
			else
			RangeStart = mean - dev
				RangeEnd = mean + dev
				print(RangeStart,RangeEnd)
			end
		end
	end
	if RangeStart == nil then -- nil means infinite range
		return
	else
		RangeTable2 = {}
		RangeTable2[1]=RangeStart;RangeTable2[2]=RangeEnd
		return RangeTable2
	end
end -- function ShiftTypeOf

function FallsInRange( TestRange, FullRange ) -- returns true if TestRange falls inside FullRange
	if FullRange == nil or FullRange[1]==nil or FullRange[2] == nil then -- range is infinite
		return true
	elseif FullRange and not TestRange then -- TestRange is infinite (larger than FullRange)
		return false
	else
		TestMin,TestMax=TestRange[1],TestRange[2]
		FullMin,FullMax=FullRange[1],FullRange[2]
		if TestMin &gt; TestMax then error("Range is invalid, start must be smaller than end") end
		if TestMin &gt; FullMin and TestMax &lt; FullMax then
			TestMinText = TestMin;TestMaxText=TestMax
			FullMinText = FullMin;FullMaxText=FullMax
			print("Spectrum dimension has range: "..TestMinText.." - "..TestMaxText)
			print("Falls within specified range: "..FullMinText.." - "..FullMaxText)
		    print("and will be corrected!")
			return true
		else
			return false
		end
	end
end -- function FallsInRange

--===================END OF FUNCTION DEFINITIONS ========================


-- ================== SOME PARAMETER DEFINITIONS ========================



-- ============Set up menu window for user preferences===================
AtomTypes = { "H", "C", "N" }

--0. Check whether there are any projects available
ProjectsTable = cara:getProjects()

if TableSize( ProjectsTable ) == 0 then error("No projects found in repository") end


--1. Create main menu window

v = gui.createMainWindow()
v:setCaption( "RecalibrateSpectrum Settings" )
t.frm = gui.createGrid( v, 2, false )
v:setCentralWidget( t.frm )
v:show()
t.frm:show()

-- Project Selector
t.ProjectListLabel = gui.createLabel( t.frm, "Select Project" )
t.ProjectListCB = CreateProjectNamesComboBox( ProjectName )


-- Display ProjectList Combobox
t.ProjectListLabel:show()
t.ProjectListCB:show()

print( t.ProjectListCB:getCurrentText() )
t.Project = cara:getProject( t.ProjectListCB:getCurrentText() )

-- Create AtomType Table Selector
t.AtomTypeLabel = gui.createLabel( t.frm, "Select AtomType of Spins to change shift")
t.AtomTypeCB = CreateComboBoxFromTable( SelectedAtomType, AtomTypes )

-- Display AtomType Table ComboBox
t.AtomTypeLabel:show()
t.AtomTypeCB:show()

-- Create Floating point field for ShiftSize
t.ShiftLELabel = gui.createLabel( t.frm, "Enter the magnitude of the shift change to apply in ppm: e.g. -1.0")
t.ShiftLE = CreateLineEditWindow( ShiftChange )

-- Display ShiftSize LineEditWindow
t.ShiftLELabel:show()
t.ShiftLE:show()

-- Create Floating point field for ShiftRange Start
t.StartOfRangeLELabel = gui.createLabel( t.frm, "Enter the range of ppm to make the correction in  LOW ppm: set both to zero for infinite ppm range" )
t.StartOfRangeLE = CreateLineEditWindow( StartOfRange )
-- Create Floating point field for ShiftRange End
t.EndOfRangeLELabel = gui.createLabel( t.frm, "Enter the range of ppm to make the correction in  HIGH ppm: set both to zero for infinite ppm range" )
t.EndOfRangeLE = CreateLineEditWindow( EndOfRange )

t.StartOfRangeLELabel:show()
t.StartOfRangeLE:show()
t.EndOfRangeLELabel:show()
t.EndOfRangeLE:show()



--9. OK and Cancel Buttons

t.okbutton = gui.createPushButton(t.frm, "OK" )
t.cancelbutton = gui.createPushButton( t.frm, "Cancel" )

t.okbutton:show()
t.cancelbutton:show()


-- ============Callbacks for menu window ===================

-- Define Callbacks for the buttons


-- cancel button Callback
t.cancelbutton:setCallback( gui.event.Clicked,
	function (self)
		v:close()
	end
) -- end cancel button Callback

-- OK button Callback
t.okbutton:setCallback( gui.event.Clicked,
	function (self)
-- =============== Determine User Preferences ===========================

		t.Project = cara:getProject( t.ProjectListCB:getCurrentText() )
		ProjectName = t.Project:getName()
		print("Project name is "..ProjectName)
		SelectedAtomType = t.AtomTypeCB:getCurrentText()
		print("AtomType is "..SelectedAtomType)
		ShiftChange = t.ShiftLE:getText()
		print("ShiftChange is "..ShiftChange)
		StartOfRange = tonumber( t.StartOfRangeLE:getText() )
		EndOfRange = tonumber( t.EndOfRangeLE:getText() )
		if not StartOfRange or not EndOfRange or ( StartOfRange == 0 and EndOfRange == 0 ) then
			RangeText = "infinite"
			UserRange = nil
		else
			if StartOfRange &gt;= EndOfRange then error("Invalid range was entered: StartOfRange must be less than EndOfRange.") end
			RangeText = StartOfRange.."  -  "..EndOfRange
			UserRange = {}
			UserRange[1] = StartOfRange; UserRange[2] = EndOfRange
		end
		print("Spectral dimensions whose excitation range falls within the ppm range "..RangeText.." will be corrected")
		print("----------------------------------------------------------------------------------------")
		for specId,Spectrum in pairs( t.Project:getSpectra() ) do
			for DimId = 1,Spectrum:getDimCount() do
				--SpectrumsRange = ShiftRange( Spectrum, DimId )
				--print("Spectrums AtomType in Dim "..DimId.." : "..Spectrum:getAtomType( DimId ) )
				HeaderWritten = false
				if SelectedAtomType == Spectrum:getAtomType( DimId ) and FallsInRange( ShiftRange( Spectrum, DimId ), UserRange ) then
					if not HeaderWritten then
						HeaderWritten = true
						print("======== Correcting Dimensions for Spectrum : "..Spectrum:getName().." with ID: "..specId.."========")
					end
					print( "Dim="..DimId.." has selected AtomType "..SelectedAtomType )
					t.OldCal = t.Project:getCalibration( specId, DimId )
					t.NewCal = t.OldCal + ShiftChange
					print( "Old calibration:"..t.OldCal.."     New calibration:"..t.NewCal )
					t.Project:setCalibration( specId, DimId, t.NewCal )
					--print( "New calibration in dimension "..DimId.." "..t.Project:getCalibration( specId, DimId ) )		
				end -- if current dim has selected AtomType
			end -- for all Dimensions of current Spectrum
		end -- for all spectra in project
		v:close()
	end
) -- end OK button Callback

-- End of script FD.

</code>
<fld name='Creation Date' type='Date'>2007-5-15</fld>
</script>
<script name='CopyPeakAmpToVol'>
<code lang='Lua'>-- script to copy peak amplitudes to volumes
-- allowing intensities to be written out in place of volumes

-- F.Damberger May 25 2004.

-- create array for script variables
t = {}
-- ----------------------------------------------------------------------
--1. Get ProjectName
local ProjectNames = {}
i = 0
for a,b in pairs(cara:getProjects()) do
	i = i + 1
	ProjectNames[ i ] = b:getName()
	print(ProjectNames[ i ])
end
t.ProjectName=dlg.getSymbol("Select Project","", unpack( ProjectNames ) )
t.P = cara:getProject( t.ProjectName )

-- ---------------------------------------------------------------------
--2. Get PeakList
local PeakListNames = {}
local PeakListIds = {}
i=0
for a,b in pairs(t.P:getPeakLists()) do
	i = i + 1
	PeakListIds[ i ] = b:getId()
	PeakListNames[ i ] = b:getName()
	-- print(b:getName())
	print(PeakListNames[ PeakListIds[ i ] ])
end

t.PeakListName=dlg.getSymbol("Select PeakList","", unpack( PeakListNames ) )
print( "before loop PeakListName ="..t.PeakListName)

i=0
for i=1,table.getn( PeakListNames ) do
	if t.PeakListName == PeakListNames[ i ] then	
		t.PeakListId = PeakListIds[ i ]
		t.PeakList = t.P:getPeakList( PeakListIds[ i ] )
	end
end


-- ---------------------------------
--3. Copy Amplitudes to Volume in specified Peaklist

t.Peaks = t.PeakList:getPeaks()

i = 0

for a,b in pairs( t.Peaks ) do
--	print("peakamplitude = "..b:getAmp() )
--	print("peakvolume = "..b:getVol() )
	if a &gt; 277 then -- 4092 for Cali, 277 for Caro
		t.PeakList:setVol(b, b:getAmp() )
		print("copying amp to vol for peak "..b:getId() )
		t.PeakList:setColor( b, 2 )
		i = i + 1
	end
end
print("amplitudes copied to volumes for "..i.." peaks")

t = nil
</code>
<fld name='Creation Date' type='Date'>2007-2-26</fld>
</script>
<script name='SelectPeakTower-f1f3'>
<code lang='Lua'>-- SelectPeakTower-f1f3.lua
-- script to select a tower of peaks within a range of f1 and f3
-- The f1 and f3 positions are derived from the chemical shifts of the selected spins (see user input)
-- All peaks are written to a new peaklist which have
--    f1 coordinate: f1start &lt; f1peak &lt; f1finish
--      AND										 (NOEs to other protons in the NOE tower of f1,f3 signal)
--    f3 coordinate: f3start &lt; f3peak &lt; f3finish
-- OR
--    f2 coordinate: f2start &lt; f2peak &lt; f2finish  (NOE to the f2 proton freq of signal)

-- F.Damberger February 27 2007.

-- user input
SystemId=267 -- enter the system number
Hlabel="HE" -- enter the label of the spin whose chemical shift determines f3 of the tower
Xlabel="CE" -- enter the label of the spin whose chemical shift determines f1 of the tower

t.Htol = 0.025 -- H tolerence for peaks belonging to tower
t.Ctol = 0.3 -- C tolerence for peaks belonging to tower


-- Do not edit below this line ---------------------------------------------------------------------------------

-- Function definitions


function PeakIsInRange( b )
	f1pos,f2pos,f3pos = b:getPos()
	--print("==== Peak "..b:getId().." ===" ) -- TEST
	--print(f1pos,f2pos,f3pos) -- TEST
	--print(t.f3start,t.f3finish) -- TEST
	--print(t.f1start,t.f1finish) -- TEST
	
	if t.PeakList:getAtomType( 3 ) == SelectedX:getAtomType() and t.f3start &lt; f3pos and f3pos &lt; t.f3finish then
		if t.f1start &lt; f1pos and f1pos &lt; t.f1finish then
			print("Found tower peak")
			return true -- f1 and f3 dimension match
		end
	end
	
	if t.f2start &lt; f2pos and f2pos &lt; t.f2finish then
		print("Found NOE to f2freq")
		return true	-- f2 dimension matches
	end
	return false
end

function GetSpinWithUniqueLabel( Sys, Label )
	NumOfMatches = 0
	result = nil
	for SpinId,Spin in pairs( Sys:getSpins() ) do
		if Spin:getLabel() == Label then
			NumOfMatches = NumOfMatches + 1
			MatchingSpin = Spin
		end
	end
	if NumOfMatches == 1 then result = MatchingSpin end
	return result
end

function Fold( Value, Min, Max )
	NumFold = 0
	while Value &lt; Min or Value &gt; Max do
	if
		Value &lt; Min then Value = Value + ( Max - Min )
		NumFold = NumFold + 1
	elseif
		Value &gt; Max then Value = Value - ( Max - Min )
		NumFold = NumFold - 1
	else
		print("Fold is done: Value = "..Value.." NumFold = "..NumFold )
	end

	end -- while
	return Value,NumFold
end

function GetPpmRange( Spec, Dim ) -- gets the correct SpectralWidth, Min and Max Ppms for a Spectrum "Spec" Dimension "Dim"
                                   -- This is necessary because CARA function getPpmRange reports Min Ppm plus Half Dwell and Max Ppm minus half Dwell
	-- check if spectrum exists
	if not ( Spec and Spec:getId() ) then error("function GetPpmMinMax: did not find spectrum in parameters") end
	-- check dim against DimCount
	DimFound = false
	for i=1,Spectrum:getDimCount() do
		if i == Dim then DimFound = true end
	end
	if not DimFound then error("function GetPpmMinMax: did not find Dim "..Dim.." in spectrum "..Spec:getName() ) end

	Max,Min = Spectrum:getPpmRange( Dim )
	SWcara = Max - Min
	Points = Spectrum:getSampleCount( Dim )
	print(Points)
	Min = Min - 0.5 * SWcara / ( Points - 1 )
	Max = Max + 0.5 * SWcara / ( Points - 1 )
	SWreal = Max - Min
	return SWreal, Min, Max
end -- function GetPpmRange

-- -- end of function definitions


-- create array for script variables
t = {}
-- ----------------------------------------------------------------------
--1. Get ProjectName
local ProjectNames = {}
i = 0
for a,b in pairs(cara:getProjects()) do
	i = i + 1
	ProjectNames[ i ] = b:getName()
	print(ProjectNames[ i ])
end
t.ProjectName=dlg.getSymbol("Select Project","", unpack( ProjectNames ) )
t.P = cara:getProject( t.ProjectName )

-- ---------------------------------------------------------------------
--2. Get PeakList
local PeakListNames = {}
local PeakListIds = {}
i=0
for a,b in pairs(t.P:getPeakLists()) do
	i = i + 1
	PeakListIds[ i ] = b:getId()
	PeakListNames[ i ] = b:getName()
	-- print(b:getName())
	print(PeakListNames[ PeakListIds[ i ] ])
end

t.PeakListName=dlg.getSymbol("Select PeakList","", unpack( PeakListNames ) )
print( "before loop PeakListName ="..t.PeakListName)

i=0
for i=1,table.getn( PeakListNames ) do
	if t.PeakListName == PeakListNames[ i ] then	
		t.PeakListId = PeakListIds[ i ]
		t.PeakList = t.P:getPeakList( PeakListIds[ i ] )
	end
end

--Sys252
--t.C13value = 15.882
--t.C13value = 38.86 -- folded position

-- Sys250
--t.H1value = 1.902
--t.C13value = 16.697 + 23.0099 --ignore tower

SelectedSystem=t.P:getSystem( SystemId )
if not SelectedSystem then error("Not a valid system Id") end
SelectedH=GetSpinWithUniqueLabel( SelectedSystem, Hlabel )
SelectedX=GetSpinWithUniqueLabel( SelectedSystem, Xlabel )
if not SelectedH then error("There is not a spin in the system with the label"..Hlabel ) end
if not SelectedX then error("There is not a spin in the system with the label"..Xlabel ) end

-- find out if AtomType for dim 3 of selected Spectrum matches that of the selected spin X
-- I know do this in the function PeakIsInRange

--if SelectedX:getAtomType() == t.PeakList:getAtomType( 3 ) then

	-- get SpectralWidth of corresponding spectrum
	--Spectrum=t.PeakList:getHome() -- Unfortunately "getHome" does not exist
	Spectrum = t.P:getSpectrum( t.PeakList:getAttr("owner") ) -- so I defined an attribute "owner" and set it for each peaklist
	if not Spectrum then error("Did not get spectrum owning the selected peaklist") end -- TEST
	--print("Spectrum has value : "..Spectrum) --TEST
	value=Spectrum:getId() -- TEST
	print("Checking folding in spectrum "..Spectrum:getName() )
	print("Spectrum:getId() is "..value) -- TEST
	t.SW,t.StartOfSW,t.FinishOfSW=GetPpmRange( Spectrum, 3 )
	print( "Spectrum has the following Ppm range "..t.StartOfSW,t.FinishOfSW.." SW = "..t.SW )
	-- fold the chemical shift
	if SelectedX:getAtomType() == t.PeakList:getAtomType( 3 ) then -- only fold it if the AtomType matches to that of Spectrums dim 3
		t.C13value,t.NumFolded = Fold( SelectedX:getShift(), t.StartOfSW, t.FinishOfSW )
	else
		t.C13value = SelectedX:getShift()
		t.NumFolded = 0
	end
	--error("Finishing the testing here")--TEST
--[[
else -- SelectedX spin does not have atomType of the spectrum
	t.C13value = 999.0 -- ignore this shift
end
]]


t.H1value = SelectedH:getShift()
--t.C13value = SelectedX:getShift() + 23.0099 --ignore tower

print(" ===================================================================================")
print("Searching for NOEs involving System "..SystemId.." spins with the following shifts")
print("shift of "..SelectedH:getAtomType().." Spin "..SelectedH:getId().." with label "..SelectedH:getLabel().."  : "..t.H1value )
print("shift of "..SelectedX:getAtomType().." Spin "..SelectedX:getId().." with label "..SelectedX:getLabel().."  : "..t.C13value)
print(" ===================================================================================")

-- ---------------------------------
-- 4. Get Ppm start and finish f1
t.f1AtomType = "H"
t.f1start = t.H1value - t.Htol
t.f1finish = t.H1value + t.Htol

-- ---------------------------------
-- 4. Get Ppm start and finish f2

t.f2AtomType = "H"
t.f2start = t.H1value - t.Htol
t.f2finish = t.H1value + t.Htol


-- ---------------------------------
-- 5. Get Ppm start and finish f3
t.f3AtomType = SelectedX:getAtomType()
t.f3start = t.C13value - t.Ctol
t.f3finish = t.C13value + t.Ctol

-- ---------------------------------
-- 3. Get Output Peaklist name
-- getSpectrum Dim3 type:
Tag=t.PeakList:getAtomType(3)
if t.PeakList:getAtomType(3) == "C" then
	if t.StartOfSW &gt;90 and t.FinishOfSW  &lt; 160 then -- its an aromatic dimension
		Tag = Tag.."aro"
	else
		Tag = Tag.."ali"
	end
end
t.OutputPeakListName = "Sys"..SystemId.."-"..Tag.."-ID"..t.PeakList:getId()..".peaks"

-- open output peaklist

t.OutputPeakList = spec.createPeakList( t.f1AtomType, t.f2AtomType, t.f3AtomType )

-- ---------------------------------

--3. Copy Amplitudes to Volume in specified Peaklist

t.Peaks = t.PeakList:getPeaks()

i = 0

for a,b in pairs( t.Peaks ) do
--	print("peakamplitude = "..b:getAmp() )
--	print("peakvolume = "..b:getVol() )
-- t.X,t.Y,t.Z=b:getPos()
--print("*** Peak "..a..":  "..t.X.." "..t.Y.." "..t.Z.." ***" ) -- TEST
	if b:getColor() == 2 and PeakIsInRange( b ) then
		Peak = t.OutputPeakList:createPeak( b:getPos() )
		t.X,t.Y,t.Z = Peak:getPos()
		print("Created peak: "..string.format("%3.3f",t.X),string.format("%3.3f",t.Y),string.format("%3.3f",t.Z) )
		t.OutputPeakList:setColor( Peak, b:getColor() )
		t.OutputPeakList:setVol( Peak, b:getVol() )
		i = i + 1
	end
end
print("created "..i.." peaks in new peaklist written to external file "..t.OutputPeakListName )

-- ---------------------------------
-- X. Write out peaklist

t.OutputPeakList:saveToFile( t.OutputPeakListName )

--t = nil
</code>
<fld name='Creation Date' type='Date'>2007-2-27</fld>
</script>
<script name='GetSpectrum'>
<code lang='Lua'>-- script to select a spectrum from a project using Combobox Selector widgets (just a test script)
-- sets the value of SelectedSpectrum = Spectrum

-- F.Damberger Feb 16 2007

-- Version 1: Feb 16 2007 F.Damberger



-- ----------------------------------------------------------------------


-- create array for script variables
t = {}



-- ----------------------------------------------------------------------

-- =================== Define Functions =================================


function TableSize( Table )
	local Size = 0
	for IdNum,Entry in pairs( Table ) do
		Size = Size + 1
	end -- for
	return Size
end -- function TableSize


function AtomNameFromResType( Label, ResType )  -- added in ver.7
	-- purpose: return true if label occurs in ResType
	local result = nil
	for AtomName,Atom in pairs( ResType:getAtoms() ) do
		if Label == AtomName then
			result = true
		end
	end -- for all atoms in ResType
	return result
end -- function AtomNameFromResType

function CreateProjectNamesComboBox( SelectedProjectName )
	ProjectNamesComboBox = gui.createComboBox( t.frm )
	SelectedItemIndex = nil
	for Id,Project in pairs( cara:getProjects() ) do
		ItemIndex = ProjectNamesComboBox:addItem( Project:getName() )
		ProjectNamesComboBox:setCurrentItem( ItemIndex )
		if SelectedProjectName == ProjectNamesComboBox:getCurrentText() then
			SelectedItemIndex = ItemIndex
		end
	end -- for all projects
	if SelectedItemIndex then -- set to previous choice if it exists
		ProjectNamesComboBox:setCurrentItem( SelectedItemIndex )
	end
	return ProjectNamesComboBox
end -- function LoadProjectNamesToComboBox

function CreateSpectraNamesComboBox( Spectra, SelectedSpectrumName )
	SpectraNamesComboBox = gui.createComboBox( t.frm )
	for SpectrumId,Spectrum in pairs( Spectra ) do
		ItemIndex = SpectraNamesComboBox:addItem( Spectrum:getName() )
		SpectraNamesComboBox:setCurrentItem( ItemIndex )
		if SelectedSpectrumName == SpectraNamesComboBox:getCurrentText() then
			SelectedItemIndex = ItemIndex
		end 
	end -- for all Spectra
	if SelectedItemIndex then -- set to previous choice if it exists
		SpectraNamesComboBox:setCurrentItem( SelectedItemIndex )
	end
	return SpectraNamesComboBox
end -- function CreateComboboxFromTable


function GetSpectrum( Project, SpectrumName )
	for Id,Spec in pairs( Project:getSpectra() ) do
		if SpectrumName == Spec:getName() then return Spec end
	end -- for all Spectra
end -- function GetSpectrum

function CreateComboBoxFromTable( SelectedTableElement, Table )
	TableComboBox = nil
	TableComboBox = gui.createComboBox( t.frm )
	SelectedItemIndex = nil
	for Id,TableElement in pairs( Table ) do
		ItemIndex = TableComboBox:addItem( TableElement )
		TableComboBox:setCurrentItem( ItemIndex )
		if SelectedTableElement == TableComboBox:getCurrentText() then
			SelectedItemIndex = ItemIndex
		end -- if match found to existing selection
	end -- for all table elements
	if SelectedItemIndex then TableComboBox:setCurrentItem( SelectedItemIndex ) end
	return TableComboBox
end --function

function CreateLineEditWindow( Value )
	LineEditWindow = nil
	LineEditWindow = gui.createLineEdit( t.frm )
	if Value ~= nil then LineEditWindow:setText( Value )
	else LineEditWindow:setText( 0.0 )
	end
	return LineEditWindow
end -- function CreateLineEdit

--===================END OF FUNCTION DEFINITIONS ========================


-- ================== SOME PARAMETER DEFINITIONS ========================



-- ============Set up menu window for user preferences===================
AtomTypes = { "H", "C", "N" }

--0. Check whether there are any projects available
ProjectsTable = cara:getProjects()

if TableSize( ProjectsTable ) == 0 then error("No projects found in repository") end


--1. Create main menu window

v = gui.createMainWindow()
v:setCaption( "RecalibrateSpectrum Settings" )
t.frm = gui.createGrid( v, 2, false )
v:setCentralWidget( t.frm )
v:show()
t.frm:show()

-- Project Selector
t.ProjectListLabel = gui.createLabel( t.frm, "Select Project" )
t.ProjectListCB = CreateProjectNamesComboBox( ProjectName )


-- Display ProjectList Combobox
t.ProjectListLabel:show()
t.ProjectListCB:show()

print( t.ProjectListCB:getCurrentText() )
t.Project = cara:getProject( t.ProjectListCB:getCurrentText() )

-- Create AtomType Table Selector
t.SpectrumNamesLabel = gui.createLabel( t.frm, "Select Spectrum")
t.SpectrumNamesCB = CreateSpectraNamesComboBox( t.Project:getSpectra(), SelectedSpectrumName )

-- Display AtomType Table ComboBox
t.SpectrumNamesLabel:show()
t.SpectrumNamesCB:show()

--9. OK and Cancel Buttons

t.okbutton = gui.createPushButton(t.frm, "OK" )
t.cancelbutton = gui.createPushButton( t.frm, "Cancel" )

t.okbutton:show()
t.cancelbutton:show()


-- ============Callbacks for menu window ===================

-- Define Callbacks for the buttons


-- cancel button Callback
t.cancelbutton:setCallback( gui.event.Clicked,
	function (self)
		v:close()
	end
) -- end cancel button Callback

-- OK button Callback
t.okbutton:setCallback( gui.event.Clicked,
	function (self)
-- =============== Determine User Preferences ===========================

		t.Project = cara:getProject( t.ProjectListCB:getCurrentText() )
		ProjectName = t.Project:getName()
		print("Project name is "..ProjectName)
		
		SelectedSpectrum = GetSpectrum( t.Project, t.SpectrumNamesCB:getCurrentText() )
		print("Spectrum name is "..SelectedSpectrum:getName() )
		
		--specId = t.Spectrum:getId()
		--dimension=1
		--offset=1.0
		--print( "Calibration in dimension "..dimension.." "..t.Project:getCalibration( specId, dimension ) )
		--t.Project:setCalibration( specId, dimension, offset )
		--print( "Calibration in dimension "..dimension.." "..t.Project:getCalibration( specId, dimension ) )		
		v:close()
	end
) -- end OK button Callback

-- End of script FD.

</code>
<fld name='Creation Date' type='Date'>2007-2-28</fld>
</script>
<script name='UplsToSpinLinks'>
<code lang='Lua'>-- F.Damberger 18.July.2004
-- modified 18.Aug.2004 to include 3D 13C-resolved [1H,1H]-NOESYs in the spectrum list -FFD

-- Short Description
-- The script reads UPLS and converts them to SpinLinks which are made visible in a selected spectrum.
-- User is prompted for a UPL file, a Project, and a Spectrum where the SpinLinks should be displayed
-- There are also some output options to send output for each UPL line to the terminal window.

-- Purpose
-- The script is intended to be used to inport UPLs from a structure calculation for inspection with CARA.
-- The UPL file should be read which contains UPLs determined from a specific NOESY spectrum.
-- The same NOESY spectrum should be selected in the dialog.

-- What it does
-- For each UPL in the UPLfile, the script does the following:
-- Checks whether the two atoms in the UPL have an assignment in the project
-- If yes, it checks whether the SpinLink between the corresponding spins exists in the project
-- If yes, the visibility of this SpinLink is turned ON, so it is visible for the selected spectrum
-- If no, the SpinLink is created, and it is made visible in the selected spectrum

-- Details:
-- for each SpinLink, the SpinLink Parameters ("Set Link Parameters" in the SystemList window) are set so that:
-- 1) the visibility is turned on for the selected spectrum
-- 2) the rating is set equal to the constraint distance
-- 3) the code is set equal to the peaknumber from which the UPL was derived

-- The script gives some feedback if it cannot read a UPL line.
-- After reading the UPL file, a summary is written to the terminal window.
-- If you see "Successfully read all UPLS" you can relax and look at the results in Cara.

t = {}
-- --------------Define Functions --------------------------------------



function FindSpin( Project, ResNum, Label )
	
--	print("FindSpin: ResNum,Label = "..ResNum..","..Label)
	SpinSys = Project:getResidue( ResNum ):getSystem()
--	print("SpinSysId = "..SpinSys:getId() )

	SpinsInSys = SpinSys:getSpins()
	for SpinId,Spin in pairs( SpinsInSys ) do
		if Spin:getLabel() == Label then
			return Spin
		end
	end

end


function IsResidueNumber ( String, LineNumber )

	if not tonumber( String ) then
		error( "UPL file, line number "..LineNumber.." first string is not a number: "..String )
		return false

	elseif not t.P:getResidue( String ) then
		error( "UPL file, line number "..LineNumber.." : not a valid residue number: "..String )
		return false
	end

	return true
end


function IsCorrectResidueType ( String, LineNumber, ResNum )

		ResName = t.P:getResidue( ResNum ):getType():getShort()
--		print("IsCorrectResidueType: ResName = "..ResName )
		if ResName ~= String then
			print("UPL file, line number "..LineNumber.." : residue type does not match sequence: "..String )
			return false
		else
			return true
		end
	
end

function IsConstraint( String, LineNumber )

	if tonumber( String ) and tonumber( String ) &gt; 1.5 and tonumber( String ) &lt; 10.0 then
		return true
	else
		print("UPL file, line number "..LineNumber.." : constraint is not a number between 1.5 and 10.0 : "..String)
		return false
	end
end

function getSpinLink( Project, SpinId1, SpinId2 )


	SpinLinks = Project:getSpinLinks()

	for a,b in pairs( SpinLinks ) do

		if b:getLeft() == SpinId1 and b:getRight() == SpinId2 or b:getLeft() == SpinId2 and b:getRight() == SpinId1 then
--			print("found spin link")
			return b -- return spinlink
		end
	end
--    print("Did not find SpinLink: SpinID1 = "..SpinId1.." SpinID2 = "..SpinId2 )
	return	-- return nil if no spinlink found
end
-- ------------ Selection Dialogs --------------------------------------

--1. Get UPL file location
UplFileLocation = dlg.getOpenFileName( "Select a UPL file", "*.upl" )

--2. Get ProjectName
local ProjectNames = {}
i = 0
for a,b in pairs(cara:getProjects()) do
	i = i + 1
	ProjectNames[ i ] = b:getName()
end
t.ProjectName=dlg.getSymbol("Select Project","", unpack( ProjectNames ) )
t.P = cara:getProject( t.ProjectName )

--3. Get Spectrum

local SpectrumNames = {}
local SpectrumIds = {}
i = 0
for id,spectrum in pairs( t.P:getSpectra() ) do
	if spectrum:getDimCount() == 3 and spectrum:getAtomType(1)=="H" and (spectrum:getAtomType(3)=="N" or spectrum:getAtomType(3)=="C") then
	-- spectrum is a 3D with AtomType H in Dim1 and N in Dim3
		i = i + 1
		SpectrumIds[ i ] = spectrum:getId()
		SpectrumNames[ i ] = spectrum:getId()..":"..spectrum:getName()
	end
end
t.SpectrumName = dlg.getSymbol( "Select Spectrum","", unpack( SpectrumNames ) )
for i = 1,table.getn( SpectrumNames ) do
	if SpectrumNames[ i ] == t.SpectrumName then
		t.Spectrum = t.P:getSpectrum( SpectrumIds[ i ] )
	end
end

--4. Get OutPut preference

t.PrintOutUpls =dlg.getSymbol(" Print out UPLs read to terminal window? ", "Select YES or NO", "NO", "YES" )

t.ReportAll = dlg.getSymbol(" Include Trouble Shoot Report for Script? ", "Select YES or NO", "NO", "YES" )

-- ------------ Read in UPLs --------------------------------------

NumUpl = 0
linenumber = 0

t.UplLine = {}

t.ResNum1 = {}
t.ResNum2 = {}
t.ResName1 = {}
t.ResName2 = {}
t.Label1 = {}
t.Label2 = {}
t.Constraint = {}
t.PeakNum = {}
t.Sup = {}
t.BadLine = false

print(" Reading in lines from UPL file: ")

for line in io.lines( UplFileLocation ) do

	local ABadLine = false

	linenumber = linenumber + 1
	if t.ReportAll == "YES" then
		print("LINE: "..linenumber..": "..line)
	end

	t.UplLine[NumUpl] = line
	newline = " "
	t.Parse = string.gfind( line, "%S+" )
	j = 0
	local FoundUpl = false
	local FoundPeak = false
	local FoundSup = false

	local ResNum1, ResNum2, ResName1, ResName2, Label1, Label2, Constraint, PeakNum, Sup


	for Word in t.Parse do

		if not ABadLine then

			if j == 0 then
				if not IsResidueNumber( Word, linenumber ) then
					ABadLine = true
				else
					ResNum1 = Word
					j = j + 1
				end

			elseif j == 1 then
				if not IsCorrectResidueType( Word, linenumber, ResNum1 ) then
					ABadLine = true
				else
					ResName1 = Word
					j = j + 1
				end

			elseif j == 2 then
				if not FindSpin( t.P, ResNum1, Word ) then
					ABadLine = true
				else
					Label1 = Word
					j = j + 1
				end

			elseif j == 3 then
				if not IsResidueNumber( Word, linenumber ) then
					ABadLine = true
				else
					ResNum2 = Word
					j = j + 1
				end

			elseif j == 4 then
				if not IsCorrectResidueType( Word, linenumber, ResNum2 ) then
					ABadLine = true
				else 
					ResName2 = Word
					j = j + 1
				end

			elseif j == 5 then
				if not FindSpin( t.P, ResNum2, Word ) then
					print("UPL file: linenumber "..linenumber.." not a valid label for atom2: "..Word )
					ABadLine = true
				else
					Label2 = Word
					j = j + 1
				end

			elseif j == 6 then
				if not IsConstraint( Word, linenumber ) then
					ABadLine = true
				else
					Constraint = Word
					FoundUpl = true
					j = j + 1
				end

			elseif j == 7 and Word == "#peak" then
				FoundPeak = true
				j = j + 1

			elseif j == 8 and FoundPeak and tonumber( Word )  then
				PeakNum = Word
				j = j + 1

			elseif j == 9 and Word == "#SUP" then
				FoundSup = true
				j = j + 1

			elseif j == 10 and FoundSup and tonumber( Word ) then
				Sup = Word
				j = j + 1

			else
				-- Do nothing
			end -- if statement to get Word to Upl Array
			-- print("linenumber "..linenumber.." j = "..j)

		end -- if not ABadLine
		if ABadLine then
			t.BadLine = true
		end
	
	end -- for all Words in line
	if FoundUpl then
		-- assign UPL to array

		NumUpl = NumUpl + 1
--		print("found Upl, total = "..NumUpl)

		t.ResNum1[ NumUpl ] = ResNum1
		t.ResNum2[ NumUpl ] = ResNum2
		t.ResName1[ NumUpl ] = ResName1
		t.ResName2[ NumUpl ] = ResName2
		t.Label1[ NumUpl ] = Label1
		t.Label2[ NumUpl ] = Label2
		t.Constraint[ NumUpl ] = Constraint
		t.PeakNum[ NumUpl ] = PeakNum
		t.Sup[ NumUpl ] = Sup

		-- report
		if t.ReportAll == "YES" then
			local k = NumUpl
			UPLline = "UPL : "..k.."    "..t.ResNum1[k].." "..t.ResName1[k].." "..t.Label1[k].."      "..t.ResNum2[k].." "..t.ResName2[k].." "..t.Label2[k].."     "..t.Constraint[k]
			if t.PeakNum[k] then
				UPLline = UPLline.."            #peak     "..t.PeakNum[k]
			end
			if t.Sup[k] then
				UPLline = UPLline.." #SUP  "..t.Sup[k]
			end
			print( UPLline )
		end -- ReportAll		
		
	end -- if FoundUpl

end -- for all Lines in UPL file







-- ------------------ Create SpinLinks ----------------------------
t.Spins = t.P:getSpins()
NumSpinPairs = 0
NumLinksModified = 0
NumLinksCreated = 0
for i=1,NumUpl do
	UplLine = t.ResNum1[i].." "..t.ResName1[i].." "..t.Label1[i].." "..t.ResNum2[i].." "..t.ResName2[i].." "..t.Label2[i].." "..t.Constraint[i]
	if t.PeakNum[i] then
		UplLine = UplLine.." #peak "..t.PeakNum[i]
		if t.Sup[i] then UplLine = UplLine.." #SUP "..t.Sup[i] end
	end -- if t.PeakNum[i]
	if t.PrintOutUpls == "YES" then
		print( UplLine )
	end -- if t.PrintOutUpls

		Spin1 = FindSpin( t.P, t.ResNum1[i], t.Label1[i] )
		Spin2 = FindSpin( t.P, t.ResNum2[i], t.Label2[i] )

	-- Create SpinLink that is visible in selected spectrum
		if Spin1 and Spin2 then
			NumSpinPairs = NumSpinPairs + 1
			SpinLink = getSpinLink( t.P, Spin1:getId(), Spin2:getId() )

			if t.Constraint[i] then
				t.Rating = t.Constraint[i]
			else
				t.Rating = 0.0
			end -- if t.Constraint[i]

			if t.PeakNum[i] then
				t.Code = t.PeakNum[i]
			else
				t.Code = 0
			end -- if t.PeakNum[i]

			if SpinLink then
				NumLinksModified = NumLinksModified + 1
				t.Vis = SpinLink:isVisible( t.Spectrum )
				-- t.Rating = SpinLink:getRating( t.Spectrum )
				-- t.Code = SpinLink:getCode( t.Spectrum )
				t.P:setLinkParams( SpinLink, t.Spectrum, t.Rating, t.Code, true )
			else
				NumLinksCreated = NumLinksCreated + 1
				if t.ReportAll == "YES" then
					print("creating spinlink from Spin1 = "..t.ResNum1[i].." "..t.Label1[i].." to Spin2 = "..t.ResNum2[i].." "..t.Label2[i])
				end
				SpinLink = t.P:linkSpins( Spin1, Spin2 )
				t.P:setLinkParams( SpinLink, nil, t.Rating, t.Code, false ) -- not visible in other spectra
				t.P:setLinkParams( SpinLink, t.Spectrum, t.Rating, t.Code, true )
			end -- if SpinLink

		else
			print("could not find Spin1 = "..t.ResNum1[i].." "..t.Label1[i].." and/or Spin2 = "..t.ResNum2[i].." "..t.Label2[i])
		end -- if Spin1 and Spin2
end -- for i=1,NumUpl

print("===============================================================")


if t.BadLine then
		print(" Found lines with incorrect format or inconsistent data in UPL file.")
else
		print(" Successfully read all UPLs. ")
end -- if t.BadLine

print( "Number of UPLs read = "..NumUpl )
print( "Number of Spin Pairs found = "..NumSpinPairs )
print(" Number of Spin Links modified = "..NumLinksModified )
print(" Number of Spin Links created = "..NumLinksCreated )

t = nil
</code>
<fld name='Creation Date' type='Date'>2007-3-1</fld>
</script>
<script name='ShowNoesInMolmol'>
<code lang='Lua'>-- ShowNoesInMolmol.lua
-- F.Damberger 30.March 2007
-- Version 1
--
-- Purpose: supports manual assignment of NOEs based on structure
--
-- Action: generates a molmol macro which displays target atom in one color and
--          all atoms whose chemical shift is within a tolerance value of an
--          entered chemical shift in a second color.

-- How to use it: 1. Display a NOESY strip of an atom
--                2. Click on an NOE in the strip
--                3. Execute the script and 
--                     a. select the project
--                     b. enter the residue number and atom name of strip
--                     c. enter the chemical shift of the NOE
--               4. OK generates the macro "DisplayNoes.mac" in the default directory (where you started CARA)
--               5. Open Molmol and load the structure
--               6. display the backbone
--               7. execute the user macro: ShowNoes.mac (or whatever you entered in the Filename field)
--               8. Inspect the positions of TargetAtom(cyan) and Candidate Atoms(magenta)and Select a good match if there is one
--               9. Add the spinlink for this NOE using "Propose Spin" in the strip of CARA
--

-- Edit preferences here
--------------------------------------------------
AtomRadius = 0.36
TargetAtomColor={0.000,1.000,1.000}    -- cyan (from Molmol)
CandidateAtomColor={1.000,0.000,1.000} -- magenta (from Molmol)
--------------------------------------------------
-- end of preferences

-- FUNCTION DEFINITIONS -------------------------------------------

function TableSize( Table ) -- added in ver.4
	local Size = 0
	for IdNum,Entry in pairs( Table ) do
		Size = Size + 1
	end -- for
	return Size
end -- function TableSize

function WriteShowShift( Spin )
	FormattedShift = string.format( "%3.3f", Spin:getShift() )
	t.Lines=t.Lines.."\n".."# Spin with Id: "..Spin:getId().." has matching shift: "..FormattedShift
end


function WriteShowAtom( Res, Atom, Color )
	AtomNameInMolmol = ConvertAtomNameToDyanaFormat( Atom:getName(), Res:getType():getShort() )
	ColorString=""
	for a,b in pairs(Color) do
	  ColorString=ColorString.." "..b
	end
	t.Lines=t.Lines.."\n".."SelectAtom 'res.num="..Res:getId().." &amp; atom.name=\""..AtomNameInMolmol.."\"'"
	t.Lines=t.Lines.."\n".."StyleAtom sphere"
	t.Lines=t.Lines.."\n".."RadiusAtom "..AtomRadius
	t.Lines=t.Lines.."\n".."ColorAtom "..ColorString
end


function GetSpinsWithMatchingShift( TargetSpin, Shift, Tol )
	-- using global variables:
	-- t.P
	
--	Shift = -0.16
--	Tol = 0.025
	
	i = 0
    MatchingSpins = {}
	Spins = t.P:getSpins()
	for Id,Spin in pairs( Spins ) do
		if Spin ~= TargetSpin then
			if math.abs( tonumber( Shift ) - tonumber( Spin:getShift()) ) &lt; tonumber( Tol ) then
				i = i + 1
				MatchingSpins[i] = Spin
			end
		end
	end
	return i,MatchingSpins
end

function AssignmentOfSpin( Spin )
	Sys = Spin:getSystem()
	if Sys then
		AssignedRes = Sys:getResidue()
		if AssignedRes then
			ResTyp = AssignedRes:getType()
			AssignedAtom = ResTyp:getAtom( Spin:getLabel() )
		end
	end
	return AssignedRes,AssignedAtom
end

function ConvertAtomNameToDyanaFormat( AtomName, ResName )
	-- Not proud of this, FFD
	if AtomName == "H" then
		AtomName = "HN"
	end -- rename all amides

	if ResName ~= "THR" and  ResName ~= "ILE" and ResName ~= "VAL" then -- if NOT Beta-branched
		if AtomName == "HB" then AtomName = "QB" end
	end
	
	if ResName == "THR" then
		if AtomName == "HG2" then AtomName = "QG2" end
	end

	if ResName == "GLU" or ResName == "GLN" or ResName == "MET" or ResName == "ARG" or ResName == "LYS" or ResName == "PRO" then -- contains gamma methylene
		if AtomName == "HG" then AtomName = "QG" end
	end
	
	if ResName == "MET" or ResName == "ARG" or ResName == "LYS" or ResName == "PRO" then -- contains delta and epsilon methylene
		if AtomName == "HD" then AtomName = "QD" end
	end
	
	if ResName == "MET" or ResName == "LYS" or ResName == "PRO" then -- contains delta and epsilon methylene
		if AtomName == "HE" then AtomName = "QE" end
	end
	
	if ResName == "LYS" then
		if AtomName == "HZ" then AtomName = "QZ" end
	end
	
	if ResName == "GLY" then
		if AtomName == "HA3" then AtomName = "HA1" end
		if AtomName == "HA" then AtomName = "QA" end
	end

	if ResName == "ILE" then
		if AtomName == "HG1" then AtomName = "QG1" end
		if AtomName == "HG2" then AtomName = "QG2" end
		if AtomName == "HD1" then AtomName = "QD1" end
	end
	
	if ResName == "VAL" then
		if AtomName == "HG1" then AtomName = "QG1" end
		if AtomName == "HG2" then AtomName = "QG2" end
		if AtomName == "HG" then AtomName = "QQG" end
	end
	
	if ResName == "LEU" then
		if AtomName == "HD1" then AtomName = "QD1" end
		if AtomName == "HD2" then AtomName = "QD2" end
		if AtomName == "HD" then AtomName = "QQD" end
	end
	
	-- aromatic sidechains
	if ResName == "PHE" or ResName == "TYR" then
		if AtomName == "HD" then AtomName = "QD" end
		if AtomName == "HE" then AtomName = "QE" end
		if AtomName == "CD" then AtomName = "CD1" end -- added this because dyana.lib does not include pseudoatoms for CD
		if AtomName == "CE" then AtomName = "CE1" end -- added this because dyana.lib does not include pseudoatoms for CE
	end
	
	-- NH2 groups
	if ResName == "ASN" then
		if AtomName == "HD2" then AtomName = "QD2" end
	end
	
	if ResName == "GLN" then
		if AtomNam == "HE2" then AtomName = "QE2" end
	end
	
	if ResName == "ARG" then
		if AtomName == "HH1" then AtomName = "QH1" end
		if AtomName == "HH2" then AtomName = "QH2" end
	end

	return AtomName
end -- function ConvertAtomNameToDyanaFormat

-- END OF FUNCTION DEFINITIONS --------------------------------------------

-- create temporary table for script
t = {}
MatchingSpins = {}


-- SET UP MENUS =====================

-- ============Set up menu window for user preferences===================

--0. Check whether there are any projects available
ProjectsTable = cara:getProjects()

if TableSize( ProjectsTable ) == 0 then error("No projects found in repository") end


--1. Create main menu window

v = gui.createMainWindow()
v:setCaption( "ShowNoesInMolmol Preferences" )
t.frm = gui.createGrid( v, 2, false )
v:setCentralWidget( t.frm )
v:show()
t.frm:show()

-- Labels for first two columns
t.ProjectListLabel = gui.createLabel( t.frm, "Select Project" )
t.ProjectListCB = gui.createComboBox( t.frm )


--2. Read ProjectNames into ProjectList combobox

SelectedItemIndex = nil
for Id,Project in pairs( cara:getProjects() ) do
	ItemIndex = t.ProjectListCB:addItem( Project:getName() )
	t.ProjectListCB:setCurrentItem( ItemIndex )
	if AssignmentReportProjectName == t.ProjectListCB:getCurrentText() then
		SelectedItemIndex = ItemIndex
	end
end -- for all projects

-- stop if no projects found

if SelectedItemIndex then -- set to previous choice if it exists
	t.ProjectListCB:setCurrentItem( SelectedItemIndex )
end

-- Display ProjectList Combobox
t.ProjectListLabel:show()
t.ProjectListCB:show()

--3. Determine Output report location ------------------------------------

SelectedItemIndex = nil
t.OutputMethodCBLabel = gui.createLabel( t.frm, "Output sent to" )
t.OutputMethodCB = gui.createComboBox( t.frm )

-- Add Item "File" to ComboBox
ItemIndex = t.OutputMethodCB:addItem( "file" )
t.OutputMethodCB:setCurrentItem( ItemIndex )
if ShowNoesInMolmolOutputMethod == t.OutputMethodCB:getCurrentText() then
	SelectedItemIndex = ItemIndex
end

-- Add Item "terminal window" to ComboBox
ItemIndex = t.OutputMethodCB:addItem( "terminal window" )
t.OutputMethodCB:setCurrentItem( ItemIndex )
if ShowNoesInMolmolOutputMethod == t.OutputMethodCB:getCurrentText() then
	SelectedItemIndex = ItemIndex
end

-- Determine if an output method was selected already
if SelectedItemIndex then
	t.OutputMethodCB:setCurrentItem( SelectedItemIndex )
end

-- Display Label and Combobox for Output Method 
t.OutputMethodCBLabel:show()
t.OutputMethodCB:show()

--4. Determine Output file name ------------------------------------------

-- Create Label and Combobox for Filename
t.FilenameLELabel = gui.createLabel( t.frm, "filename for output" )
t.FilenameLE = gui.createLineEdit( t.frm )

if ShowNoesInMolmolFilename then -- determine if Filename already exists
	t.FilenameLE:setText( ShowNoesInMolmolFilename )
else
	t.FilenameLE:setText( "ShowNoes.mac" ) -- default name
end

-- Display Label and LineEdit window
t.FilenameLELabel:show()
t.FilenameLE:show()

--5. Checkbox LongRange only

t.LongRange_ChBxLabel = gui.createLabel( t.frm, "Display only long range NOEs" )
t.LongRange_ChBx = gui.createCheckBox( t.frm )

if LongRange == "YES" then
	t.LongRange_ChBx:setChecked()
end
t.LongRange_ChBxLabel:show()
t.LongRange_ChBx:show()

--6. Residue number field
t.ResidueNum_LELabel = gui.createLabel( t.frm, "Enter residue number of Atom" )
t.ResidueNum_LE = gui.createLineEdit( t.frm )

if ShowNoesInMolmolResidueNum then
	-- print("User defined SDmult : "..AssignmentReport_SDmult.."\nRepository value of SDmult : "..SDmult_Repository)
	t.ResidueNum_LE:setText( ShowNoesInMolmolResidueNum )
else
	t.ResidueNum_LE:setText( "1" )
end

t.ResidueNum_LELabel:show()
t.ResidueNum_LE:show()

--7. AtomName number field
t.AtomName_LELabel = gui.createLabel( t.frm, "Enter Atom Name" )
t.AtomName_LE = gui.createLineEdit( t.frm )

if ShowNoesInMolmolAtomName then
	-- print("User defined SDmult : "..AssignmentReport_SDmult.."\nRepository value of SDmult : "..SDmult_Repository)
	t.AtomName_LE:setText( ShowNoesInMolmolAtomName )
else
	t.AtomName_LE:setText( "HA" )
end

t.AtomName_LELabel:show()
t.AtomName_LE:show()

--8. Shift field

t.Shift_LELabel = gui.createLabel( t.frm, "Enter shift of NOE in ppm" )
t.Shift_LE = gui.createLineEdit( t.frm )

if ShowNoesInMolmolShift then
	t.Shift_LE:setText( ShowNoesInMolmolShift )
else
	t.Shift_LE:setText( "0.00" )
end

t.Shift_LELabel:show()
t.Shift_LE:show()

--9. Tolerance field

t.Tolerance_LELabel = gui.createLabel( t.frm, "Enter tolerance range for matching shift in ppm" )
t.Tolerance_LE = gui.createLineEdit( t.frm )

if ShowNoesInMolmolTolerance then
	t.Tolerance_LE:setText( ShowNoesInMolmolTolerance )
else
	t.Tolerance_LE:setText( "0.025" )
end

t.Tolerance_LELabel:show()
t.Tolerance_LE:show()


-- DONE setting up user parameter fields

--10. OK and Cancel Buttons

t.okbutton = gui.createPushButton(t.frm, "OK" )
t.cancelbutton = gui.createPushButton( t.frm, "Cancel" )

t.okbutton:show()
t.cancelbutton:show()


-- ============Callbacks for menu window ===================
-- Define Callbacks for the buttons

-- ResidueNum_LE lineEdit Callback
t.ResidueNum_LE:setCallback( gui.event.Changed,
	function (self)
		-- function actions
		-- check if a number was entered:
		StartChar,EndChar,NumberRetrieved = string.find( t.ResidueNum_LE:getText(), "(%d+)" )
		StartChar,EndChar,HalfFloatRetrieved = string.find( t.ResidueNum_LE:getText(), "(%d+)." )
		StartChar,EndChar,FloatRetrieved = string.find( t.ResidueNum_LE:getText(), "(%d+.%d+)" )
		if not NumberRetrieved then
		StartChar,EndChar,NumberRetrieved = string.find( t.ResidueNum_LE:getText(), "--(%d+)" )
		end
		StartChar,EndChar,HalfFloatRetrieved = string.find( t.ResidueNum_LE:getText(), "(%d+)." )
		StartChar,EndChar,FloatRetrieved = string.find( t.ResidueNum_LE:getText(), "(%d+.%d+)" )
		Value = nil
		if NumberRetrieved then Value = NumberRetrieved end
		if HalfFloatRetrieved then Value = string.format( "%d", HalfFloatRetrieved ) end
		if FloatRetrieved then Value = string.format( "%d", FloatRetrieved ) end
		if Value then
			ShowNoesInMolmolResidueNum = Value
		else
			t.ResidueNum_LELabel:setText( "Shift value: Please enter a valid residue number: " )
		end -- if Value found
		
	end -- function self
) -- end ResidueNum_LE Callback

-- Shift_LE lineEdit Callback
t.Shift_LE:setCallback( gui.event.Changed,
	function (self)
		-- function actions
		-- check if a number was entered:
		StartChar,EndChar,NumberRetrieved = string.find( t.Shift_LE:getText(), "(%d+)" )
		StartChar,EndChar,HalfFloatRetrieved = string.find( t.Shift_LE:getText(), "(%d+)." )
		StartChar,EndChar,FloatRetrieved = string.find( t.Shift_LE:getText(), "(%d+.%d+)" )
		Value = nil
		if NumberRetrieved then Value = tonumber(NumberRetrieved) end
		if HalfFloatRetrieved then Value = tonumber(HalfFloatRetrieved) end
		if FloatRetrieved then Value = tonumber(FloatRetrieved) end
		if Value then
			ShowNoesInMolmolShift = Value
			test = ShowNoesInMolmolShift - 1.0
		else
			t.Shift_LELabel:setText( "Shift value: Please enter a number or floating point value: " )
		end -- if Value found
		
	end -- function self
) -- end Shift_LE Callback


-- Tolerance_LE lineEdit Callback
t.Tolerance_LE:setCallback( gui.event.Changed,
	function (self)
		-- function actions
		-- check if a number was entered:
		StartChar,EndChar,NumberRetrieved = string.find( t.Tolerance_LE:getText(), "(%d+)" )
		StartChar,EndChar,HalfFloatRetrieved = string.find( t.Tolerance_LE:getText(), "(%d+)." )
		StartChar,EndChar,FloatRetrieved = string.find( t.Tolerance_LE:getText(), "(%d+.%d+)" )
		Value = nil
		if NumberRetrieved and tonumber(NumberRetrieved) &gt; 0 then Value = tonumber(NumberRetrieved) end
		if HalfFloatRetrieved and tonumber(HalfFloatRetrieved) &gt; 0 then Value = tonumber(HalfFloatRetrieved) end
		if FloatRetrieved and tonumber(FloatRetrieved) &gt; 0 then Value = tonumber(FloatRetrieved) end
		if Value then
			ShowNoesInMolmolTolerance = Value
			print(Value)
		else
			t.Tolerance_LELabel:setText( "Tolerance value: Please enter a positive number or floating point value: " )
		end -- if Value found
		
	end -- function self
) -- end Shift_LE Callback

-- cancel button Callback
t.cancelbutton:setCallback( gui.event.Clicked,
	function (self)
		v:close()
		print("ShowNoesInMolmol.lua was canceled")
	end

) -- end cancel button Callback

-- OK button Callback
t.okbutton:setCallback( gui.event.Clicked,
	function (self)
-- =============== Determine User Preferences ===========================

		t.P = cara:getProject( t.ProjectListCB:getCurrentText() )
		ShowNoesInMolmolProjectName = t.P:getName()
		ShowNoesInMolmolOutputMethod = t.OutputMethodCB:getCurrentText()
		ShowNoesInMolmolFilename = t.FilenameLE:getText()
		--ShowNoesInMolmolAtomName = t.AtomNameCB:getCurrentText()
		ShowNoesInMolmolResidueNum = t.ResidueNum_LE:getText()
		ShowNoesInMolmolAtomName = t.AtomName_LE:getText()
		ShowNoesInMolmolShift = t.Shift_LE:getText()
		ShowNoesInMolmolTolerance = t.Tolerance_LE:getText()
		Formatted_Shift = string.format( "%3.2f", ShowNoesInMolmolShift )
		
		TargetRes = t.P:getResidue( ShowNoesInMolmolResidueNum )
		if not TargetRes then error("A valid residue number was not entered") end
		TargetAtom = TargetRes:getType():getAtom( ShowNoesInMolmolAtomName )
		if not TargetAtom then error("A valid atom name was not entered") end
		Shift = Formatted_Shift
		if not Shift then error("A valid chemical shift was not entered") end
		if not ShowNoesInMolmolTolerance then error("A valid tolerance value was not entered") end
		
		if t.LongRange_ChBx:isChecked() then
			LongRange = "YES"
		else
			LongRange = "NO"
		end
-- ============== Run analysis ===========================================
								
					-- generate header for macro
		t.Lines="# DisplayNoes.mac: generated by CARA script ShowNoesInMolmol.lua" -- string containing lines for macro
		t.Lines=t.Lines.."\n".."# Project: "..t.P:getName()
		t.Lines=t.Lines.."\n".."# StartingAtom: TargetRes="..TargetRes:getId().." TargetAtom="..TargetAtom:getName()
		t.Lines=t.Lines.."\n".."# Target Shift for NOE: "..Shift.." ppm"
		t.Lines=t.Lines.."\n".."#"
		t.Lines=t.Lines.."\n".."# Select TargetAtom"
		
		-- generate lines to select Target Atom
		WriteShowAtom( TargetRes, TargetAtom, TargetAtomColor )
		
		NumMatchingSpins,SpinsWithMatchingShift = GetSpinsWithMatchingShift( TargetSpin, Shift, ShowNoesInMolmolTolerance )
		print("found "..NumMatchingSpins.." assigned spins within "..ShowNoesInMolmolTolerance.." of "..Shift.." ppm")
		if NumMatchingSpins&lt;1 then
			t.Lines=t.Lines.."\n".."# found no assigned spins within "..ShowNoesInMolmolTolerance.." of "..Shift.." ppm"
			print("WARNING: found no assigned spins within "..ShowNoesInMolmolTolerance.." of "..Shift.." ppm" )
		else -- write out lines to select all assigned spins with matching shift
			t.Lines=t.Lines.."\n".."# Select "..NumMatchingSpins.." within "..ShowNoesInMolmolTolerance.." of "..Shift.." ppm"
			print("TableSize="..TableSize(SpinsWithMatchingShift) )
			for Index,Spin in pairs( SpinsWithMatchingShift ) do
				print("SpinId: "..Spin:getId() )
				Res,Atom = AssignmentOfSpin( Spin )
				if Res and Atom then
					--Write out text to mml file for this Atom
					if LongRange == "YES" then
						if math.abs( TargetRes:getId() - Res:getId() ) &gt; 3 then
							WriteShowShift( Spin )
							WriteShowAtom( Res, Atom, CandidateAtomColor )
						end
					else
						WriteShowShift( Spin )
						WriteShowAtom( Res, Atom, CandidateAtomColor )
					end
				end
			end
		end
		
		if ShowNoesInMolmolOutputMethod == "terminal window" then
			print(" ~~~~~~~~~~~~~~~ output to terminal only ~~~~~~~~~~~~~~~~")
			print( t.Lines )
			print(" ~~~~~~~~~~~~~~~ output to terminal only ~~~~~~~~~~~~~~~~")

		else
			print(" ~~~~~~~~~~~~~~~ output to terminal and file ~~~~~~~~~~~~~~~~")
			print( t.Lines )
			-- open macro file to write
			outfile = io.output( ShowNoesInMolmolFilename )
			outfile:write( t.Lines )
			-- close macro file to write
			outfile:close()
			print(" ~~~~~~~~~~~~~~~ output to terminal and file ~~~~~~~~~~~~~~~~")
			print("Wrote output to file: "..ShowNoesInMolmolFilename )
			print("ShowNoesInMolmol.lua is finished")			
		end

		v:close()
	end
) -- end OK button Callback


print("Finished with ShowNoesInMolmol.lua")
-- =================================



</code>
<fld name='Creation Date' type='Date'>2007-3-31</fld>
</script>
<script name='CalcMassOfLabeledProtein'>
<code lang='Lua'>-----------------------------------------------------------------------------------------
-- script to calculate the mass of an isotope-labeled protein
-- The mass is calculated from the sequence of the selected project.

-- You can enter the percent isotope labeling for 2H,13C,15N
-- The exchangeable protons are assumed to be completely exchanged.
-- Normally you work in H2O (natural abundance of D2O) when measuring MS spectra

-- Note that the template Start1.5.cara assumes that residues like
-- ASP, GLU, LYS, ARG, HIS are ionized and that CYS is reduced

-- F. Damberger Version 1 3.Feb.2006

-- First mass is just for residues
-- second mass includes the termini
-- Atom Counts include the termini

-- F. Damberger Version 2 24.Apr.2006
-- added checkboxes to:
-- select all CYS as oxidized (otherwise they are assumed all reduced)
-- N-term can be usual NH3 or CH3CONH (N-acetylated)
-- C-term can be usual COOH or CONH2 (C-amidated)
-- ionizable residues are assumed to be neutral 
--    ignore mass of the following atoms in mass calculation:  ARG HH12, LYS HZ3, HIS HE2

-- F. Damberger Version 3 7.Nov.2007
-- Changed the formula for determining the average mass of an Atom
-- All Masses are now calculated using the abundances and atomic masses given in the web  elements site
-- When an isotope is "Labeled" the ratio of the non-labeled isotopes is assumed to be unchanged (see the new function GetWeightedMass for details)
--    The template should include the following atoms in the library:       ASP HD2, GLU HE2 (these are checked for)
--    added a checkbox to calculate the expected Mass for ESI-MassSpec (assumes all ARG,LYS,HIS and termini are neutral)
--    added pH, if MassSpec is NOT checked, the mass is determined using the expected ionization states at the given pH
--              assuming that all sidechains and the termini have the statistical average pKa values (see table pKa = {})
-- To obtain a detailed output, set Verbose to true below
-- To obtain additional isotopes like O17, P32, S33, set Extended to true below


Version = 3
Date = "Nov. 8 2007 FD"
-----------------------------------------------------------------------------------------

-- ======= USER CAN COMMENT IN THE OPTIONS BELOW TO =====================================

-- change to Verbose = true to get an more verbose output
--including the calculated masses of each residue
--and the average masses of the AtomTypes:
 Verbose = false

-- Change to Extended = true to get an extended list of nuclei to label:
 Extended = false
 
-- ======================================================================================
-- DO NOT EDIT BELOW THIS LINE
-----------------------------------------------------------------------------------------
Repeated = false

function NonExchanging( Atom )
	Result = true
	if Atom:getAtomType() == "H" then
		for Id,NeighbourAtom in pairs( Atom:getNeighbours() ) do
			if NeighbourAtom:getAtomType() == "N" or NeighbourAtom:getAtomType() == "O" then
				Result = false
			end -- if Neighbor is N or O
		end -- for all neighbour atoms (only 1 for an H)
	end -- if Atom is a H
	return Result
end -- function NonExchanging

function MassOfTermAtom( AtomType, Lability )
-- This function is needed for terminal atoms because they are not included in the ResidueType model
-- Therefore the neighbour atom cannot be determined using the function NonExchanging
	if LabeledIsotopes[ AtomType ] then
		if Lability == "Ex" then
			Percent = CalcMassOfLabeledProtein_PercentD2O 
			--NumExchangeable = NumExchangeable + 1
		end -- use D2O percent for exchangeable atoms
		--Result =  0.01 * ( (100 - Percent ) * AtomMass[ CommonIsotopes[ AtomType ] ]+ Percent * AtomMass[ LabeledIsotopes[ AtomType ] ] )
		Result = GetWeightedMass( AtomType, Percent )
	else
		Result = AvgAtomMass[ AtomType ] -- use average (natural abundance) mass							
	end -- LabeledIsotope[AtomType] defined
	return Result
end -- function MassOfAtom

function MassOfAtom( AtomType, Atom )
	if LabeledIsotopes[ AtomType ] then
		if NonExchanging( Atom ) == false then
			Percent = CalcMassOfLabeledProtein_PercentD2O 
			--NumExchangeable = NumExchangeable + 1 -- This is done in the main script
		end -- use D2O percent for exchangeable atoms
		--Result =  0.01 * ( (100 - Percent ) * AtomMass[ CommonIsotopes[ AtomType ] ]+ Percent * AtomMass[ LabeledIsotopes[ AtomType ] ] )
		Result = GetWeightedMass( AtomType, Percent )
	else
		Result =  AvgAtomMass[ AtomType ] -- use average (natural abundance) mass	
	end -- LabeledIsotope[AtomType] defined
	return Result
end

function GetWeightedMass( AtomType, Percent )
	local WeightedMass = 0
	for Idx,Isotop in pairs( Isotopes[ AtomType ] ) do
		if LabeledIsotopes[ AtomType ] == Isotop then
			Weight = Percent
		else
			-- This formula assumes that the other (non-enriched) isotopes maintain the same ratio of relative amounts as in natural abundance
			-- e.g. if I enriched O17 to 98% then the remaining 2% of O would have relative fractions of
			--      O16: 99.757/(99.757+0.205) and O18: 0.205/(99.757+0.205)
			Weight = Abundance[ Isotop ] * ( 1 -  ( Percent - Abundance[ LabeledIsotopes[ AtomType ] ] ) / ( 100 - Abundance[ LabeledIsotopes[ AtomType ] ] ) )
		end
		WeightedMass = WeightedMass +  AtomMass[ Isotop ] * Weight/100
	end
	return WeightedMass
end

function SetValue( ResTypeName, AtomName, Value )
	Result = true
	ResType = cara:getResidueType( ResTypeName )
	if ResType then
		Atom = ResType:getAtom(AtomName)
		if Atom then
			Atom:setMagnitude( Value )
		else
			MissingAtom = true
			print("Did not find the atom "..AtomName.." in ResidueType "..ResTypeName )
		end -- if Atom exists
	else
		MissingResidueType = true
		print(" Did not find the ResidueType "..ResTypeName )
	end -- if ResType exists
	return Result
end -- function SetValue

function GetAvgAtomicMass( AtomType )
	MassAtom2 = 0
	for IsoId,Iso2 in pairs( Isotopes[ AtomType ] ) do
		MassAtom2 = MassAtom2 + Abundance[ Iso2 ] * AtomMass[ Iso2 ] / 100
	end
	return MassAtom2
end


-- Set magnitudes of Methyl and ammonium groups to 3 (some older Start1.2.cara templates have magnitudes of 1)
-- and check for missing atoms in the template (ASP HD1 &amp; GLU HE1)
MissingAtom = false
MissingResidueType = false
SetValue( "ALA", "HB", 3 )
SetValue( "THR", "HG2", 3 )
SetValue( "LYS", "HZ", 3 )
SetValue( "MET", "HE", 3 )
SetValue( "VAL", "HG1", 3 )
SetValue( "VAL", "HG2", 3 )
SetValue( "LEU", "HD1", 3 )
SetValue( "LEU", "HD2", 3 )
SetValue( "ILE", "HD1", 3 )
SetValue( "ILE", "HG2", 3 )
SetValue( "ASP", "HD1", 1 ) -- Version 3: added this to check for existence of ASP HD1
SetValue( "GLU", "HE1", 1 ) -- Version 3: added this to check for existence of GLU HE1


if MissingAtom or MissingResidueType then
	print("WARNING: this does not appear to be a Start1.2.cara template. This script looks for specific atoms and residuetypes and some of these are missing!")
	print("  If you do not have ASP HD1, then create this Atom in the ResidueType ASP and bond it to OD1")
	print("  If you do not have GLU HE1, then create this Atom in the ResidueType GLU and bond it to OE1")
end

-- create temporary array for lua script
t={}

print( "----------------------------------------------------------------------------------------" )
print("Starting CalcMassOfLabeledProtein version "..Version.." of "..Date )


-- New interface

--1. Create main menu window

v = gui.createMainWindow()
v:setCaption( "Selection Dialog for CalcMassOfLabeledProtein" )
t.frm = gui.createGrid( v, 2, false )
v:setCentralWidget( t.frm )
v:show()
t.frm:show()

-- Define ProjectList Combobox and its Label
t.ProjectListLabel = gui.createLabel( t.frm, "Select Project" )
t.ProjectListCB = gui.createComboBox( t.frm )


--2. Read ProjectNames into ProjectList combobox

SelectedItemIndex = nil
for Id,Project in pairs( cara:getProjects() ) do
	ItemIndex = t.ProjectListCB:addItem( Project:getName() )
	t.ProjectListCB:setCurrentItem( ItemIndex )
	if CalcMassOfLabeledProtein_ProjectName == t.ProjectListCB:getCurrentText() then
		SelectedItemIndex = ItemIndex
	end
end -- for all projects

if SelectedItemIndex then -- set to previous choice if it exists
	t.ProjectListCB:setCurrentItem( SelectedItemIndex )
end

-- Display ProjectList Combobox
t.ProjectListLabel:show()
t.ProjectListCB:show()

--3. Create CheckBox which determines whether CYS are oxidized
t.CysteinesOxidizedLabel = gui.createLabel( t.frm, "All CYS are oxidized" )
t.CysteinesOxidizedChBx = gui.createCheckBox( t.frm )

if CysteinesState == "oxidized" then t.CysteinesOxidizedChBx:setChecked() end

t.CysteinesOxidizedLabel:show()
t.CysteinesOxidizedChBx:show()

--4. Create CheckBox which determines whether N-terminus is acetylated
t.NacetylatedLabel = gui.createLabel( t.frm, "N-terminus is acetylated" )
t.NacetylatedChBx = gui.createCheckBox( t.frm )

if NacetylatedState == true then t.NacetylatedChBx:setChecked() end

t.NacetylatedLabel:show()
t.NacetylatedChBx:show()

--5. Create CheckBox which determines whether N-terminus is acetylated
t.CamidatedLabel = gui.createLabel( t.frm, "C-terminus is amidated" )
t.CamidatedChBx = gui.createCheckBox( t.frm )

if CamidatedState == true then t.CamidatedChBx:setChecked() end

t.CamidatedLabel:show()
t.CamidatedChBx:show()

--6. Create CheckBox which determines whether to calculate mass M expected for ESI-MS or mass in solution at the given pH
t.MassSpecLabel = gui.createLabel( t.frm, "Calculate expected Mass for ESI-MassSpec" )
t.MassSpecChBx = gui.createCheckBox( t.frm )

if MassSpec == "ESI" then t.MassSpecChBx:setChecked() end

t.MassSpecLabel:show()
t.MassSpecChBx:show()



--4. Create Table of LineEdit Labels for isotope percentages
t.PercentLELabel = {}
t.PercentLE = {}

-- Create data tables

pKa = {} -- these are used to determine whether to add 1H to MW when residue is protonated
pKa[ "Cterm" ] = 3.9
pKa[ "Nterm" ] = 7.4
pKa[ "HIS" ] = 6.5
pKa[ "ASP" ] = 3.95
pKa[ "GLU" ] = 4.4
pKa[ "CYS" ] = 9.25
pKa[ "LYS" ] = 10.75 -- not used in script
pKa[ "ARG" ] = 12.0  -- not used in script
pKa[ "TYR" ] = 10.15 -- not used in script


-- Create table for Labeled isotopes (the ones to isotope enrich)
-- You can add other isotopes if desired
-- the script will allow you to set isotope enrichment for these
LabeledIsotopes = {}
LabeledIsotopes[ "H" ] = "H2"
LabeledIsotopes[ "C" ] = "C13"
LabeledIsotopes[ "N" ] = "N15"
if Extended then
	LabeledIsotopes[ "S" ] = "S33" -- spin 3/2
	LabeledIsotopes[ "O" ] = "O17" -- spin 5/2
	LabeledIsotopes[ "P" ] = "P32" -- spin 1, 14d halflife
end

--Create Tables of Isotopes
Isotopes = {}
Isotopes[ "H" ] = { "H1", "H2" }
Isotopes[ "C" ] = { "C12", "C13" }
Isotopes[ "N" ] = { "N14", "N15" }
Isotopes[ "O" ] = { "O16", "O17", "O18" }
Isotopes[ "P" ] = { "P31", "P32" }
Isotopes[ "S" ] = { "S32", "S33", "S34", "S36" }


--[[
-- These are values calculated from the masses and abundances given in the next tables defined below
AvgAtomMass = {}
AvgAtomMass[ "H" ] = 1.007941    --1.008
AvgAtomMass[ "C" ] = 12.010736   --12.011 
AvgAtomMass[ "N" ] = 14.006743   --14.007
AvgAtomMass[ "O" ] = 15.999405   --15.999
AvgAtomMass[ "P" ] = 30.973762   --30.974
AvgAtomMass[ "S" ] = 32.066085   --32.065
]]

AtomMass = {}
Abundance = {}
-- Masses of most abundant nuclei (CommonIsotopes)
AtomMass[ "H1" ] = 1.007825032;  Abundance[ "H1" ] =  99.9885 -- Spin 1/2      1.0078
AtomMass[ "H2" ] = 2.014101778;  Abundance[ "H2" ] = 0.0115   --  Spin 1        2.014

AtomMass[ "C12" ] = 12.000000;   Abundance[ "C12" ] = 98.93   -- Spin 0     
AtomMass[ "C13" ] = 13.003354;   Abundance[ "C13" ] = 1.07     --  Spin 1/2       13.003

AtomMass[ "N14" ] = 14.003074;   Abundance[ "N14" ] = 99.632  -- Spin 1       14.003
AtomMass[ "N15" ] = 15.000108;   Abundance[ "N15" ] = 0.368    --  Spin 1/2      15.000

AtomMass[ "O16" ] = 15.99491463; Abundance[ "O16" ] = 99.757  -- Spin         15.995
AtomMass[ "O17" ] = 16.9991312;  Abundance[ "O17" ] = 0.038   --  Spin 5/2      16.999
AtomMass[ "O18" ] = 17.9991603;  Abundance[ "O18" ] = 0.205 --  Spin 0

AtomMass[ "P31" ] = 30.9737620;  Abundance[ "P31" ] = 100.0    -- Spin 1/2     30.974
AtomMass[ "P32" ] = 31.973615;   Abundance[ "P32" ] = 0        --  Spin 1     abundance 0       31.974

AtomMass[ "S32" ] = 31.97207070; Abundance[ "S32" ] = 94.93   -- Spin 0       32.059 = weighted average mass of isotopes 32,34 &amp; 36
AtomMass[ "S33" ] = 32.97145843; Abundance[ "S33" ] = 0.76   --  Spin 3/2       32.971
AtomMass[ "S34" ] = 33.96786665; Abundance[ "S34" ] = 4.29 --  Spin 0
AtomMass[ "S36" ] = 35.96708062; Abundance[ "S36" ] = 0.02 --  Spin 0

-- Average masses of each AtomType
AvgAtomMass = {}
for AtId,At2 in pairs( Isotopes ) do
	AvgAtomMass[ AtId ] = GetAvgAtomicMass( AtId )
end


--5. Get percentages for isotope-labeling


-- Create array for percentages if it is missing
if not CalcMassOfLabeledProtein_Percent then
	CalcMassOfLabeledProtein_Percent = {}
	--print("OK button callback: Creating CalcMassOfLabeledProtein_Percent table")
else
	--print("CalcMassOfLabeledProtein_Percent exists in OK button call back! It has size: "..table.getn(CalcMassOfLabeledProtein_Percent) )
	
end

for IdIso,Iso in pairs( LabeledIsotopes ) do

	t.PercentLELabel[ Iso ] = gui.createLabel( t.frm, "Enter Percent "..Iso.." labeling" )
	t.PercentLE[ Iso ] = gui.createLineEdit( t.frm )

	if CalcMassOfLabeledProtein_Percent[ Iso ] then
		t.PercentLE[ Iso ]:setText( CalcMassOfLabeledProtein_Percent[ Iso ] )
	else
		t.PercentLE[ Iso ]:setText( Abundance[ Iso ] )
	end
	-- Display Label and LineEdit window
	t.PercentLELabel[ Iso ]:show()
	t.PercentLE[ Iso ]:show()
end -- for all isotopes

--6. Get percentage D2O
	t.PercentD2OLELabel = gui.createLabel( t.frm, "Enter Percentage D2O - complete exchange is assumed" )
	t.PercentD2OLE = gui.createLineEdit( t.frm )

	if CalcMassOfLabeledProtein_PercentD2O then
		t.PercentD2OLE:setText( CalcMassOfLabeledProtein_PercentD2O )
	else
		t.PercentD2OLE:setText( Abundance[ "H2" ] )
	end
	-- Display Label and LineEdit window
	t.PercentD2OLELabel:show()
	t.PercentD2OLE:show()
	
--7. Get pH
	t.pHLELabel = gui.createLabel( t.frm, "Enter sample pH" )
	t.pHLE = gui.createLineEdit( t.frm )

	if CalcMassOfLabeledProtein_pH then
		t.pHLE:setText( CalcMassOfLabeledProtein_pH )
	else
		t.pHLE:setText( 3.5 )
	end
	-- Display Label and LineEdit window
	t.pHLELabel:show()
	t.pHLE:show()
	


	
--7. Reset natural abundance values
t.resetbutton = gui.createPushButton( t.frm, "Reset Natural Abundance values" )
t.resetbutton:show()


-- ================== END OF SELECTION DIALOG =============================


-- ================= create control buttons =============================

t.okbutton = gui.createPushButton(t.frm, "OK" )
t.cancelbutton = gui.createPushButton( t.frm, "Cancel" )

t.okbutton:show()
t.cancelbutton:show()

-- ================= CALLBACKS for menu window ==========================

-- reset button callback -------------------------------------------------------------------------------------------------
t.resetbutton:setCallback( gui.event.Clicked,
	function (self)

		for IdIso,Iso in pairs( LabeledIsotopes ) do
			t.PercentLE[ Iso ]:setText( Abundance[ Iso ] )
		end
		--t.PercentLELabel[ Iso ]:show()
		--t.PercentLE[ Iso ]:show()
		
		t.PercentD2OLE:setText( Abundance[ "H2" ] )

	end
) -- end resetbutton callback --------------------------------------------------------------------------------------------

-- cancel button callback ------------------------------------------------------------------------------------------------

t.cancelbutton:setCallback( gui.event.Clicked,
	function (self)
		v:close()
	end
) -- end cancelbutton callback

-- OK button Callback ----------------------------------------------------------------------------------------------------
t.okbutton:setCallback( gui.event.Clicked,
	function (self)

-- ================== Set the user preference variables ==================

-- get the project
for ProjId,Proj in pairs( cara:getProjects() ) do
	if Proj:getName() == t.ProjectListCB:getCurrentText() then
		t.P = Proj
	end
end
if t.P == nil then error("No valid project selected Aborting without any action.")
else
	CalcMassOfLabeledProtein_ProjectName = t.P:getName()
end

-- get the sequence

t.Seq = t.P:getSequence()
if t.Seq == nil then error("No sequence found in the selected project. Aborting without any action.") end

-- get the state of the CysteinOxidized CheckBox
if t.CysteinesOxidizedChBx:isChecked() then
	CysteinesState = "oxidized"
else
	CysteinesState = "reduced"
end

-- get the state of the N-acetylation CheckBox
if t.NacetylatedChBx:isChecked() then
	NacetylatedState = true
else
	NacetylatedState = false
end

-- get the state of the C-amidation CheckBox
if t.CamidatedChBx:isChecked() then
	CamidatedState = true
else
	CamidatedState = false
end

-- get the state of the MassSpec CheckBox
if t.MassSpecChBx:isChecked() then
	MassSpec = "ESI"
else
	MassSpec = nil
end



-- Create array for percentages if it is missing
if not CalcMassOfLabeledProtein_Percent then
	CalcMassOfLabeledProtein_Percent = {}
	--print("OK button callback: Creating CalcMassOfLabeledProtein_Percent table")
else
	--print("CalcMassOfLabeledProtein_Percent exists in OK button call back! It has size: "..table.getn(CalcMassOfLabeledProtein_Percent) )
	
end
-- get the Isotope percentages
for IsoId,Iso in pairs( LabeledIsotopes ) do
	CalcMassOfLabeledProtein_Percent[ Iso ] = t.PercentLE[ Iso ]:getText()
	--print( "OK call back: CalcMassOfLabeledProtein_Percent["..Iso.."]= "..CalcMassOfLabeledProtein_Percent[Iso] )
end
-- get the D2O percentage
CalcMassOfLabeledProtein_PercentD2O = t.PercentD2OLE:getText()

-- get the pH
CalcMassOfLabeledProtein_pH = t.pHLE:getText()
pH = tonumber( CalcMassOfLabeledProtein_pH )

-- ================== Define AtomTypes and AtomMass arrays  ==========================
AtomTypes = { "H", "C", "N", "O", "P", "S" }
NumAtoms = {}



-- ================== Count number of Atoms of each type and calculate the mass =======

-- set number of each atomtype to zero
Mass = 0 -- total mass of sequence in Daltons
NumRes = 0
NumCysRed = 0
NumCysDeprotonated = 0
NumExchangeable = 0
Space = "                            - "
for AtomTypeId,AtomType in pairs( AtomTypes ) do
	NumAtoms[ AtomType ] = 0
end
for ResId,Res in pairs( t.Seq ) do
	message = Space
	MassOfThisResidue = 0
	ResType = Res:getType()
	NumRes = NumRes + 1
	Atoms = ResType:getAtoms()
	for AtomId,Atom in pairs( Atoms ) do
		for AtomTypeId,AtomType in pairs( AtomTypes ) do
			AtomMag = Atom:getMagnitude()
			if Atom:getAtomType() == AtomType then
			
					if ResType:getShort() == "CYS" and Atom:getName() == "HG" then
							if CysteinesState == "oxidized" or pH &gt; pKa[ "CYS" ] then -- remove one H, CYS is deprotonated
								if Verbose then message = message.."\n"..Space.."ignoring a CYS HG, either Cysteines are all oxidized or pH &gt; pKa" end
								AtomMag = 0
								NumCysDeprotonated = NumCysDeprotonated + 1
							end
						--end -- if MassSpec == "ESI"
					end -- if CYS HG
					
					if ResType:getShort() == "LYS" and Atom:getName() == "HZ" then
						if MassSpec == "ESI" then
							AtomMag = 2
							if Verbose then message = message.."\n"..Space.."ignoring one H of HZ group, LYS assumed uncharged for ESI-MS" end
						end
					end
					
					if ResType:getShort() == "ARG" and Atom:getName() == "HH12" then
						if MassSpec == "ESI" then
							AtomMag = 0
							if Verbose then message = message.."\n"..Space.."ignoring ARG HH12, ARG assumed uncharged for ESI-MS" end
						end
					end -- ignore mass, ARG assumed uncharged for ESI-MS

					if ResType:getShort() == "ASP" and Atom:getName() == "HD1" then
						if MassSpec == "ESI" then
							AtomMag = 1 -- keep mass, ASP assumed uncharged for ESI-MS
						else
							if pH &gt; pKa[ "ASP" ] then
								AtomMag = 0
								if Verbose then message = message.."\n"..Space.."pH &gt; pKa, ignore mass of ASP HD1, ASP assumed charged at this pH" end
							end
						end
					end
										
					if ResType:getShort() == "GLU" and Atom:getName() == "HE1" then
						if MassSpec == "ESI" then
							AtomMag = 1 -- keep mass, GLU assumed uncharged for ESI-MS
						else
							if pH &gt; pKa[ "GLU" ] then
								AtomMag = 0
								if Verbose then message = message.."\n"..Space.."pH &gt; pKa, ignore mass of GLU HE1, GLU assumed charged at this pH" end
							end -- ignore mass, GLU assumed charged						
						end
					end

					if ResType:getShort() == "HIS" and Atom:getName() == "HE2" then
						if MassSpec == "ESI" then
							AtomMag = 0
							if Verbose then message = message.."\n"..Space.."ignoring mass of HE2, HIS assumed uncharged for ESI-MS" end
						else
							if pH &gt; pKa[ "HIS" ] then
								AtomMag = 0 -- ignore mass, HIS assumed uncharged for ESI-MS
								if Verbose then message = message.."\n"..Space.."pH &gt; pKa, ignore mass of HIS HE2, HIS assumed neutral at this pH" end
							end
						end
					end
					
					NumAtoms[ AtomType ] = NumAtoms[ AtomType ] + AtomMag
					Percent = CalcMassOfLabeledProtein_Percent[ LabeledIsotopes[ AtomType ] ]
					if LabeledIsotopes[ AtomType ] then
						if NonExchanging( Atom ) == false then
							Percent = CalcMassOfLabeledProtein_PercentD2O 
							NumExchangeable = NumExchangeable + 1
						end -- use D2O percent for exchangeable atoms
						MassOfThisResidue = MassOfThisResidue + MassOfAtom( AtomType, Atom ) * AtomMag
					else
						MassOfThisResidue = MassOfThisResidue + AvgAtomMass[ AtomType ] * AtomMag -- use average (natural abundance) mass							
					end -- LabeledIsotope[AtomType] defined
			end -- if AtomType matches
		end -- for all AtomTypes
	end -- for all Atoms in Residue
	MassOfThisResidue = string.format( "%6.3f", MassOfThisResidue )
	if Verbose then
		print( "Residue : "..Res:getType():getShort()..ResId.."  Mass: "..MassOfThisResidue )
		if message ~= Space then print(message) end
	end
	Mass = Mass + MassOfThisResidue
end

-- consider termini
if NacetylatedState == true then -- CH3CO
	NtermName = "CH3CO"
	MassSum = 0
	--MassSum = MassSum + 0.01 * ( (100 - Percent ) * AtomMass[ CommonIsotopes[ "C" ] ] + Percent * AtomMass[ LabeledIsotopes[ "C" ] ] ) * NumAtoms
	MassSum = MassSum + MassOfTermAtom( "C" , "nonEx" ) * 2
	NumAtoms[ "C" ] = NumAtoms[ "C" ] + 2
	MassSum = MassSum + MassOfTermAtom( "O" , "nonEx" ) * 1
	NumAtoms[ "O" ] = NumAtoms[ "O" ] + 1
	MassSum = MassSum + MassOfTermAtom( "H" , "nonEx" ) * 3
	NumAtoms[ "H" ] = NumAtoms[ "H" ] + 3
	MassOfNterm = MassSum
else -- H2
	NtermName = "H2"
	MassSum = 0
	MassSum = MassSum + MassOfTermAtom( "H" , "Ex" ) * 2
	NumExchangeable = NumExchangeable + 2
	NumAtoms[ "H" ] = NumAtoms[ "H" ] + 2
	if not MassSpec == "ESI" then
		if pH &lt; pKa[ "Nterm" ] then -- Alpha Amino is NH3
			MassSum = MassSum + MassOfTermAtom( "H" , "Ex" ) * 1
			NumAtoms[ "H" ] = NumAtoms[ "H" ] + 1
			NumExchangeable = NumExchangeable + 1
		end
	end
	MassOfNterm = MassSum
end

if CamidatedState == true then -- NH2
	CtermName = "NH2"
	MassSum = 0
	MassSum = MassSum + MassOfTermAtom( "N" , "nonEx" ) * 1
	NumAtoms[ "N" ] = NumAtoms[ "N" ] + 1
	MassSum = MassSum + MassOfTermAtom( "H" , "Ex" ) * 2
	NumAtoms[ "H" ] = NumAtoms[ "H" ] + 2
	NumExchangeable = NumExchangeable + 2
	MassOfCterm = MassSum
else -- OH
	CtermName = "O-"
	MassSum = 0
	MassSum = MassSum + MassOfTermAtom( "O" , "nonEx" ) * 1
	NumAtoms[ "O" ] = NumAtoms[ "O" ] + 1
	if not MassSpec == "ESI" then
		if pH &lt; pKa[ "Cterm" ] then
			MassSum = MassSum + MassOfTermAtom( "H" , "Ex" )
			NumAtoms[ "H" ] = NumAtoms[ "H" ] + 1
			NumExchangeable = NumExchangeable + 1
		end
	end
	MassOfCterm = MassSum
end

if MassSpec == "ESI" then
	TextAboutIonizationStates = "in a neutral ionization state (MassSpec is checked)."
else
	TextAboutIonizationStates = "in an ionization state determined by the given pH and standard pKa's."
end


-- add mass of termini
Mass = Mass + MassOfNterm + MassOfCterm

-- Calculate mass adjusted for the termini
MassOfTermini = MassOfNterm + MassOfCterm
MassOfTermini = string.format( "%8.3f", MassOfTermini )
--MassAdjusted = Mass + MassH2O
Mass = string.format( "%8.3f", Mass )

-- Output the result of mass calculation to terminal
print("\n")
for AtomTypeId,AtomType in pairs( AtomTypes ) do
	print("Found "..NumAtoms[ AtomType ].." atoms of type "..AtomType)
end
print("\n")
print( "Found "..NumExchangeable.." exchangeable H atoms. Assumed that "..CalcMassOfLabeledProtein_PercentD2O.."% are Deuterated." )
print( "Found "..NumCysDeprotonated.." deprotonated cysteines using the selected pH "..string.format("%3.2f", pH ).." and oxidation state "..CysteinesState )
print("\n")
print( "The sequence of "..NumRes.." residues has a calculated Mass of: " )
print( Mass.." Da")
print( " assuming:")
print( " - all cysteines are "..CysteinesState.." [NOTE: typically for ESI-MS, cysteines are reduced]" )
print( " - termini and sidechains are "..TextAboutIonizationStates )
print( " - including a mass of +"..MassOfTermini.." Da from the "..NtermName.." for Nterm and "..CtermName.." for Cterm" )

--print( " Expected Mass of bmr6313: 14472.50 assuming all CYS are reduced." )

if Verbose then
	print("--------------------------")
	print("The following mean masses for atoms were assumed")
	for AtId,At2 in pairs( Isotopes ) do
		MassAtom2 = 0
		for IsoId,Iso2 in pairs( Isotopes[ AtId ] ) do
			MassAtom2 = MassAtom2 + Abundance[ Iso2] * AtomMass[ Iso2 ] / 100
		end
		print( "Avg mass of "..AtId.." "..string.format( "%8.6f", MassAtom2 ) )
	end
end

print( "\nCalcMassOfLabeledProtein Version "..Version.." "..Date.." is done")
print( "----------------------------------------------------------------------------------------" )
--free up script variables
-- t = nil
	v:close()
	end
) -- end okbutton callback -------------------------------------------------------------------------------------------------


</code>
<fld name='Author' type='String'>Fred Damberger</fld>
<fld name='Creation Date' type='Date'>2008-3-5</fld>
<fld name='Description' type='Memo'>Calculates the mass of isotope-labeled proteins. User enters the percentage isotope-labeling. Either ESI-MS mass or mass in solution can be calculated.

In the ResidueType definitions,  ASP should include the atom HD1 and GLU should have HE1.</fld>
</script>
<script name='UplsToSystemFromPeaklist'>
<code lang='Lua'>-- script to select a tower of peaks within a range of f1 and f3
-- All peaks are written to a new peaklist which have
--    f1 coordinate: f1start &lt; f1peak &lt; f1finish
--      AND										 (NOEs to other protons in the NOE tower of f1,f3 signal)
--    f3 coordinate: f3start &lt; f3peak &lt; f3finish
-- OR
--    f2 coordinate: f2start &lt; f2peak &lt; f2finish  (NOE to the f2 proton freq of signal)

-- F.Damberger February 27 2007.


-- Function definitions


function PeakIsInRange( b )
	f1pos,f2pos,f3pos = b:getPos()
	
	if t.f1start &lt; f1pos and f1pos &lt; t.f1finish then
		if t.f3start &lt; f3pos and f3pos &lt; t.f3finish then
			print("Found tower peak")
			return true -- f1 and f3 dimension match
		end
	end
	
	if t.f2start &lt; f2pos and f2pos &lt; t.f2finish then
		print("Found NOE to f2freq")
		return true	-- f2 dimension matches
	end
	return false
end

function GetUplsFromPeak( Peak )
	-- function looks for possible assignments of a peak and stores them all in a table which is returned
	
	-- requires functions:
	--GetSpinAssignment( Spin ) RETURNS AssignedResidueNumber,AssignedResidueType,AssignedAtom,AssignedAtomType
	-- GetNeighbourSpin( AssignedAtom ) RETURNS: AtatchedProton
	f1pos,f2pos,f3pos = Peak:getPos()
	ProxyText = "PRX  XH      5.00 #SUP  0.64"
	
	Spins = t.P:getSpins()

	if t.f1start &lt; f1pos and f1pos &lt; t.f1finish then
		if t.f3start &lt; f3pos and f3pos &lt; t.f3finish then -- peak is in tower, try to assign NOE of tower to another spin
			print("Assigning peak "..Peak:getId().." in tower of TARGET system")
			i = 0
			for SpinId,Spin in pairs( Spins ) do
				AssignedResidueNumber,AssignedResidueType,AssignedAtom,AssignedAtomType = GetSpinAssignment( Spin )
				if AssignedAtomType == "H1" and AssignedResidueNumber and AssignedAtom then
					Shift = Spin:getShift()
					t.ShiftStart = Shift - t.Htol
					t.ShiftFinish = Shift + t.Htol
					if t.ShiftStart &lt; f2pos and f2pos &lt; t.ShiftFinish then -- f2pos is within t.Htol of Shift, add a UPL to list
						i=i+1
						UplList[i]=AssignedResidueNumber.."  "..AssignedResidueType.."    "..ProxyText
					-- example of a UPL line: 104 ASN  HN    192 PRX  XH      4.49 #SUP  0.64
					end -- if f2pos matches shift of spin
				end -- if spin is a H1 and assigned
			end -- for all spins
		end -- if peaks f3 position matches the f3 shift of system X
	end -- if peak is in tower of system X
	
	if t.f2start &lt; f2pos and f2pos &lt; t.f2finish then --another tower shows NOEs to f2freq of System, try to assign the tower position
		print("Assigning peak "..Peak:getId().." in tower of another system")
		for SpinId,Spin in pairs( Spins ) do
			AssignedResidueNumber,AssignedResidueType,AssignedAtom,AssignedAtomType = GetSpinAssignment( Spin )
			if AssignedAtomType == t.PeakList:getType(3) and AssignedResidueNumber and AssignedAtom then -- spin is a heteroatom and it's assigned
				AtatchedProton = GetNeighbourSpin( AssignedAtom )
				AssignedResidueNumber,AssignedResidueType,AssignedAtom,AssignedAtomType = GetSpinAssignment( AtatchedProton )
				if AtatchedProton then
					if AtatchedProton:getShift() - t.Htol &lt; f1pos and AtatchedProton:getShift() + t.Htol &gt; f1pos then -- proton matcheds
						i=i+1
						UplList[i]=AssignedResidueNumber.."  "..AssignedResidueType.."    "..ProxyText
					end
				end
			end

		end
	end
end


-- create array for script variables
t = {}
-- ----------------------------------------------------------------------
--1. Get ProjectName
local ProjectNames = {}
i = 0
for a,b in pairs(cara:getProjects()) do
	i = i + 1
	ProjectNames[ i ] = b:getName()
	print(ProjectNames[ i ])
end
t.ProjectName=dlg.getSymbol("Select Project","", unpack( ProjectNames ) )
t.P = cara:getProject( t.ProjectName )

-- ---------------------------------------------------------------------
--2. Get PeakList
local PeakListNames = {}
local PeakListIds = {}
i=0
for a,b in pairs(t.P:getPeakLists()) do
	i = i + 1
	PeakListIds[ i ] = b:getId()
	PeakListNames[ i ] = b:getName()
	-- print(b:getName())
	print(PeakListNames[ PeakListIds[ i ] ])
end

t.PeakListName=dlg.getSymbol("Select PeakList","", unpack( PeakListNames ) )
print( "before loop PeakListName ="..t.PeakListName)

i=0
for i=1,table.getn( PeakListNames ) do
	if t.PeakListName == PeakListNames[ i ] then	
		t.PeakListId = PeakListIds[ i ]
		t.PeakList = t.P:getPeakList( PeakListIds[ i ] )
	end
end



t.H1value = 2.066
--t.C13value = 15.882
--t.C13value = 38.86 -- folded position
t.C13value = 200.0 --ignore tower
t.Htol = 0.02
t.Ctol = 0.2
-- ---------------------------------
-- 4. Get Ppm start and finish f1
t.f1AtomType = "H"
t.f1start = t.H1value - t.Htol
t.f1finish = t.H1value + t.Htol

-- ---------------------------------
-- 4. Get Ppm start and finish f2

t.f2AtomType = "H"
t.f2start = t.H1value - t.Htol
t.f2finish = t.H1value + t.Htol


-- ---------------------------------
-- 5. Get Ppm start and finish f3
t.f3AtomType = "N"
t.f3start = t.C13value - t.Ctol
t.f3finish = t.C13value + t.Ctol

-- ---------------------------------
-- 3. Get Output Peaklist name

t.OutputPeakListName = "test.peaks"

-- open output peaklist

t.OutputPeakList = spec.createPeakList( t.f1AtomType, t.f2AtomType, t.f3AtomType )

-- ---------------------------------

--3. Copy Amplitudes to Volume in specified Peaklist

t.Peaks = t.PeakList:getPeaks()

i = 0
UplLists = {}
for a,b in pairs( t.Peaks ) do
--	print("peakamplitude = "..b:getAmp() )
--	print("peakvolume = "..b:getVol() )
	if b:getColor() == 2 and PeakIsInRange( b ) then
		Peak = t.OutputPeakList:createPeak( b:getPos() )
		print("Created peak: "..Peak:getPos() )
		t.OutputPeakList:setColor( Peak, b:getColor() )
		t.OutputPeakList:setVol( Peak, b:getVol() )
		
		UplLists[i] = GetUplsFromPeak( Peak )
		i = i + 1
	end
end
print("created "..i.." peaks in new peaklist written to external file "..t.OutputPeakListName )

-- ---------------------------------
-- X. Write out peaklist

t.OutputPeakList:saveToFile( t.OutputPeakListName )

t = nil
</code>
<fld name='Creation Date' type='Date'>2007-5-10</fld>
</script>
<script name='SparkyAssignmentsToCara'>
<code lang='Lua'>-- Description: this script reads in a Sparky assignment file generated with the
-- Sparky command Peak-Resonances-Resonance List "rl" and generates the spins
-- with the correct assignments in systems which are already assigned to the residues

-- The script assumes that the sparky file has the suffix '.shifts' e.g. 'Myassignments.shifts'
-- and that a project exists where the sequence has been read in.
-- If there is more than one project in the repository, the user must edit 'ProjectName' below
-- to have the name of the target project

--Version 1
-- author Fred Damberger
Version = "Version 1: 27. Jan. 2009"


-- USER EDITABLE PARAMETERS SECTION -------------------------------------------------------------------
NumHeader = 2 -- number of lines at start of file to ignore (header)
ProjectName = "MyprojectsName" -- edit this to correspond to the name of the project
IncludeInfo = false -- set to true if you want a report of which assigned resonances were ignored
                    -- otherwise set to false
-- END OF USER EDITABLE PARAMETERS --------------------------------------------------------------------

-- Function Definitions

function GetLine( Line )
	--print("GetLine")
	i = 0
	LineTbl = {}
	for Word in string.gfind( Line, ("%S+") ) do
		i = i + 1
		--print("=== "..i.." === "..Word)
		LineTbl[ i ] = Word
		if i&gt;20 then error("found line with more than 20 elements. This cannot be a Sparky assignment file!") end
	end
	if i == 6 then
		return LineTbl
	else
		return nil
	end
end

function CreateSpin( ResName, AtomName, Shift, LineNum )
	WrongAssignment = false
	AlreadyAssigned = false
	Assigned = false
--print("CreateSpin")
--print("ResName="..AtomName)
	StartChar,EndChar,String = string.find( ResName,"(%d+)" )
		if StartChar then
			--print("got ResidueNum = "..String)
			ResidueNum = tonumber( String )
		end
	StartChar,EndChar,String = string.find( ResName,"(%a)" )
		if StartChar then
			--print("got ResLetter = "..String )
			ResLetter = String
		end
	AtomType=nil
	Residue=Project:getResidue(ResidueNum)
	if Residue then
		System=Residue:getSystem()
		--if System then print("System found with id "..System:getId()) end
		if not System then
			System=Project:createSystem()
			
			--print( "=== System === "..System:getId() )
			Project:assignSystem( System, Residue )
		end -- if not System
		--print("AtomName "..AtomName)
		if AtomName == "HN" then
			AtomName = "H"
			if Messages == MessageHeader then
				Warning=Warning.."\nGENERAL WARNING: File uses old nomenclature for amide protons 'HN'. Correct nomenclature in BMRB format is 'H'.\nConverting 'HN' to 'H' automatically"
			end
		end -- convert to BMRB nomenclature
		StartChar,EndChar,String = string.find( AtomName,"(%a+)" )
		if StartChar then
			j=0
			for Letter in string.gfind( AtomName, ("%a") ) do
				j = j + 1
				if j==1 then
					AtomType = string.upper( Letter )
				end
			end
		end -- if StartChar
		if AtomType then
			--check for correct assignment
			ResType=Residue:getType()
			-- check whether ResLetter in file matches ResType in sequence 
			if ResLetter~=ResType:getLetter() then
				Warnings = Warnings.."\nWARNING Ignoring Line "..LineNum..": Residue name "..ResName.." is not consistent with the Residue in the sequence "..ResType:getLetter()..ResidueNum
				WrongAssignment = true
			end
			-- check whether AtomName in file matches an AtomName or AtomGroup from the ResidueType of the Residue at position ResidueNum in the sequence
			if not ResType:getAtom( AtomName ) and not ResType:getAtomGroup( AtomName ) then
				Warnings = Warnings.."\nWARNING Ignoring Line "..LineNum..": "..AtomName.." is not consistent with any AtomNames in Residue "..ResName
				WrongAssignment = true
			end
			-- check whether the Atom is already assigned
			for SpinOfResId,SpinOfRes in pairs( System:getSpins() ) do
				if SpinOfRes:getLabel() == AtomName then
					Info = Info.."\nINFO Ignoring Line "..LineNum..": The Atom "..AtomName.." from residue "..ResType:getLetter()..ResidueNum.." is already assigned in this project."
					AlreadyAssigned = true
				end
			end
			--print("AtomType "..AtomType)
			if not WrongAssignment and not AlreadyAssigned then
				Assigned = true
				Spin = Project:createSpin( AtomType, Shift)
				Project:assignSpin( Spin, System )
				Project:setLabel( Spin, AtomName ) 
			end
		end -- if AtomType
	end -- if Residue
	return WrongAssignment,AlreadyAssigned,Assigned
end -- function
-- end of functions -------------------------------------------------

Project=cara:getProject()
MessageHeader = " ------- MESSAGES for the USER -------\nIgnoring first two lines which are normally header of Sparky assignments file."
Messages =  MessageHeader -- create the messages text
Warnings = " ------- WARNINGS -------  "
Info = " -------- INFO -------- "
--1. Get OneLetterCode File Location
local ListFileLocation = dlg.getOpenFileName( "Select the one letter residue code file", "*.shifts" )

local ListFile = io.open( ListFileLocation )
local NotEof = true


--3. Read in the ListFile and create the assignments

-- Read in Statistics

local NumLines = 0
local NotFinished = true
local NumReps = 0
NumRes = 0
NumAssigned = 0
NumIgnoredDueToWrongAssignment = 0
NumIgnoredDueToAlreadyAssigned = 0
NumLinesWithNonStandardFormat = 0
while NotFinished and NumReps &lt; 20000 do
	LineOfFile = ListFile:read()
	if LineOfFile then
		NumReps = NumReps + 1
		--print("found LineOfFile")
		--StartChar,EndChar,String = string.find( Line,"(%a+)" )
		LineTable = {}
		LineTable = GetLine( LineOfFile )
		if NumReps &gt;NumHeader then
			if LineTable then
				--print("LineTable")
				ResName=LineTable[1]
				AtName=LineTable[2]
				Nuc=LineTable[3]
				Shift=LineTable[4]
				SDshift=LineTable[5]
				NumAss=LineTable[6]
				--[[
				for a,b in pairs(LineTable) do
					print(a,b)
				end
				]]
				WrongAssignment,AlreadyAssigned,Assigned = CreateSpin(ResName,AtName,Shift,NumReps)
				if WrongAssignment or AlreadyAssigned then
					if WrongAssignment then
						NumIgnoredDueToWrongAssignment = NumIgnoredDueToWrongAssignment + 1
					else
						NumIgnoredDueToAlreadyAssigned = NumIgnoredDueToAlreadyAssigned + 1
					end
				else
					if Assigned then
						NumAssigned = NumAssigned + 1
					end
				end
			else -- not LineTable
				Warnings = Warnings.."\nWARNING Ignoring Line "..LineNum..": nonsparky format (does not have exactly 6 items separated by spaces)\nLine appears on next line of output"
				Warnings = Warnings.."\n"..LineOfFile
				NumLinesWithNonStandardFormat = NumLinesWithNonStandardFormat + 1
			end -- if LineTable
		end -- NumReps &gt; 2
	else -- if not LineOfFile
		--print("+++++++++++++ FINISHED ++++++++++++++")
		NotFinished = false
	end -- if LineOfFile
end -- while NotFinished

ListFile:close()
Messages = MessageHeader
if IncludeInfo then Messages = Messages.."\n"..Info end
Messages =  Messages.."\n"..Warnings
print( " ---------------------------------------------------------------")
print( Messages )
print( "----------------------------------------------------------------")
print( "After editing the file "..ListFileLocation.." you can repeat this script.\nAtoms that are already assigned will be ignored")
print( "If you want to start with an empty project, use the script RemoveSelectedSystems.lua to delete existing systems")
print( " ---------------------------------------------------------------")
print( "Number of lines ignored at top of file (header)         : "..NumHeader )
print( "Number of lines ignored due to warnings                 : "..NumIgnoredDueToWrongAssignment )
print( "Number of lines ignored because of non standard format  : "..NumLinesWithNonStandardFormat )
print( "Number of lines ignored because atom is assigned already: "..NumIgnoredDueToAlreadyAssigned )
print( "Number of lines where a new assignment could be made    : "..NumAssigned )
print( "Number of lines read from file                          : "..NumReps )
print( " ---------------------------------------------------------------")
print( "SparkyAssignmentsToCara "..Version.." is finished")
</code>
<fld name='Creation Date' type='Date'>2012-7-27</fld>
</script>
<color code='1' name='#00ffff'/>
<color code='2' name='#00ffff'/>
<color code='3' name='#00ffff'/>
<color code='4' name='#008080'/>
<color code='5' name='#800080'/>
<color code='6' name='#808000'/>
<database>
</database>
<fld name='Creation Date' type='Date'>2012-7-27</fld>
<fld name='Description' type='Memo'></fld>
<fld name='#ext-delta#' type='Boolean'>true</fld>
<fld name='OrigTemplateDesc' type='Memo'>This template is intended for resonance assignment of 1H-labeled proteins, 15N-labeled proteins, and 13C/15N-labeled proteins. CLICK IN WINDOW TO SEE MORE INFO.

Residue Types:
ResidueTypes include all the standard amino acid residues in IUPAC nomenclature for compatibility with BMRB. Note that Sequence files and ProtonLists using the old nomenclature from Start1.1.cara must be converted to IUPAC nomenclature using the LUA scripts which are included. SEE BELOW FOR DETAILS.

Object Tables:
ResidueType, Spectrum and SpectrumType have Attributes which can be viewed from the corresponding Cara explorer window using "Open Object Table".
----------------------------------------------------------
Changes from Start1.1.cara:

Residue Types:
- Chemical shifts reflect the diamagnetic protein statistics of the BMRB of Jun-25-2010.  See ObjectTable for the date and SDmult used.

Spectrum Types:
- Added Labels in some Spectrum Types for better SynchroScope compatibility.
- altered some of the ave and dev values for triple resonance Spectrum Types to get better pathway simulation.

Spin System Types:
- available types are now ALA, GLY, ILE, LEU, PRO, THR, VAL, AMX and long.

Terminal:
- included both new and updated scripts. For a description of their function, click on the script and right-click "Edit Attributes". For more details "Open" the script and read the header.
-----------------------------------------------------------
BMRB conversion scripts

- BMRB file to Project:
1) read in a BMRB str file as a project by using the standard menu item "Project-Import Project from BMRB". 
2) Afterwards run the script "ReplaceDegenerateSpinsByGroup.lua" to remove the degenerate spins from the BMRB file (see "Edit Attributes" or the header to script for details)

- importing Xeasy files to Start1.2.cara :
1) convert sequence file to Start1.2.cara compatible format (only three letter code allowed) using LUA script XeasySeqTo3Letter.lua
2) convert protonlist file to Start1.2.cara compatible format (e.g. HN -&gt; H) using LUA script XeasyToBmrbLabelsInProtonList.lua
3) Load these into a new project using "Project-Import Project From Sequence"  and "ProjectName-Import AtomList".
4) To import Alias shifts to the new project, use the LUA script "PeakListToAliases.lua"

- Start1.1.cara project to Start1.2.cara project:
1) Write out sequence and protonlist using "ProjectName-Export-Sequence" and "Export-AtomList"
2) Do the same steps as above for importing Xeasy files to Start1.2.cara.

- Cara Project to BMRB deposit (chemical shifts only)
1) Run the LUA script BmrBDeposit.lua

Note: To work with NEASY using IUPAC/BMRB nomenclature, you will need to load "ll" the modified XEASY library file ecepp_bmrb.lib available at the CARA website.
</fld>
<fld name='OrigTemplateDate' type='Date'>2005-3-23</fld>
<fld name='TemplateDate' type='Date'>2010-6-10</fld>
<fld name='TemplateDesc' type='Memo'></fld>
</repository>
