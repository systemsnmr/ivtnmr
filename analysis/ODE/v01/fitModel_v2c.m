function s = fitModel_v2c(model,data,actp,pinit,lb,ub,options)
% s = fitModel(model,data,[actp,pinit,lb,ub,options])
%
% Least-squares based parameter estimation in ODE systems including an
% observation function. fitModel employs the lsqnonlin function of MATLABs
% optimization toolbox. It uses the odeM integration routine to calculate
% the solution of the ODE and the sensitivity equations.
%
% Input arguments:
% 
% model = model structure as returned by model4fit
% data = data structure with entries
%        data.t = time points T
%        data.y = N times T matrix with measurement values of N observations
%        data.s = standard deviation of the measurement error
%        data.bootidx = random sample for bootstrap
%
% actp (optional) = index vector with parameters to fit. Default = all parameters
% pinit (optional) = initial values of all parameters. Default = as
%                    defined in model structure
% lb (optional) = lower bound for each parameter. Default = as
%                 defined in model structure
% ub (optional) = upper bound for each parameter. Default = as
%                 defined in model structure
% options (optional) = options structure passed to lsqnonlin (generated by
%                      optimset). This is an optional argument. The default
%                      is = optimset('Jacobian','On')
%
% Fitting results are return in a structure with the following entries
% 
% actp = optimized parameters
% pinit = inital parameters values
% popt = optimized parameter values
% cov = covariance matrix of parameters
% corr = correlation matrix of parameters
% conf = (symmetric) confidence intervals of the parameter values 
% res = residuals at the optimum
% chi2.v = Chi2 value (sum of squared residuals)
% chi2.dof = degrees of fredom of the Chi2 test
% chi2.p = P-value of the goodness of fit test
% R2 = R squared value defined as 1-sse/sst. sse = sum of squares of
%      non-normalized residuals, sst = total sum of squares 
% J = gradient of the residuals
% int = structure returned by odeM 
% tlaps = elapsed time

%========================================================
% TODO - flag to fit from log-fit to normal
%========================================================

%%%%%
% fitModel_v2b8_bootstrap:
debugOutput = 0;

if nargin<2
  help fitModel
  error('At least 2 input arguments required!')
end

% check input arguments
if ~exist('actp','var') | isempty(actp)
  actp = 1:nvar+npar;
end
if ~exist('pinit','var') | isempty(pinit)
  pinit = [model.par_init model.var_init];
end
if ~exist('lb','var') | isempty(lb)
  lb = [model.par_min model.var_min];
end
if ~exist('ub','var') | isempty(ub)
  ub = [model.par_max model.var_max];
end

ndata = length(data.t);
nvar = model.nvar;
nobs = model.nobs;
npar = model.npar;

% error check
if any(actp>nvar+npar)
  error(sprintf('Not correct active parameter index! 1 <= actp <= %d.',npar))
end

% process input
if length(pinit) == npar
  pinit = [pinit(:); model.var_init(:)]';
end
fit.pinit = pinit;
fit.ptot = pinit;
fit.actp = actp; % active (=estimated) parameters
fit.p = pinit(actp);
fit.lb = lb(actp);
fit.ub = ub(actp);

% lsqnonlin options
if ~(nargin == 7)
   options = optimset('Jacobian','On');
end

% report options
hoptions.output = 0;

if hoptions.output > 0 
  % plot initial solution
  int = odeM(model,[data.t(1) data.t(end)],fit.ptot);
  plotSolution(int.tr,int.yr,data.t,data.y)
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% nonlinear least-squares optimization (lsqnonlin)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
tstart = tic;
[popt,rsn,resid,flag,out,l,J] = ...
    lsqnonlin(@(x) optfun_bootstrap(x,model,data,fit,hoptions),fit.p,fit.lb,fit.ub,options);
tlaps = toc(tstart);

% update
fit.ptot(fit.actp) = popt;

if hoptions.output > 0 
  % plot final solution
  int = odeM(model,[data.t(1) data.t(end)],fit.ptot);
  plotSolution(int.tr,int.yr,data.t,data.y)
end

% % YarN. debug. - used to check if final J and r returned by lsqnonlin are
% % the same (already bootstrapped) ones in the optfun
% Jfitm = full(J(1:10,1:10))
% rfitm = resid(1:10)

%%% Collect results
s = struct;
s.tlaps = tlaps;
s.pinit = fit.pinit;
s.popt = fit.ptot;
s.actp = fit.actp;
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% post-regression statistics 
% (for details see e.g. Numerical recepies, Press et al. 1992, chapter 15)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

int = odeM(model,data.t,fit.ptot);
int0 = int; % save full structure (store full curve doing bootstrap)

% Adjust results of the fits - for when fitting done with bootstrap
if isfield(data,'bootidx')
    bix = data.bootidx;
    int.t = int.t(bix,:);
    int.x = int.x(:,bix);
    int.y = int.y(:,bix);
    int.dxdp = int.dxdp(:,:,bix);
    int.dxdx0 = int.dxdx0(:,:,bix);
    int.dydp = int.dydp(:,:,bix);
    int.dydx0 = int.dydx0(:,:,bix);
    
    data.y = data.y(:,bix);
    data.s = data.s(:,bix);
end

% @YarN (2016-06-01):
% The resid returned by lsqnonlin is already normalized by error!
% But here is a pure residual:
res = int.y(:)-data.y(:);
sse = res'*res; % non-normalyzed residuals. Same as SSR (sum of squared residuals) and RSS (residual sum of squares)
sst = data.y-repmat(mean(data.y,2),1,ndata);
sst = sum(sst(:).^2);
R2 = 1-sse/sst;

% @YaroslavN. 2014-09-29. Modified calculation of C after the warnings:
% Warning: Matrix is close to singular or badly scaled.
% Results may be inaccurate. RCOND = 7.589744e-35.
% See "Model fit for IVTNMR of SMNv10" - Task11bug1
% evernote:///view/350340/s4/54c4a3c5-002f-41ad-a69d-0cc0701e55fe/54c4a3c5-002f-41ad-a69d-0cc0701e55fe/

% C = 2*inv(full(J)'*full(J)); % Original mean to calculate Covariance (C)
% save('C_inv.mat','C'); % used for comparing results of C calculation
% clear C;

[Q,R] = qr(full(J),0);
S = inv(R);
C = 2*(S*S');
% save('C_qr.mat','C'); % used for comparing results of C calculation


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Calculation of covariance based on MSE, not factor 2:
% http://ch.mathworks.com/matlabcentral/newsreader/view_thread/86198

% DO NOT USE R2 here!! - It is used in the post-reg stats!!!
[Qf2,Rf2] = qr(full(J),0);
r = res; % @Y: <resnorm> is a SCALAR, so have to use <residual>
mse = sum(abs(r).^2)/(size(full(J),1)-size(full(J),2)); % Mean Squared Error = Sum of Squares / N
Rinv = inv(Rf2);
C = Rinv*Rinv'*mse; % Covariance matrix - was Sigma in MathWorks notation.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


corr = C./sqrt(diag(C)*diag(C)');
level = 0.95;
fac = sqrt(2)*erfinv(2*(1-(1-level)/2)-1); % is 1.96 for level = 0.95


% Assuming sqrt(diag(C)) = SD, unlike sqrt(diag(C)) = SEM - from original
% procedure:
dof = ndata*nobs-length(fit.actp);
sd = sqrt(diag(C))'; % SD does not change if n is large - since it reflects the variance of data!
sem = sd ./ sqrt(ndata); % SEM shrinks as n grows 
confi = sem .* fac; % CI also shrinks as n grows 

% This is already calculated above
% SEM from CI derivation: Task7 in evernote:///view/350340/s4/d8351a89-506c-413b-afb5-49132cc41d22/d8351a89-506c-413b-afb5-49132cc41d22/
% For SEM could simplify to 1-0.05/2. But to make use of level have to do 1-(1-level)/2.
% using DOF/nobs, because CI is per-observable, and not for ALL observables.
CItoSEMfactor = tinv(1-(1-level)/2, round(dof/nobs));
if debugOutput
fprintf(1, 'SEM from CI (level=%.2f, dof/nobs=%.1f) = CI / %.2f \n', level, round(dof/nobs), CItoSEMfactor);
% sem = confi ./ CItoSEMfactor;
end

% chi2 = resid'*resid; % SEE Task8 in "Parameter confidence..." evernote:///view/350340/s4/d8351a89-506c-413b-afb5-49132cc41d22/d8351a89-506c-413b-afb5-49132cc41d22/
chi2 = res'*res;
gofP = 1 - gammainc(chi2/2,dof/2);

%%% Recalc of Chi2 - making use of errors in the data!
chi2_sigma = sum( (res ./ data.s(:)) .^2 ); % (O-E)^2 / sigma^2
chi2red_sigma = chi2_sigma ./ dof;
gofP_sigma = 1 - gammainc(chi2_sigma/2,dof/2);
i_sigma = true; % Whether to use x_sigma versions for calc of individual stats

%%% Calculating chi2red & gofP for individual observables:
% structure to keep individual statistics
i_stat = struct;
% get an "average" dof per observable - if splitting for individual observables
i_stat.dof = ndata - round( length(fit.actp)/nobs );
% Convert residuals from signle vector into matrix of correct form. Takes the number of observables, and splits the vector accordingly.
resMatrix = reshape(res, nobs, ndata); % will get same shape as data.s

i_stat.chi2 = zeros(nobs,1);
i_stat.chi2red = zeros(nobs,1);
i_stat.gofP = zeros(nobs,1);

for o = 1:nobs
    if i_sigma
        i_stat.chi2(o) = sum( (resMatrix(:,o) ./ data.s(:,o)) .^2 ); % (O-E)^2 / sigma^2
    else
        i_stat.chi2(o) = resMatrix(:,o)'*resMatrix(:,o);
    end
    i_stat.chi2red(o) = i_stat.chi2(o) / i_stat.dof;
    i_stat.gofP(o) = 1 - gammainc( i_stat.chi2(o)/2, i_stat.dof/2);
end
    

%%% Display post-regression infos to the console
% if hoptions.output > 0 %YN DEBUG 2015-01-06
if debugOutput %YN DEBUG 2015-01-06
  % print results
  disp('Summary of minimization results');
  fprintf(1,'\nMinimization took %.4f seconds \n', tlaps)
  names = [model.par_names cellfun(@(x) sprintf('%s init',x), model.var_names,'UniformOutput',0)];
  fprintf(1,'\nFitted parameters: optimum and %.2f confidence interval\n', level)
  for k=1:length(fit.actp)
%     fprintf(1,'%s: %.4f +- %.4f \n',names{fit.actp(k)},fit.ptot(fit.actp(k)),confi(k))
    fprintf(1,'%s: %.1g +- %.1g \n',names{fit.actp(k)},fit.ptot(fit.actp(k)),confi(k))
  end
  fprintf(1,'\nChi2 value = %.4f (%d degrees of freedom) \n', chi2, dof)
  fprintf(1,'Chi2red (chi2/dof) = %.4f (good if close to 1) \n', chi2/dof)
  fprintf(1,'Goodness of fit: P(X>=Chi2) = %.4f \n', gofP)
  fprintf(1,'R squared value = %.4f \n', R2)

  fprintf(1,'\n== Chi2, Chi2red and GOF values when using (O-E)/SIGMA \n')
  fprintf(1,'Chi2 value = %.4f (%d degrees of freedom) \n', chi2_sigma, dof)
  fprintf(1,'Chi2red (chi2/dof) = %.4f (good if close to 1) \n', chi2_sigma/dof)
  fprintf(1,'GOF: P(X>=Chi2) = %.4f \n', gofP_sigma)
  fprintf(1,'R squared value = %.4f \n', R2)
end

%%% Collect results
% s = struct;
% s.tlaps = tlaps;
% s.pinit = fit.pinit;
% s.popt = fit.ptot;
% s.actp = fit.actp;

s.i_stat = i_stat; % add individual statistics per observable
s.res = resid;
s.resManual = res;
s.chi2.v = chi2;
s.chi2.dof = dof;
s.chi2.p = gofP;
s.chi2red = chi2 / dof;
s.J = J;
s.cov = C;
s.corr = corr;
s.conf = confi;
s.level = level;
s.sd = sd;
s.sem = sem;
s.R2 = R2;
s.int = int;
s.int0 = int0;

% Post-regression stats using actual error fromt he measurement
s.chi2_sigma = chi2_sigma;
s.chi2red_sigma = chi2red_sigma;
s.gofP_sigma = gofP_sigma;

